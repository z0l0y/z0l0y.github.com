<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java9到22的一些新特性</title>
    <url>/2024/09/10/Java22-new-features/</url>
    <content><![CDATA[<h2 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h2><h3 id="接口里面可以声明私有方法了"><a href="#接口里面可以声明私有方法了" class="headerlink" title="接口里面可以声明私有方法了"></a>接口里面可以声明私有方法了</h3><p>在JDK9中新增了接口私有方法，我们可以在接口中声明private修饰的方法了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 定义私有方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">solution</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改进try-with-resource"><a href="#改进try-with-resource" class="headerlink" title="改进try with resource"></a>改进try with resource</h3><p>Java7中新增了try with resource语法用来自动关闭资源文件，在IO流和JDBC部分使用的比较多。</p>
<p><strong>使用方式是将需要自动关闭的资源对象的创建放到try后面的小括号中，在JDK9中我们可以将这些资源对象的创建代码放到小括号外面，然后将需要关闭的对象名放到try后面的小括号中即可</strong>，示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    改进了try-with-resources语句，可以在try外进行初始化，在括号内填写引用名，即可实现资源自动关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryWithResource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">// JDK8以前</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">             <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JDK9</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 多资源用分号隔开</span></span><br><span class="line">        <span class="keyword">try</span> (fis; fos) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不能使用下划线命名变量"><a href="#不能使用下划线命名变量" class="headerlink" title="不能使用下划线命名变量 __"></a>不能使用下划线命名变量 __</h3><p>下面语句在JDK9之前可以正常编译通过，但是在JDK9（含）之后编译报错，在后面的版本中会将下划线作为关键字来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">_</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="String字符串的变化"><a href="#String字符串的变化" class="headerlink" title="String字符串的变化"></a>String字符串的变化</h3><p>写程序的时候会经常用到String字符串，在以前的版本中String内部使用了char数组存储，对于使用英语的人来说，一个字符用一个字节就能存储，使用char存储字符会浪费一半的内存空间，因此在JDK9中将String内部的char数组改成了byte数组，这样就节省了一半的内存占用。</p>
<p>String中增加了下面2个成员变量</p>
<ul>
<li>COMPACT_STRINGS：判断是否压缩，默认是true，若为false，则不压缩，使用UTF16编码</li>
<li>coder用来区分使用的字符编码，分别为LATIN1（值为0）和UTF16（值为1）</li>
</ul>
<p>byte数组如何存储中文呢？通过源码（StringUTF16类中的toBytes方法）得知，<strong>在使用中文字符串时，1个中文会被存储到byte数组中的两个元素上</strong>，即存储1个中文，<strong>byte数组长度为2，存储2个中文，byte数组长度为4</strong>。</p>
<p>以如下代码为例进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;好&quot;</span></span><br></pre></td></tr></table></figure>

<p>好对应的Unicode码二进制为0101100101111101，**分别取出高8位和低8位，放入到byte数组中{01011001,01111101}**，这样就利用byte数组的2个元素保存了1个中文。</p>
<p>当字符串中存储了<strong>中英混合的内容时，1个英文字符会占用2个byte数组位置</strong>。</p>
<p>在获取字符串长度时，若存储的内容存在中文，是不能直接获取byte数组的长度作为字符串长度的，String源码中有向右移动1位的操作（即除以2），这样才能获取正确的字符串长度。</p>
<h3 id="Deprecated注解的变化"><a href="#Deprecated注解的变化" class="headerlink" title="@Deprecated注解的变化"></a>@Deprecated注解的变化</h3><p>该注解用于标识废弃的内容，在JDK9中新增了2个内容：</p>
<ul>
<li>String since() default “”：标识是从哪个版本开始废弃</li>
<li>boolean forRemoval() default false：标识该废弃的内容会在未来的某个版本中移除</li>
</ul>
<h3 id="jshell"><a href="#jshell" class="headerlink" title="jshell"></a>jshell</h3><p>在一些编程语言中，例如：python，Ruby等，都提供了REPL（Read Eval Print Loop 简单的交互式编程环境）。jshell就是Java语言平台中的REPL。</p>
<p>有的时候我们只是想写一段简单的代码，例如HelloWorld，按照以前的方式，还需要自己创建Java文件，创建class，编写main方法，但实际上里面的代码其实就是一个打印语句，此时还是比较麻烦的。在JDK9中新增了jshell工具，可以帮助我们快速的运行一些简单的代码。</p>
<p>从命令提示符里面输入jshell，进入到jshell之后输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/10/Java22-new-features/image-20240911000358964.png" alt="image-20240911000358964"></p>
<p>如果要退出jshell的话，输入&#x2F;exit即可。</p>
<h2 id="Java10新特性"><a href="#Java10新特性" class="headerlink" title="Java10新特性"></a>Java10新特性</h2><h3 id="局部变量类型推断-var"><a href="#局部变量类型推断-var" class="headerlink" title="局部变量类型推断 var"></a>局部变量类型推断 var</h3><p>在JDK10以前声明变量的时候，我们会像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">oldName</span> <span class="operator">=</span> <span class="string">&quot;jack&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">oldAge</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">oldMoney</span> <span class="operator">=</span> <span class="number">88888888L</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">oldObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>上面我们声明的时候使用了4种不同类型的变量，在JDK10中前面的类型都可以使用var来代替，JVM会自动推断该变量是什么类型的，例如可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">newName</span> <span class="operator">=</span> <span class="string">&quot;jack&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">newAge</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">newMoney</span> <span class="operator">=</span> <span class="number">88888888L</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">newObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><strong>当然这个var的使用是有限制的，仅适用于局部变量，增强for循环的索引，以及普通for循环的本地变量；它不能使用于方法形参，构造方法形参，方法返回类型等。</strong></p>
<p>除了上面的新特性之外，还对JVM进行了一些优化，这里就不罗列了。</p>
<h2 id="Java11新特性"><a href="#Java11新特性" class="headerlink" title="Java11新特性"></a>Java11新特性</h2><h3 id="直接运行-java"><a href="#直接运行-java" class="headerlink" title="直接运行 java"></a>直接运行 java</h3><p>在以前的版本中，我们在命令提示下，需要先编译，生成class文件之后再运行，例如：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">javac HelloWorld.java</span><br><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure>

<p>在java 11中，我们可以这样直接运行</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">java HelloWorld.java</span><br></pre></td></tr></table></figure>

<p>去掉了 javac 的环节，可以直接使用java来运行代码，而且如果你的代码有其他对象的引用，也是没有任何问题的。</p>
<p><strong>可以帮助我们做一个级联的无感知编译。</strong></p>
<h3 id="lambda表达式中的变量类型推断"><a href="#lambda表达式中的变量类型推断" class="headerlink" title="lambda表达式中的变量类型推断"></a>lambda表达式中的变量类型推断</h3><p>JDK11中允许在lambda表达式的参数中使用var修饰</p>
<p>函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">(String a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支持lambda表达式参数中使用var</span></span><br><span class="line"><span class="type">MyInterface</span> <span class="variable">mi</span> <span class="operator">=</span> (<span class="keyword">var</span> a,<span class="keyword">var</span> b)-&gt;&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mi.m1(<span class="string">&quot;monkey&quot;</span>,<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Java12新特性"><a href="#Java12新特性" class="headerlink" title="Java12新特性"></a>Java12新特性</h2><h3 id="升级的switch语句"><a href="#升级的switch语句" class="headerlink" title="升级的switch语句"></a>升级的switch语句</h3><p>在JDK12之前的switch语句中，如果没有写break，则会出现case穿透现象，下面是对case穿透的一个应用，根据输入的月份打印相应的季节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;summer&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;autumn&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;winter&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;wrong&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JDK12之后我们可以省略全部的break和部分case，这样使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">switch</span> (month) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> -&gt; System.out.println(<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> -&gt; System.out.println(<span class="string">&quot;summer&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span> -&gt; System.out.println(<span class="string">&quot;autumn&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>, <span class="number">1</span>,<span class="number">2</span> -&gt; System.out.println(<span class="string">&quot;winter&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;wrong&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个是预览功能，如果需要编译和运行的话需要使用下面命令，预览功能在2个版本之后会成为正式版，即如果你使用的是JDK14以上的版本，正常的编译和运行即可。否则需要使用预览功能来编译和运行</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">编译:</span><br><span class="line">javac --enable-preview -source 12 Test.java</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">java --enable-preview Test</span><br></pre></td></tr></table></figure>

<h2 id="Java13新特性"><a href="#Java13新特性" class="headerlink" title="Java13新特性"></a>Java13新特性</h2><h3 id="升级的switch语句-1"><a href="#升级的switch语句-1" class="headerlink" title="升级的switch语句"></a>升级的switch语句</h3><p>JDK13中对switch语句又进行了升级，<strong>可以switch的获取返回值</strong></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">switch</span> (month) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> -&gt; <span class="string">&quot;spring&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> -&gt; <span class="string">&quot;summer&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span> -&gt; <span class="string">&quot;autumn&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>, <span class="number">1</span>,<span class="number">2</span> -&gt; <span class="string">&quot;winter&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="string">&quot;wrong&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>对于JDK15之后的版本可以直接编译和运行，否则需要使用下面命令执行该预览功能</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">编译:</span><br><span class="line">    javac --enable-preview -source 13 Test.java</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">    java --enable-preview Test</span><br></pre></td></tr></table></figure>

<h3 id="文本块的变化-Python的插值表达式-fstring"><a href="#文本块的变化-Python的插值表达式-fstring" class="headerlink" title="文本块的变化 Python的插值表达式 fstring"></a>文本块的变化 Python的插值表达式 fstring</h3><p>在JDK13之前的版本中如果输入的字符串中有换行的话，需要添加换行符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello\nWorld\nLearn\nJava&quot;</span>;</span><br><span class="line">    System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>JDK13之后可以直接这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            Hello</span></span><br><span class="line"><span class="string">            World</span></span><br><span class="line"><span class="string">            Learn</span></span><br><span class="line"><span class="string">            Java</span></span><br><span class="line"><span class="string">           &quot;&quot;&quot;</span>;</span><br><span class="line">  System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>这样的字符串更加一目了然。</p>
<h2 id="Java14新特性"><a href="#Java14新特性" class="headerlink" title="Java14新特性"></a><strong>Java14新特性</strong></h2><p>java 14 新增了很多特性，我们针对较为突出的特性进行说明。JDK12和JDK13中预览版的switch特性，在JDK14中已经是正式的语法了。</p>
<h3 id="instanceof模式匹配"><a href="#instanceof模式匹配" class="headerlink" title="instanceof模式匹配"></a>instanceof模式匹配</h3><p><strong>该特性可以减少强制类型转换的操作</strong>，简化了代码，代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInstanceof</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// JDK14之前的写法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer)obj;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + <span class="number">10</span>;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JDK14新特性  不用再强制转换了</span></span><br><span class="line">        <span class="comment">// 这里相当于是将obj强制为Integer之后赋值给i了</span></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Integer i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + <span class="number">10</span>;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 作用域问题，这里是无法访问i的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是预览版的功能所以需要使用下面命令编译和运行</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">编译:</span><br><span class="line">    javac --enable-preview -source 14 TestInstanceof.java</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">    java --enable-preview TestInstanceof</span><br></pre></td></tr></table></figure>

<h3 id="友好的空指针（NullPointerException）提示"><a href="#友好的空指针（NullPointerException）提示" class="headerlink" title="友好的空指针（NullPointerException）提示"></a>友好的空指针（NullPointerException）提示</h3><p>JDK14中添加了对于空指针异常友好的提示，便于开发者快速定位空指针的对象。示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Machine</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Machine machine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Engine engine;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNull</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 这里会报出空指针，但是哪个对象是null呢？</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Car</span>().engine.machine.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在运行上面代码的时候，错误信息就可以明确的指出那个对象为null了。此外，还可以使用下面参数来查看:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">java -XX:+ShowCodeDetailsInExceptionMessages TestNull</span><br></pre></td></tr></table></figure>

<p>这样编译器会明确的告诉开发者哪个对象是null。</p>
<h3 id="record类型"><a href="#record类型" class="headerlink" title="record类型"></a>record类型</h3><p>之前在编写javabean类的时候，<strong>需要编写成员变量，get方法，构造方法，toString方法，hashcode方法，equals方法。这些方法通常会通过开发工具来生成，在JDK14中新增了record类型，通过该类型可以省去这些代码的编写。</strong></p>
<p>JDK14编写User</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">User</span><span class="params">(String name,Integer age)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>通过反编译命令可以看到该字节码文件中的内容，<strong>User类</strong>是继承了Record类型：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">javap -p -private user</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUser</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">15</span>);</span><br><span class="line">        System.out.println(u);</span><br><span class="line">        System.out.println(u.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是预览版的功能所以需要使用下面命令编译和运行</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">编译:</span><br><span class="line">javac --enable-preview -source 14 TestUser.java</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">java --enable-preview TestUser</span><br></pre></td></tr></table></figure>

<p>记录类型有自动生成的成员，包括：</p>
<ul>
<li><strong>状态描述中的每个组件都有对应的private final字段。</strong></li>
<li><strong>状态描述中的每个组件都有对应的public访问方法。方法的名称与组件名称相同。</strong></li>
<li><strong>一个包含全部组件的公开构造器，用来初始化对应组件。</strong></li>
<li><strong>实现了equals()和hashCode()方法。equals()要求全部组件都必须相等。</strong></li>
<li><strong>实现了toString()，输出全部组件的信息。</strong></li>
</ul>
<h2 id="Java15新特性"><a href="#Java15新特性" class="headerlink" title="Java15新特性"></a><strong>Java15新特性</strong></h2><p>java 15中更新了一些新的内容，这里仅列出对于写代码方面的新特性。</p>
<h3 id="Sealed-Classes"><a href="#Sealed-Classes" class="headerlink" title="Sealed Classes"></a>Sealed Classes</h3><p>密封类和接口，作用是限制一个类可以由哪些子类继承或者实现。</p>
<ol>
<li>如果指定模块的话，sealed class和其子类必须在同一个模块下。如果没有指定模块，则需要在同一个包下。</li>
<li><strong>sealed class指定的子类必须直接继承该sealed class。</strong></li>
<li>sealed class的<strong>子类要用final修饰。</strong></li>
<li>sealed class的<strong>子类如果不想用final修饰的话，可以将子类声明为sealed class。</strong></li>
</ol>
<p>Animal类，在指定允许继承的子类时可以使用全限定名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">permits</span> Cat, Dog&#123;<span class="comment">// 多个子类之间用,隔开</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cat类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">    <span class="keyword">permits</span> Husky &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Husky类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Husky</span> <span class="keyword">extends</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        c.eat();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java16新特性"><a href="#Java16新特性" class="headerlink" title="Java16新特性"></a>Java16新特性</h2><p>这里只介绍一些跟开发关联度较大的特性，除此之外JDK16还更新了许多其他新特性，感兴趣的同学可以去Oracle官网查看</p>
<h3 id="包装类构造方法的警告"><a href="#包装类构造方法的警告" class="headerlink" title="包装类构造方法的警告"></a>包装类构造方法的警告</h3><p><strong>使用包装类的构造方法在编译的时候会出现警告，不建议再使用包装类的构造方法。</strong>下面代码在javac编译之后会出现警告。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p><strong>不建议使用包装类作为锁对象，倘若使用包装类作为锁对象，在编译时会出现警告。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(i)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="新增日时段"><a href="#新增日时段" class="headerlink" title="新增日时段"></a>新增日时段</h3><p>在DateTimeFormatter.ofPattern传入B可以获取现在时间对应的日时段，上午，下午等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(DateTimeFormatter.ofPattern(<span class="string">&quot;B&quot;</span>).format(LocalDateTime.now()));</span><br></pre></td></tr></table></figure>

<p>在之前JDK版本中作为预览功能的Record类，模式匹配的instanceof，打包工具jpackage，已成为正式版。JDK16对GC，JVM运行时内存等内容有一些变化，例如：<strong>ZGC并发栈处理</strong>，<strong>弹性meta space</strong></p>
<h2 id="Java17新特性"><a href="#Java17新特性" class="headerlink" title="Java17新特性"></a>Java17新特性</h2><p>java17是一个LTS（long term support）长期支持的版本，根据计划来看java17会支持到2029年（java8会支持到2030年，OMG），同时Oracle提议下一个LTS版本是java21，在2023年9月发布，这样讲LST版本的发布周期由之前的3年变为了2年。这里只介绍一些跟开发关联度较大的特性，除此之外JDK17还更新了一些其他新特性，感兴趣的同学可以从这里查看：<a href="https://www.oracle.com/news/announcement/oracle-releases-java-17-2021-09-14/">https://www.oracle.com/news/announcement/oracle-releases-java-17-2021-09-14/</a></p>
<h3 id="switch语法的变化-预览"><a href="#switch语法的变化-预览" class="headerlink" title="switch语法的变化(预览)"></a>switch语法的变化(预览)</h3><p>在之前版本中新增的instanceof模式匹配的特性在switch中也支持了，即我们可以在switch中减少强转的操作。比如下面的代码：</p>
<p>Rabbit和Bird均实现了Animal接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="comment">//特有的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="comment">//特有的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新特性可以减少Animal强转操作代码的编写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switch01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rabbit</span>();</span><br><span class="line">        animalEat(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">animalEat</span><span class="params">(Animal a)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">            <span class="comment">//如果a是Rabbit类型，则在强转之后赋值给r，然后再调用其特有的run方法</span></span><br><span class="line">            <span class="keyword">case</span> Rabbit r -&gt; r.run();</span><br><span class="line">            <span class="comment">//如果a是Bird类型，则在强转之后赋值给b，然后调用其特有的fly方法</span></span><br><span class="line">            <span class="keyword">case</span> Bird b -&gt; b.fly();</span><br><span class="line">            <span class="comment">//支持null的判断</span></span><br><span class="line">            <span class="keyword">case</span> <span class="literal">null</span> -&gt; System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;no animal&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该功能在java17中是预览的，编译和运行需要加上额外的参数:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">javac --enable-preview -source 17 Switch01.java</span><br><span class="line">java  --enable-preview Switch01</span><br></pre></td></tr></table></figure>

<h3 id="去除了AOT和JIT"><a href="#去除了AOT和JIT" class="headerlink" title="去除了AOT和JIT"></a>去除了AOT和JIT</h3><p>AOT（Ahead-of-Time）是java9中新增的功能，可以先将应用中中的字节码编译成机器码。</p>
<p>Graal编译器作为使用java开发的JIT（just-in-time ）即时编译器在java10中加入（注意这里的JIT不是之前java中的JIT，在JEP 317中有说明<a href="https://openjdk.java.net/jeps/317"><strong>https://openJDK.java.net/jeps/317</strong></a>）。</p>
<p>以上两项功能由于使用量较少，且需要花费很多精力来维护，因此在java17中被移除了。当然你可以通过Graal VM来继续使用这些功能。</p>
<h2 id="Java18新特性"><a href="#Java18新特性" class="headerlink" title="Java18新特性"></a>Java18新特性</h2><p>这里只介绍一些跟开发关联度较大的特性，除此之外JDK18还更新了许多其他新特性，感兴趣的同学可以去Oracle官网查看：</p>
<p><a href="https://www.oracle.com/java/technologies/javase/18-relnote-issues.html#NewFeature">https://www.oracle.com/java/technologies/javase/18-relnote-issues.html#NewFeature</a></p>
<h3 id="默认使用UTF-8字符编码"><a href="#默认使用UTF-8字符编码" class="headerlink" title="默认使用UTF-8字符编码"></a>默认使用UTF-8字符编码</h3><p>从JDK18开始，默认使用UTF-8字符编码。我们可以通过如下参数修改其他字符编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure>

<h3 id="将被移除的方法"><a href="#将被移除的方法" class="headerlink" title="将被移除的方法"></a>将被移除的方法</h3><p><strong>在JDK18中标记了Object中的finalize方法，Thread中的stop方法将在未来被移除。</strong></p>
<h3 id="简单的web服务器"><a href="#简单的web服务器" class="headerlink" title="简单的web服务器"></a>简单的web服务器</h3><p>可以通过jwebserver命令启动JDK18中提供的静态web服务器，可以利用该工具查看一些原型，做简单的测试。在命令提示符中输入jwebserver命令后会启动，然后在浏览器中输入:<a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> 即可看到当前命令提示符路径下的文件了。</p>
<h3 id="snippet注解"><a href="#snippet注解" class="headerlink" title="@snippet注解"></a>@snippet注解</h3><p>以前在文档注释中编写代码时需要添加code标签，使用较为不便，通过**@snippet注解可以更方便的将文档注释中的代码展示在api文档中。**</p>
<h2 id="Java19新特性"><a href="#Java19新特性" class="headerlink" title="Java19新特性"></a><strong>Java19新特性</strong></h2><h3 id="Virtual-Threads-Preview-（虚拟线程）"><a href="#Virtual-Threads-Preview-（虚拟线程）" class="headerlink" title="Virtual Threads (Preview)（虚拟线程）"></a>Virtual Threads (Preview)（虚拟线程）</h3><p>该特性在java19中是预览版，<strong>虚拟线程是一种用户态下的线程，类似go语言中的goroutines 和Erlang中的processes</strong>，虚拟线程并非比线程快，<strong>而是提高了应用的吞吐量，相比于传统的线程是由操作系统调度来看，虚拟线程是我们自己程序调度的线程</strong>。如果你对之前java提供的线程API比较熟悉了，那么在学习虚拟线程的时候会比较轻松，<strong>传统线程能运行的代码，虚拟线程也可以运行。虚拟线程的出现，并没有修改java原有的并发模型，也不会替代原有的线程</strong>。<strong>虚拟线程主要作用是提升服务器端的吞吐量。</strong></p>
<h4 id="吞吐量的瓶颈"><a href="#吞吐量的瓶颈" class="headerlink" title="吞吐量的瓶颈"></a>吞吐量的瓶颈</h4><p>服务器应用程序的伸缩性受<strong>利特尔法则（Little’s Law）</strong>的制约，与下面3点有关</p>
<ol>
<li>延迟：请求处理的耗时</li>
<li>并发量：同一时刻处理的请求数量</li>
<li>吞吐量：单位时间内处理的数据数量</li>
</ol>
<p>比如一个服务器应用程序的延迟是50ms，处理10个并发请求，则吞吐量是200请求&#x2F;秒（10 &#x2F; 0.05），如果吞吐量要达到2000请求&#x2F;秒，则处理的并发请求数量是100。<strong>按照1个请求对应一个线程的比例来看，要想提高吞吐量，线程数量也要增加。</strong></p>
<p><strong>java中的线程是在操作系统线程（OS thread）进行了一层包装，而操作系统中线程是重量级资源，在硬件配置确定的前提下，我们就不能创建更多的线程了，此时线程数量就限制了系统性能，为了解决该问题，虚拟线程就出现了。</strong></p>
<p><img src="/2024/09/10/Java22-new-features/image-20240911004144255.png" alt="image-20240911004144255"></p>
<p><strong>与虚拟地址可以映射到物理内存类似，java是将大量的虚拟线程映射到少量的操作系统线程，多个虚拟线程可以使用同一个操作系统线程，其创建所耗费的资源也是极其低廉的，无需系统调用和系统级别的上下文切换，且虚拟线程的生命周期短暂，不会有很深的栈的调用，一个虚拟线程的生命周期中只运行一个任务，因此我们可以创建大量的虚拟线程，且虚拟线程无需池化。</strong></p>
<h4 id="虚拟线程的应用场景"><a href="#虚拟线程的应用场景" class="headerlink" title="虚拟线程的应用场景"></a>虚拟线程的应用场景</h4><p>在服务器端的应用程序中，<strong>可能会有大量的并发任务需要执行，而虚拟线程能够明显的提高应用的吞吐量。下面的场景能够显著的提高程序的吞吐量</strong>：</p>
<ul>
<li>至少几千的并发任务量</li>
<li>任务为io密集型</li>
</ul>
<p>下面代码中为每个任务创建一个线程，当任务量较多的时候，你的电脑可以感受到明显的卡顿（如果没有，可以增加任务数量试下）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ExecutorService实现了AutoCloseable接口，可以自动关闭了</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool()) &#123;</span><br><span class="line">    <span class="comment">// 向executor中提交1000000个任务</span></span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">1000000</span>).forEach(</span><br><span class="line">        i -&gt; &#123;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 睡眠1秒，模拟耗时操作</span></span><br><span class="line">                    Thread.sleep(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行任务:&quot;</span> + i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的代码改成虚拟线程之后，电脑不会感受到卡顿了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newVirtualThreadPerTaskExecutor为每个任务创建一个虚拟线程</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">1000_000</span>).forEach(i -&gt; &#123;</span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 睡眠1秒，模拟耗时操作</span></span><br><span class="line">                Thread.sleep(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;执行任务:&quot;</span> + i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平台线程和虚拟线程"><a href="#平台线程和虚拟线程" class="headerlink" title="平台线程和虚拟线程"></a>平台线程和虚拟线程</h4><p>平台线程（platform thread）：<strong>指java中的线程，比如通过Executors.newFixedThreadPool()创建出来的线程，我们称之为平台线程。</strong></p>
<p>虚拟线程并不会直接分配给cpu去执行，而是通过调度器分配给平台线程，平台线程再被调度器管理。java中虚拟线程的调度器采用了工作窃取的模式进行FIFO的操作，调度器的并行数默认是JVM获取的处理器数量（通过该方法获取的数量Runtime.getRuntime().availableProcessors()），调度器并非分时（time sharing）的。在使用虚拟线程编写程序时，不能控制虚拟线程何时分配给平台线程，也不能控制平台线程何时分配给cpu。</p>
<p>以前任务和平台线程的关系：</p>
<p><img src="/2024/09/10/Java22-new-features/image-20240911004612979.png" alt="image-20240911004612979"></p>
<p>使用虚拟线程之后，任务-虚拟线程-调度器-平台线程的关系，1个平台线程可以被调度器分配不同的虚拟线程：</p>
<p><img src="/2024/09/10/Java22-new-features/image-20240911004633649.png" alt="image-20240911004633649"></p>
<h4 id="创建虚拟线程的方式"><a href="#创建虚拟线程的方式" class="headerlink" title="创建虚拟线程的方式"></a>创建虚拟线程的方式</h4><p>java中创建的虚拟线程本质都是通过Thread.Builder.OfVirtual对象进行创建的，我们后面再来讨论这个对象，下面先看下创建虚拟线程的三种方式：</p>
<p><strong>1.通过Thread.startVirtualThread直接创建一个虚拟线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行任务&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建虚拟线程将任务task传入并启动</span></span><br><span class="line">Thread.startVirtualThread(task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程睡眠，否则可能看不到控制台的打印</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>2.使用Thread.ofVirtual()方法创建</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建虚拟线程命名为诺手，将任务task传入</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">vt1</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;诺手&quot;</span>).unstarted(task);</span><br><span class="line">vt1.start();<span class="comment">// 启动虚拟线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程睡眠，否则可能看不到控制台的打印</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>也可以在创建虚拟线程的时候直接启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建虚拟线程命名为诺手，将任务task传入并启动</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">vt1</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;诺手&quot;</span>).start(task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程睡眠，否则可能看不到控制台的打印</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>3.通过ExecutorService创建</strong>，为每个任务分配一个虚拟线程，下面代码中提交了100个任务，对应会有100个虚拟线程进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过ExecutorService创建虚拟线程</span></span><br><span class="line"><span class="comment">    ExecutorService实现了AutoCloseable接口，可以自动关闭了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    <span class="comment">// 向executor中提交100个任务</span></span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">100</span>).forEach(i -&gt; &#123;</span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 睡眠1秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;                    </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在平台线程和虚拟线程都是Thread的对象，那该如何区分该对象是平台线程还是虚拟线程？可以利用Thread中的isVirtual()方法进行判断，返回true表示虚拟线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行任务&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建虚拟线程将任务task传入并启动</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">vt</span> <span class="operator">=</span> Thread.startVirtualThread(task);</span><br><span class="line">System.out.println(vt.isVirtual());</span><br></pre></td></tr></table></figure>

<h2 id="Java21新特性"><a href="#Java21新特性" class="headerlink" title="Java21新特性"></a><strong>Java21新特性</strong></h2><p>java20中没有太大的变化，这里主要聊下java21的新特性，21是继java17之后，最新的LTS版本，该版本中虚拟线程称为了正式版，对虚拟线程不了解的同学可以看下之前的java19中的介绍。接下来我们看下java21中一些新特性。</p>
<h3 id="字符串模板-STR"><a href="#字符串模板-STR" class="headerlink" title="字符串模板 STR"></a>字符串模板 STR</h3><p>字符串模板可以让开发者更简洁的进行字符串拼接（例如拼接sql，xml，json等）。该特性并不是为字符串拼接运算符+提供的语法糖，也并非为了替换SpringBuffer和StringBuilder。</p>
<p>这个和<strong>Python的插值表达式很类似，可以做变量的替换</strong>，多行文本的变量替换，还可以做一些计算 。 </p>
<p>利用STR模板进行字符串与变量的拼接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sport</span> <span class="operator">=</span> <span class="string">&quot;basketball&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> STR.<span class="string">&quot;i like \&#123;sport&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(msg);<span class="comment">// i like basketball</span></span><br></pre></td></tr></table></figure>

<p>这个特性目前是预览版，编译和运行需要添加额外的参数：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">javac --enable-preview -source 21 Test.java</span><br><span class="line">java --enable-preview Test</span><br></pre></td></tr></table></figure>

<p>在js中字符串进行拼接时会采用下面的字符串插值写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sport = <span class="string">&quot;basketball&quot;</span></span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">`i like <span class="subst">$&#123;sport&#125;</span>`</span></span><br></pre></td></tr></table></figure>

<p>看起来字符串插值写法更简洁移动，<strong>不过若在java中使用这种字符串插值的写法拼接sql，可能会出现sql注入的问题，为了防止该问题，java提供了字符串模板表达式的方式</strong>。</p>
<p>上面使用的STR是java中定义的模板处理器，<strong>它可以将变量的值取出，完成字符串的拼接。在每个java源文件中都引入了一个public static final修饰的STR属性，因此我们可以直接使用STR</strong>，STR通过打印STR可以知道它是java.lang.StringTemplate，是一个接口。</p>
<p>在StringTemplate中是通过调用interpolate方法来执行的，该方法分别传入了两个参数：</p>
<ul>
<li>fragements：包含字符串模板中所有的字面量，是一个List</li>
<li>values：包含字符串模板中所有的变量，是一个List</li>
</ul>
<p>而该方法又调用了JavaTemplateAccess中的interpolate方法，经过分析可以得知，它最终<strong>是通过String中的join方法将字面量和变量进行的拼接</strong>。</p>
<h3 id="scoped-values-传递参数时无需声明形参"><a href="#scoped-values-传递参数时无需声明形参" class="headerlink" title="scoped values 传递参数时无需声明形参"></a>scoped values 传递参数时无需声明形参</h3><h4 id="ThreadLocal的问题"><a href="#ThreadLocal的问题" class="headerlink" title="ThreadLocal的问题"></a>ThreadLocal的问题</h4><p>scoped values 是一个隐藏的方法参数，<strong>只有方法可以访问scoped values，它可以让两个方法之间传递参数时无需声明形参</strong>。例如在UserDao类中编写了saveUser方法，LogDao类中编写了saveLog方法，那么在保存用户的时候需要保证事务，此时就需要在service层获取Connection对象，然后将该对象分别传入到两个Dao的方法中，但对于saveUser方法来说并不是直接使用Connection对象，却又不得不在方法的形参中写上该对象，其实仅从业务上来看，该方法中只要传入User对象就可以了。</p>
<p>int saveUser(Connection connection,User user);</p>
<p><strong>对于上面的问题，开发者通常会使用ThreadLocal解决，但由于ThreadLocal在设计上的瑕疵，导致下面问题：</strong></p>
<ol>
<li><strong>内存泄漏，在用完ThreadLocal之后若没有调用remove，这样就会出现内存泄漏。</strong></li>
<li><strong>增加开销，在具有继承关系的线程中，子线程需要为父线程中ThreadLocal里面的数据分配内存。</strong></li>
<li><strong>混乱的可变，任何可以调用ThreadLocal中get方法的代码都可以随时调用set方法，这样就不易辨别哪些方法是按照什么顺序来更新的共享数据。</strong></li>
</ol>
<p><strong>随着虚拟线程的到来，内存泄漏问题就不用担心了，由于虚拟线程会很快的终止，此时会自动删除ThreadLocal中的数据，这样就不用调用remove方法了</strong>。但虚拟线程的数量通常是多的，试想下上百万个虚拟线程都要拷贝一份ThreadLocal中的变量，这会使内存承受更大的压力。为了解决这些问题，scoped values就出现了。</p>
<h4 id="ScopeValue初体验"><a href="#ScopeValue初体验" class="headerlink" title="ScopeValue初体验"></a>ScopeValue初体验</h4><p>在java21中新增了ScopeValue类，为了便于多个方法使用，通常会将该类的对象声明为static final ，每个线程都能访问自己的scope value，与ThreadLocal不同的是，它只会被write 1次且仅在线程绑定的期间内有效。</p>
<p>下面代码模拟了送礼和收礼的场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScopedValue&lt;String&gt; GIFT = ScopedValue.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        t.giveGift();</span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//送礼</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveGift</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在对象GIFT中增加字符串手机，当run方法执行时，</span></span><br><span class="line"><span class="comment">            会拷贝一份副本与当前线程绑定，当run方法结束时解绑。</span></span><br><span class="line"><span class="comment">            由此可见，这里GIFT中的字符串仅在收礼方法中可以取得。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ScopedValue.where(GIFT, <span class="string">&quot;手机&quot;</span>).run(() -&gt; receiveGift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收礼</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveGift</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(GIFT.get()); <span class="comment">// 手机</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多线程操作相同的ScopeValue"><a href="#多线程操作相同的ScopeValue" class="headerlink" title="多线程操作相同的ScopeValue"></a>多线程操作相同的ScopeValue</h4><p>不同的线程在操作同一个ScopeValue时，相互间不会影响，其本质是利用了Thread类中scopedValueBindings属性进行的线程绑定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScopedValue&lt;String&gt; GIFT = ScopedValue.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            pool.submit(()-&gt;&#123;</span><br><span class="line">                t.giveGift();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//向ScopedValue中添加当前线程的名字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveGift</span><span class="params">()</span> &#123;</span><br><span class="line">        ScopedValue.where(GIFT, Thread.currentThread().getName()).run(() -&gt; receiveGift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveGift</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(GIFT.get()); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="record-pattern-解构"><a href="#record-pattern-解构" class="headerlink" title="record pattern 解构"></a>record pattern 解构</h3><p>通过该特性可以解构record类型中的值，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">10</span>, <span class="string">&quot;jordan&quot;</span>);</span><br><span class="line">        printSum(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSum</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="comment">//这里的Student(int a, String b)就是 record pattern</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> a, String b)</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;id:&quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;name:&quot;</span> + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">record</span> <span class="title class_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch格式匹配"><a href="#switch格式匹配" class="headerlink" title="switch格式匹配"></a>switch格式匹配</h3><p>之前的写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> getObjInstance(i);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getObjInstance</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">objInstance</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">            objInstance = <span class="string">&quot;空对象&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer i) &#123;</span><br><span class="line">            objInstance = <span class="string">&quot;Integer 对象：&quot;</span> + i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Double d) &#123;</span><br><span class="line">            objInstance = <span class="string">&quot;Double 对象：&quot;</span> + d;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">            objInstance = <span class="string">&quot;String 对象：&quot;</span> + s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新的写法，代码更加简洁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> getObjInstance(i);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getObjInstance</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">switch</span>(obj)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">null</span> -&gt; <span class="string">&quot;空对象&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Integer i -&gt; <span class="string">&quot;Integer 对象：&quot;</span> + i;</span><br><span class="line">            <span class="keyword">case</span> Double d -&gt; <span class="string">&quot;Double对象：&quot;</span> + d;</span><br><span class="line">            <span class="keyword">case</span> String s -&gt; <span class="string">&quot;String对象：&quot;</span> + s;</span><br><span class="line">            <span class="keyword">default</span> -&gt; obj.toString();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在switch中使用when</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        yesOrNo(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yesOrNo</span><span class="params">(String obj)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(obj)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">null</span> -&gt; &#123;System.out.println(<span class="string">&quot;空对象&quot;</span>);&#125;</span><br><span class="line">            <span class="keyword">case</span> String s</span><br><span class="line">                when s.equalsIgnoreCase(<span class="string">&quot;yes&quot;</span>) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;确定&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> String s</span><br><span class="line">                when s.equalsIgnoreCase(<span class="string">&quot;no&quot;</span>) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;取消&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">//最后的case要写，否则编译回报错</span></span><br><span class="line">            <span class="keyword">case</span> String s -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入yes或no&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unnamed-Classes-and-Instance-Main-Methods"><a href="#Unnamed-Classes-and-Instance-Main-Methods" class="headerlink" title="Unnamed Classes and Instance Main Methods"></a>Unnamed Classes and Instance Main Methods</h3><p>对于初学者来说，写的第一个HelloWorld代码有太多的概念，为了方便初学者快速编写第一段java代码，这里提出了无名类和实例main方法，下面代码可以直接运行编译，相当于是少了类的定义，main方法的修饰符和形参也省略掉了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Structured-Concurrency"><a href="#Structured-Concurrency" class="headerlink" title="Structured Concurrency"></a>Structured Concurrency</h3><p>该特性主要作用是在使用虚拟线程时，可以使任务和子任务的代码编写起来可读性更强，维护性更高，更加可靠。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.StructuredTaskScope;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">Food</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>().handle();</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Food <span class="title function_">handle</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;</span><br><span class="line">            Supplier&lt;String&gt; yaoZi = scope.fork(() -&gt; <span class="string">&quot;新鲜大腰子烤好了&quot;</span>);<span class="comment">// 烤腰子的任务</span></span><br><span class="line">            Supplier&lt;String&gt; drink = scope.fork(() -&gt; <span class="string">&quot;奶茶做好了&quot;</span>);<span class="comment">// 买饮料的任务</span></span><br><span class="line"></span><br><span class="line">            scope.join() <span class="comment">// 将2个子任务都加入</span></span><br><span class="line">            .throwIfFailed(); <span class="comment">// 失败传播</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当两个子任务都成功后，最终才能吃上饭</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Food</span>(yaoZi.get(), drink.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">record</span> <span class="title class_">Food</span><span class="params">(String yaoZi, String drink)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java22新特性"><a href="#Java22新特性" class="headerlink" title="Java22新特性"></a>Java22新特性</h2><h3 id="无名变量"><a href="#无名变量" class="headerlink" title="无名变量 __"></a>无名变量 __</h3><p>这个和Go的下划线挺类似的，<strong>一般使用在try-catch中，直接将e，变为下划线</strong>。主要是<strong>区分出需要使用的变量和不需要使用的变量</strong>，因为不是所有的返回值都是你需要的，这样可以<strong>使代码逻辑更加清晰</strong>。</p>
<p>以下场景可以使用Unnamed Variables</p>
<ul>
<li><p>局部变量</p>
</li>
<li><p>try-with-resource</p>
</li>
<li><p>循环头中声明的变量</p>
</li>
<li><p>catch中声明的变量</p>
</li>
<li><p>lambda表达式中的参数</p>
</li>
</ul>
<p>参考文章：<a href="https://www.yuque.com/monkey1024/javase/uhzrnnl2ragygqfm">1.java9新特性 (yuque.com)</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>My-Backend-Learning-Journey</title>
    <url>/2024/09/07/My-Backend-Learning-Journey/</url>
    <content><![CDATA[<h1 id="后端技术知识一览"><a href="#后端技术知识一览" class="headerlink" title="后端技术知识一览"></a>后端技术知识一览</h1><blockquote>
<p>整理了一下自己在学习后端时的心得体会，争取可以让各位立志学习后端的朋友快速了解一下后端的技术 :horse_racing:</p>
<p>如果觉得项目不错，或者给你带来了一些帮助，不妨点个 Star ❤️</p>
<p>本篇文章属于本人的原创作品，如果需要转载，请保留出处，谢谢咯 😆</p>
<p>由于本人现在的技术可能不太成熟，对于一些概念可能理解的会有问题，所以如果你在文章中发现了问题不妨指出问题，提一个issue哦 :rose:</p>
</blockquote>
<h2 id="为什么会创建这样一个仓库？"><a href="#为什么会创建这样一个仓库？" class="headerlink" title="为什么会创建这样一个仓库？"></a>为什么会创建这样一个仓库？</h2><p>很多教程对于后端的技术栈说明的并不全面，或者是太全面了让人不知道从哪里开始学起，这导致初入编程的我们学习的过程中没有较强的连续性，很容易让人产生不知道学了有什么用，有那么多技术框架，我该先学哪个的疑问。</p>
<p>所以作为一名普通的在校大学生，我想在此分享一下自己学习后端的整个心路历程和经验，将整个后端要学习的技术尽量以一种启发式的方式介绍给大家，希望能为所有想学习后端的同学们提供一些帮助。</p>
<h2 id="这个仓库包含了哪些知识的介绍？"><a href="#这个仓库包含了哪些知识的介绍？" class="headerlink" title="这个仓库包含了哪些知识的介绍？"></a>这个仓库包含了哪些知识的介绍？</h2><ul>
<li>后端语言 — Java</li>
<li>关系型数据库 — MySQL</li>
<li>ORM框架 — Mybatis &#x2F; Mybatis-plus</li>
<li>Web开发框架 — Spring，SpringMVC，SpringBoot</li>
<li>接口管理工具 — Postman &#x2F; Apifox &#x2F; Swagger &#x2F; YAp</li>
<li>安全管理框架 — Spring Security &#x2F; Shiro</li>
<li>依赖管理工具 — Maven &#x2F; Gradle</li>
<li>版本控制工具 — Git</li>
<li>服务器 — Linux</li>
<li>前端基础 — 前端三剑客</li>
<li>设计模式 — 优化代码</li>
<li>缓存 — Redis</li>
<li>性能压测 — JMeter</li>
<li>消息队列 — RabbitMQ</li>
<li>反向代理服务器 — Nginx</li>
<li>网络编程 — Netty</li>
<li>微服务框架 — SpringCloud</li>
<li>容器 — Docker</li>
<li>容器编排 — Kubernetes</li>
<li>CI &#x2F; CD — Jenkins</li>
<li>并发编程 — JUC</li>
<li>虚拟机 — JVM</li>
<li>任务调度 — XXL-JOB</li>
<li>搜索引擎 — Elasticsearch</li>
<li>链路追踪 — SkyWalking</li>
<li>读写分离 — ShardingSphere &#x2F; MyCat</li>
<li>同步数据 — Canal</li>
<li>存储图片 — OSS</li>
<li>好用的工具包 — Hutool</li>
</ul>
<p>个人认为除了四大件和其他CS专业知识的介绍，关于纯后端知识的介绍已经非常全面了。</p>
<p>你可能会觉得还不是很全，比如这里有一些概念笔者并没有提及：CDN内容分发网络，DDD架构，分布式的Raft，拥抱云的GraalVM，新时代GC的ZGC，服务网格Istio，提高代码质量的SonarQube等等。</p>
<p>其实当然，后端知识浩如烟海，怎么可能仅仅只用一篇文章介绍完。倒不如说，这些后端知识应该是你在有了一定基础之后自己去看前沿文章去了解到的。</p>
<p>写这篇文章主要是觉得现在市面上的学习路线主要有以下两个极端:</p>
<ul>
<li>太全。让真正的初学者难以下手，不知道学什么，只会盲目的去学习一些新框架</li>
<li>太简单。让初学者不易于建立完整的后端知识体系，对于后端架构没有一个完整的认识</li>
</ul>
<p>所以这里就我在大学以来和在团队中学习的经验写一些我对于后端的看法，希望可以让朋友们拨开云雾见青天，知道自己为什么学这些技术，以及要学什么技术。</p>
<h2 id="我该怎么学习后端的技术"><a href="#我该怎么学习后端的技术" class="headerlink" title="我该怎么学习后端的技术"></a>我该怎么学习后端的技术</h2><p>我目前学习后端的主要语言是Java，所以在这里主要介绍一下Java后端的学习路线，当然如果你是其他语言的选手，这并不影响你阅读本章内容，因为业界要解决的问题是不会变的，变的只是框架。</p>
<p>比如你在Java中使用Mybatis-plus操作数据，在Go中使用GORM操作数据，在Java中使用SpringBoot作为基本的Web开发框架，在Go中使用Gin或Echo作为基本的Web开发框架。</p>
<p>下面，各位朋友可以根据自己的需求来学习。</p>
<p>这里直接总结一下最基础的后端开发需求，适合真正的初学者:</p>
<ul>
<li>会一门后端语言的基础语法 — 比如Java，Python，Go，Rust等</li>
<li>会基础的关系型数据库操作 — 一般会MySQL的基础操作就行了</li>
<li>会使用ORM框架来操作数据库 — 这个ORM框架你可以根据你选的语言去搜</li>
<li>会使用Web开发框架做基本的项目开发 — 这个Web开发框架你可以根据你选的语言去搜</li>
<li>会基本的接口管理工具给我们的程序发起请求 — 会使用Postman &#x2F; Apifox其中一个就行了</li>
<li>会一个依赖管理工具来管理我们的依赖 — 这个依赖管理工具你可以根据你选的语言去搜</li>
<li>会版本控制工具 — Git</li>
</ul>
<p>比如，我这里以Java为例:</p>
<ul>
<li>会Java的基础语法：掌握数据类型、控制结构、面向对象编程等基本概念</li>
<li>会关系型数据库MySQL的基础操作：能够执行基本的SQL查询、插入、更新和删除操作</li>
<li>会Mybatis来操作数据库：了解如何使用MyBatis进行数据持久化</li>
<li>会SpringBoot来做基本的项目开发：能够创建和配置SpringBoot应用，理解基本的注解和配置方式</li>
<li>会使用Apifox给我们的程序发起请求：能够使用Apifox测试和管理API接口</li>
<li>会使用Maven来管理我们的依赖：熟悉Maven的基本命令和POM文件配置</li>
<li>会使用Git提交推送代码到GitHub上：能够使用 Git 进行版本控制，掌握基本的提交、推送和分支操作</li>
</ul>
<p>又或者，以Go为例:</p>
<ul>
<li>会Go的基础语法：理解数据类型、控制结构、函数和并发编程等基本概念</li>
<li>会关系型数据库MySQL的基础操作：能够执行基本的 SQL 查询、插入、更新和删除操作</li>
<li>会GORM来操作数据库：了解如何使用GORM进行数据持久化</li>
<li>会Echo &#x2F; Gin来做基本的项目开发：能够使用 Echo 或 Gin 框架搭建基本的 Web 应用</li>
<li>会使用Apifox给我们的程序发起请求：能够使用 Apifox 测试和管理 API 接口</li>
<li>会使用Go Modules来管理我们的依赖：熟悉 Go Modules 的基本用法</li>
<li>会使用Git提交推送代码到GitHub上：能够使用 Git 进行版本控制，掌握基本的提交、推送和分支操作</li>
</ul>
<p>除了这些，建议你了解学习以下内容:</p>
<ul>
<li>如何使用Markdown规范自己的文档</li>
<li>如何规范自己的commit信息</li>
<li>如何遵守接口设计规范 RESTful API</li>
</ul>
<p>当你有了一定的基础后，你可以根据后面写的这些来查缺补漏，丰富自己的技术栈。</p>
<h2 id="语言—Java-必学"><a href="#语言—Java-必学" class="headerlink" title="语言—Java(必学)"></a><a href="https://www.oracle.com/cn/java/technologies/downloads/">语言—Java(必学)</a></h2><p>首先我们要编程，写项目，一定要会一门语言，正所谓万丈高楼平地起，语言就是我们搭建高楼的砖块。</p>
<p>不过初学一门编程语言的时候可能你会遇到很多问题，比如思考为什么要写OOP，为什么要有多线程，很多东西你可能暂时不太了解，不过这没有关系，当你学到后面的时候自然会体会到这样做的原因。</p>
<p>这里介绍一下我初学Java语言时的技巧:</p>
<ul>
<li><strong>多敲代码</strong>(代码是手上功夫，光看不练假把式)</li>
<li><strong>学习 Debug</strong> (当你遇到问题无法得到你预期的结果时，可以试试断点调试)</li>
<li><strong>学习Stream流和Lambda 表达式</strong>(这两个技术可以使我们的程序更加优雅—优化数据处理和匿名函数的编写)</li>
<li><strong>看看阿里巴巴的开发规范</strong>(这样更有利于你的程序写出更少的Bug，可读性更好，可扩展性更高)</li>
</ul>
<p>推荐文档和工具:</p>
<ul>
<li><a href="https://liaoxuefeng.com/books/java/introduction/index.html">简介 - Java教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/">Overview (Java Platform SE 8 ) (oracle.com)</a></li>
<li><a href="https://www.matools.com/api/java8">Java 8 中文版 - 在线API手册 - 码工具 (matools.com)</a></li>
<li><a href="https://github.com/akullpp/awesome-java">akullpp&#x2F;awesome-java: A curated list of awesome frameworks, libraries and software for the Java programming language. (github.com)</a></li>
<li><a href="https://developer.aliyun.com/ebook/386">《阿里巴巴Java开发手册（终极版）》免费下载_在线阅读_藏经阁-阿里云开发者社区 (aliyun.com)</a></li>
</ul>
<h2 id="关系型数据库—MySQL-必学"><a href="#关系型数据库—MySQL-必学" class="headerlink" title="关系型数据库—MySQL(必学)"></a><a href="https://www.mysql.com/cn/">关系型数据库—MySQL(必学)</a></h2><p>当我们学完一门语言后，一般学校里面都会要求我们做一个课设(这里用贪吃蛇举例)，我们初步了解Java并上手之后，知道了可以使用文件来存储读取数据，那么一旦当数据多起来的时候，我们就不好处理了，这时我们不妨在网上搜搜看有什么东西可以帮助我们存储数据呢？</p>
<p>于是你找到了<a href="https://zh.wikipedia.org/wiki/MySQL">MySQL</a>(这里还推荐你了解一下<a href="https://zh.wikipedia.org/zh-cn/MariaDB">MariaDB</a>和<a href="https://zh.wikipedia.org/zh-cn/PostgreSQL">PostgreSQL</a>)。</p>
<p>那么我们学习MySQL到底要到一个什么程度才能进行开发呢？</p>
<ul>
<li>SQL语句编写(<strong>主要会CURD就行了</strong>，create、update、read和delete)</li>
<li>设计数据库表，字段(这里建议<strong>看看阿里巴巴对于数据库设计的规范</strong>，帮助你更好的设计数据库)</li>
</ul>
<p>推荐文档:</p>
<ul>
<li><a href="https://dev.mysql.com/doc/">MySQL :: MySQL Documentation</a></li>
<li><a href="https://mysql.net.cn/">MySQL 中文网</a></li>
<li><a href="https://www.mysqlzh.com/">MySQL 中文文档 | MySQL 中文网 (mysqlzh.com)</a></li>
<li><a href="https://developer.aliyun.com/ebook/386">《阿里巴巴Java开发手册（终极版）》免费下载_在线阅读_藏经阁-阿里云开发者社区 (aliyun.com)</a></li>
</ul>
<h2 id="ORM框架—MyBatis-Mybatis-plus-必学"><a href="#ORM框架—MyBatis-Mybatis-plus-必学" class="headerlink" title="ORM框架—MyBatis &#x2F; Mybatis-plus(必学)"></a><a href="https://zh.wikipedia.org/wiki/MyBatis">ORM框架—MyBatis &#x2F;</a> <a href="https://github.com/baomidou/mybatis-plus">Mybatis-plus(必学)</a></h2><p>当你写多了原生的<a href="https://zh.wikipedia.org/wiki/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5"><strong>JDBC</strong></a>来操作数据库之后，会发现编码效率很低，写的过程中也比较容易出错，为了更好的和数据库进行交互，于是你又在网上看别人的博客，发现了<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84">ORM</a>这个东西，这种框架可以帮助我们更快的写<a href="https://zh.wikipedia.org/wiki/SQL">SQL</a>，甚至有时候都不用写，而是自动生成。</p>
<p>这里简单介绍一下我写项目时的搭配(MyBatis &#x2F; Mybatis-plus)，当然<a href="https://zh.wikipedia.org/wiki/Java%E6%8C%81%E4%B9%85%E5%8C%96API"><strong>JPA</strong></a>也是可以的:</p>
<ul>
<li>Mybatis在这种搭配下常常用于写复杂的SQL</li>
<li>Mybatis-plus天生支持单表查询，不用自己手写单表查询，这里推荐写一些简单的SQL，对于复杂的SQL建议还是使用Mybatis来写</li>
</ul>
<p>这里简单说明一下，为什么这样搭配，因为在写复杂SQL的时候Mybatis-plus的wrapper会很复杂，可读性很低，我们写的时候犯错的几率也会更大，所以推荐这时使用Mybatis来写。</p>
<p>推荐文档:</p>
<ul>
<li><a href="https://mybatis.org/mybatis-3/zh_CN/index.html">mybatis – MyBatis 3 | 简介</a></li>
<li><a href="https://baomidou.com/">MyBatis-Plus 🚀 为简化开发而生 (baomidou.com)</a></li>
</ul>
<h2 id="Web开发框架—Spring，SpringMVC，Spring-Boot-必学"><a href="#Web开发框架—Spring，SpringMVC，Spring-Boot-必学" class="headerlink" title="Web开发框架—Spring，SpringMVC，Spring Boot(必学)"></a><a href="https://zh.wikipedia.org/wiki/Spring_Framework">Web开发框架—Spring，SpringMVC</a><a href="https://zh.wikipedia.org/wiki/Spring_Boot">，Spring Boot(必学)</a></h2><p>这是我们做<a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1">Web服务</a>时常用的框架，如果不想从麻烦的原生配置开始做起，建议直接学习SpringBoot2。</p>
<p>SpringBoot3相对于SpringBoot2就是功能更多，但是API发生了较大的变化，可能你学习的时候大部分时间都用在处理冲突上了，所以建议新手入门直接学习SpringBoot2，等有了一定基础再学Spring家族的其他框架，做一般的项目SpringBoot也够用了。</p>
<p>还有就是不要看Spring，SpringMVC，Spring Boot有三个，其实Spring + SpringMVC ≈ SpringBoot，所以你其实可以直接学习SpringBoot。但是可能对于一些在前者(Spring，SpringMVC)中约定俗称的配置有些迷惑，所以这边还是建议有时间的话先把Spring，SpringMVC学了再学SpringBoot。</p>
<p>推荐文档:</p>
<ul>
<li><a href="https://spring.io/">Spring | Home</a></li>
<li><a href="https://springdoc.cn/docs/">spring 中文文档 - spring 中文网 (springdoc.cn)</a></li>
<li><a href="https://docs.springframework.org.cn/spring-framework/reference/spring-projects.html">Spring 项目 :: Spring 框架 - Spring 中文 (springframework.org.cn)</a></li>
</ul>
<h2 id="接口管理工具—Postman-Apifox-Swagger-YApi-必学"><a href="#接口管理工具—Postman-Apifox-Swagger-YApi-必学" class="headerlink" title="接口管理工具—Postman &#x2F; Apifox &#x2F; Swagger &#x2F; YApi(必学)"></a><a href="https://www.postman.com/">接口管理工具—Postman &#x2F;</a> <a href="https://apifox.com/?utm_source=bing&utm_medium=sem&utm_campaign=%E9%AB%98%E8%BD%AC%E5%8C%96%E8%AF%8D-%E4%BA%A7%E5%93%81&utm_content=Apifox&utm_term=apifox&search_term=Apifox&msclkid=d08923251e02177742af45ff8fc17a7f">Apifox &#x2F;</a> <a href="https://swagger.io/">Swagger &#x2F;</a> <a href="https://yapi.pro/">YApi(必学)</a></h2><p>什么，你还在使用<a href="https://hc.apache.org/httpcomponents-client-4.5.x/index.html">HttpClient</a>发送请求？</p>
<p>那么不妨试一试我上面提到的工具吧，这些工具的界面更加友好，功能更加强大，我们没有理由不去使用它。</p>
<p>最开始我使用的是Postman，后面使用过Apifox，Swagger，YApi等工具，就我个人这么久的使用体验而言，感觉Apifox的功能更多更强大，界面是中文，而且还可以导出接口文档，很方便，不用我们自己去写。</p>
<p>这个就不用什么文档了，建议直接<a href="https://zh.wikipedia.org/wiki/CSDN">CSDN</a>启动。</p>
<h2 id="安全管理框架—Spring-Security-Shiro框架-选学，项目有安全需要的学"><a href="#安全管理框架—Spring-Security-Shiro框架-选学，项目有安全需要的学" class="headerlink" title="安全管理框架—Spring Security &#x2F; Shiro框架(选学，项目有安全需要的学)"></a><a href="https://springdoc.cn/spring-security/index.html">安全管理框架—Spring Security &#x2F;</a> <a href="https://zh.wikipedia.org/wiki/Apache_Shiro">Shiro框架(选学，项目有安全需要的学)</a></h2><p>当你的系统缺少安全管理部分可以使用到它，你也许还听说过Shiro框架，它也是做安全的，只不过相比于Spring Security更加轻量。</p>
<p>当然，我们说安全管理框架可能你还不太清楚，为什么要这个东西，如果你写过登录系统，就应该明白，没有框架来管理接口访问，我们将无法对用户进行相应的验证和授权，也就无法区分管理员与普通用户的权限。</p>
<p>除了上面那些框架，我还可以尝试什么？</p>
<ul>
<li>当然，如果你觉得上面提到的框架过于笨重，那么这里还建议你尝试一下<a href="https://jwt.io/">JWT</a>，它可比上面两个轻量多了</li>
<li>同时也建议你了解一下<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E8%A7%92%E8%89%B2%E7%82%BA%E5%9F%BA%E7%A4%8E%E7%9A%84%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6">RBAC理论</a>，这个在Spring Security中也有体现</li>
<li>还有就是建议你了解一下<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%8E%88%E6%9D%83">OAuth2.0协议</a></li>
</ul>
<p>推荐文档:</p>
<ul>
<li><a href="https://spring.io/">Spring | Home</a></li>
<li><a href="https://springdoc.cn/docs/">spring 中文文档 - spring 中文网 (springdoc.cn)</a></li>
<li><a href="https://docs.springframework.org.cn/spring-framework/reference/spring-projects.html">Spring 项目 :: Spring 框架 - Spring 中文 (springframework.org.cn)</a></li>
</ul>
<h2 id="依赖管理工具—Maven-Gradle-必学"><a href="#依赖管理工具—Maven-Gradle-必学" class="headerlink" title="依赖管理工具—Maven &#x2F; Gradle(必学)"></a><a href="https://zh.wikipedia.org/wiki/Apache_Maven">依赖管理工具—Maven &#x2F;</a> <a href="https://zh.wikipedia.org/wiki/Gradle">Gradle(必学)</a></h2><p>相信你之前使用依赖的方式是直接将对应的<a href="https://zh.wikipedia.org/wiki/JAR_(%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F)">JAR包</a>放入项目中，但是随着你项目中使用的依赖越来越多，自己管理依赖逐渐变成了一件麻烦的事情。</p>
<p>于是你发现了Maven，这个工具可以帮助你管理你的依赖，并且你可以通过<a href="https://blog.csdn.net/qq_20236937/article/details/135893883">pom.xml</a>的形式配置jar包的版本。从我们自己在Maven仓库中找到对应依赖的jar包，自己导入项目，自己管理，到Maven的一键配置，大大减少了我们为管理依赖头疼的时间。</p>
<p>相关建议:</p>
<ul>
<li><strong>当成工具用就行</strong>，重要性没有那些框架重要</li>
<li>如果缺什么的工具包(比如处理<a href="https://zh.wikipedia.org/wiki/JSON">JSON</a>的)，<strong>建议在awesome-java中找找看有没有推荐的工具包</strong>，然后在Maven仓库中找到对应的依赖，得到对应的pom文件导入就行了</li>
</ul>
<p>推荐文档和仓库:</p>
<ul>
<li><a href="https://maven.apache.org/guides/index.html">Maven – Maven Documentation (apache.org)</a></li>
<li><a href="https://mvnrepository.com/">Maven Repository: Search&#x2F;Browse&#x2F;Explore (mvnrepository.com)</a></li>
<li><a href="https://central.sonatype.com/?smo=true">Maven Central (sonatype.com)</a></li>
<li><a href="https://maven.org.cn/">Maven 中文网</a></li>
</ul>
<h2 id="版本控制工具—Git-必学"><a href="#版本控制工具—Git-必学" class="headerlink" title="版本控制工具—Git(必学)"></a><a href="https://zh.wikipedia.org/wiki/Git">版本控制工具—Git(必学)</a></h2><p>你可能想过：有没有一个工具记录自己做过的事情并且可以标准的区分自己各个版本的功能呢？</p>
<p>当然有咯，那就是Git，于此相应的概念还有<a href="https://zh.wikipedia.org/wiki/GitHub">GitHub</a>，不过前者是一个版本控制工具，类似的还有<a href="https://zh.wikipedia.org/wiki/Subversion">SVN</a>，后者是一个代码托管平台，类似的还有<a href="https://zh.wikipedia.org/wiki/GitLab">GitLab</a>。</p>
<p>我们该怎么学习Git？</p>
<ul>
<li>看过<a href="https://cloud.tencent.com/developer/article/1771872">Git底层设计</a>的朋友都知道，Git对于底层的抽象做的很好，比如底层基于快照的存储，以及无环图的设计，但是对于上层<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3">API</a>暴露的并不友好，所以推荐<strong>先看一下Git的底层设计</strong>之后，再学习一下Git的API，并结合Git底层的数据结构来思考，每次API操作的是数据的哪一部分，时间久了，你对于Git就会非常熟悉了</li>
</ul>
<p>以及，我们主要要学习Git的哪些API呢？</p>
<ul>
<li>主要是学习提交、推送、拉取、回退、重置、克隆，代码合并、解决冲突的命令。后续根据对应项目场景的需求再对应去学即可</li>
</ul>
<p>推荐文档和网站:</p>
<ul>
<li><a href="https://git-scm.com/book/zh/v2">Git - Book (git-scm.com)</a></li>
<li><a href="https://docs.github.com/zh">GitHub Docs</a></li>
<li><a href="https://nulab.com/zh-cn/learn/software-development/git-tutorial/">Simple Git tutorial for beginners | Nulab</a></li>
<li><a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></li>
<li><a href="https://training.github.com/downloads/zh_CN/github-git-cheat-sheet/">GitHub Git 备忘单 - GitHub Cheatsheets</a></li>
</ul>
<h2 id="服务器—Linux-必学"><a href="#服务器—Linux-必学" class="headerlink" title="服务器—Linux(必学)"></a><a href="https://zh.wikipedia.org/wiki/Linux">服务器—Linux(必学)</a></h2><p>你是不是有疑惑，为什么自己写的项目只能被自己的电脑访问，而不能被其他的电脑访问？</p>
<p>其实是因为你没有自己的服务器，如果你要让别人访问你的服务，你可以去买一个属于你的域名和一个云服务器，将自己写的服务部署到服务器上，供别人访问。</p>
<p>那么，使用Linux服务器最基本的技能是什么呢？</p>
<p>由于现在的很多前后台项目大多都是在Linux环境下部署的，所以我们至少要了解一些常用的Linux指令。</p>
<p>当然如果你不买现成的云服务器，你还可以使用虚拟机，这样同样可以模拟在云服务器上Linux的操作。学会了基础的Linux操作之后，你将会在之后学习微服务架构时将会如鱼得水。</p>
<p>那么多命令我该怎么记下来呢？</p>
<ul>
<li>你可以<strong>使用man或者tldr</strong>，这些命令会解释每一个命令具体的含义或给出详细的示例，你可以照葫芦画瓢的去使用</li>
<li><strong>每一个命令一般都是对应英文的缩写</strong>，你可以去网上找找看，这样便于你记忆和理解</li>
</ul>
<p>我该看什么了解Linux命令呢？</p>
<ul>
<li>你可以看看<strong>鸟哥的 Linux 私房菜</strong>，这本书对于Linux有一个较为全面的介绍</li>
</ul>
<p>我该怎么用Linux系统呢？</p>
<ul>
<li>我目前主要通过<a href="https://zh.wikipedia.org/wiki/VMware">VMware</a>，<a href="https://zh.wikipedia.org/wiki/VirtualBox">VirtualBox</a>和<a href="https://zh.wikipedia.org/wiki/%E9%80%82%E7%94%A8%E4%BA%8ELinux%E7%9A%84Windows%E5%AD%90%E7%B3%BB%E7%BB%9F#WSL_2">WSL2</a>来使用，推荐使用<a href="https://zh.wikipedia.org/wiki/Ubuntu">Ubuntu</a>，当然使用<a href="https://zh.wikipedia.org/wiki/CentOS">CentOS</a>学习也行</li>
<li>VMware是我一开始学习Linux的时候用的工具，其实也是挺好用的</li>
<li>VirtualBox可以结合<a href="https://zh.wikipedia.org/wiki/Vagrant">Vagrant</a>来使用，实现一键部署虚拟机，这个倒是挺方便的</li>
<li>对了对了，如果你要使用虚拟机来进行学习的话，推荐你使用<a href="https://zh.wikipedia.org/wiki/Xshell">Xshell</a>或者<a href="https://cloud.tencent.com/developer/article/1943148">FinalShell</a>来作为<a href="https://zh.wikipedia.org/wiki/Secure_Shell">SSH</a>连接的工具，要不然你就只能使用黑黑的终端来连接了（这边建议你实在是要用最好自己配置一下<a href="https://github.com/ohmyzsh/ohmyzsh">ohmyzsh</a>，它提供了非常友好的终端界面）</li>
<li>WSL2可以直接在Windows上运行，不用每次学习都要开虚拟机，更加方便</li>
</ul>
<p>这个Linux上有很多好玩的东西，下面我来介绍一下:</p>
<ul>
<li>脚本控制项目部署和起起停停 — <a href="https://www.runoob.com/linux/linux-shell.html">Shell</a></li>
<li>最流行的基于命令行的编辑器 — <a href="https://zh.wikipedia.org/wiki/Vim">Vim</a></li>
<li>最常用的构建系统之一 — <a href="https://zh.wikipedia.org/wiki/Make">make</a></li>
</ul>
<p>推荐网站:</p>
<ul>
<li><a href="https://wangchujiang.com/linux-command/">Linux命令搜索引擎 命令，Linux Linux命令搜索引擎 命令详解：最专业的Linux命令大全，内容包含Linux命令手册、详解、学习，值得收藏的Linux命令速查手册。 - Linux 命令搜索引擎 (wangchujiang.com)</a></li>
<li><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></li>
</ul>
<h2 id="前端基础—前端三剑客HTML，CSS，JavaScript-选学，这个不做要求，感兴趣可以了解一下"><a href="#前端基础—前端三剑客HTML，CSS，JavaScript-选学，这个不做要求，感兴趣可以了解一下" class="headerlink" title="前端基础—前端三剑客HTML，CSS，JavaScript(选学，这个不做要求，感兴趣可以了解一下)"></a><a href="https://zh.wikipedia.org/wiki/HTML">前端基础—前端三剑客HTML</a>，<a href="https://zh.wikipedia.org/wiki/CSS">CSS</a>，<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript(选学，这个不做要求，感兴趣可以了解一下)</a></h2><p>作为一位想要从事后端工作的程序员来说，了解一点前端知识是很有用处的。</p>
<p>正如你所了解的一样，后端负责给前端提供数据，前端负责在页面上展示数据。为了使我们和前端的小伙伴们配合的更好，我们可以适当了解一些关于前端的知识，知道数据怎么提交给前端，以便于前端处理，知道前端是怎么获取到后端数据的等等。</p>
<p>那么，我们具体需要掌握到什么层次呢？</p>
<ul>
<li>当然，对于后端程序员来说，你<strong>不需要知道太多的前端知识</strong>，但是基础的你还是要会的，比如说：HTML，CSS， JavaScript。当然你还可以了解一点<a href="https://zh.wikipedia.org/wiki/Vue.js">Vue</a>等等前端框架，太多的我们不需要掌握，了解一下目前主流前端开发框架就行了</li>
</ul>
<p>好的，完成上面内容的基本学习之后，你将掌握基本的项目开发能力，但是想要做到一个合格的后端程序员是不容易的，接下来，我们还需要学会这些知识。</p>
<h2 id="设计模式—优化代码-选学，想要项目有更好设计的学"><a href="#设计模式—优化代码-选学，想要项目有更好设计的学" class="headerlink" title="设计模式—优化代码(选学，想要项目有更好设计的学)"></a><a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">设计模式—优化代码(选学，想要项目有更好设计的学)</a></h2><p>也许你已经写出过几千行的代码了，但是你或许会发现自己每改动一个位置的代码，很多位置都会发生变化，你常常因为这件事情焦头烂额，觉得工作量太大。</p>
<p>其实大可不必，很多时候都是我们没有设计好类与类之间的关系，使得我们后期加需求，维护时的难度大大提升。</p>
<p>简而言之，设计模式可以让你写出<strong>高质量的代码(Safe from bugs,Easy to understand,Ready for change)。</strong></p>
<p>设计模式简单的说有三个模式：创建型模式，结构型模式，行为型模式。当然，你肯定不想让我在这里介绍一些枯燥的知识，所以我这里直接说说我对设计模式的看法：</p>
<ul>
<li>设计模式不应该一开始就强行运用上。也许你会疑惑，刚才不是说了设计模式很好很好云云之类的，为什么这里又不推荐用呢？其实是因为我们项目最开始的时候，需求并不清楚，代码并不复杂，如果直接使用设计模式会使得代码可读性降低，而且不能有的放矢(不是所有的类都需要通过设计模式来设计)，只有当后期需求逐渐完整，类与类之间的关系变得逐渐复杂，你<strong>发现可以优化的时候再推荐使用</strong>（毕竟软件开发又不是一次就结束了，而是会经历很多轮的迭代优化）</li>
<li>最开始的时候<strong>不要为了使用设计模式而使用设计模式</strong>。学习设计模式可以让我们在读对应优秀框架源码的时候游刃有余(比如Spring就是用了很多的设计模式，如果你不学，很可能看都看不懂这是在干什么)</li>
</ul>
<p>推荐资料(除了设计模式本身，也包含了其他让你写出高质量代码的资料):</p>
<ul>
<li><a href="https://java-design-patterns.com/">Explore, Learn, and Master Industry-Standard Patterns | Java Design Patterns (java-design-patterns.com)</a></li>
<li><a href="https://ocw.mit.edu/courses/6-005-software-construction-spring-2016/pages/readings/">Readings | Software Construction | Electrical Engineering and Computer Science | MIT OpenCourseWare</a></li>
</ul>
<h2 id="缓存—Redis-必学"><a href="#缓存—Redis-必学" class="headerlink" title="缓存—Redis(必学)"></a><a href="https://zh.wikipedia.org/wiki/Redis">缓存—Redis(必学)</a></h2><p>在你使用MySQL的时候不知道你有没有想到过，如果频繁的对于一些经常要访问的数据进行SQL查询是十分浪费性能的(因为数据库是从硬盘里面读取数据到内存中)。</p>
<p>在业务处理中IO往往是导致处理请求慢的罪魁祸首，所以我们不妨使用一下缓存技术吧，将数据缓存到内存中，然后直接省去了从硬盘中读取这一步！</p>
<p>要知道缓存经常访问的不易变化的数据对于提升系统性能是有很大帮助的！</p>
<p>缓存其实和数据库类似，毕竟都是对数据进行存储的，所以一般而言，我们对其的操作也不会超过增删改查。</p>
<p>但是与关系型数据库不同的是，缓存常常和业务是强耦合的，你需要根据实际的情况判断哪些需要缓存，哪些不需要缓存(对于经常变化的数据，不建议缓存，对于不经常变化的数据，建议缓存)。</p>
<p>如果你学完之后意犹未尽，不妨看看<a href="https://github.com/ben-manes/caffeine">Caffeine</a>(这是一个很优秀的本地缓存框架)和多级缓存(可以使用<a href="https://zh.wikipedia.org/wiki/Lua">Lua脚本</a>在<a href="https://zh.wikipedia.org/wiki/Nginx">Nginx</a>里构建缓存)。</p>
<p>推荐文档:</p>
<ul>
<li><a href="https://redis.io/docs/latest/commands/">Commands | Docs (redis.io)</a></li>
<li><a href="http://redis.ac.cn/docs/latest/">文档 - Redis 中文</a></li>
<li><a href="https://redis.com.cn/documentation.html">redis中文文档</a></li>
</ul>
<h2 id="性能压测—JMeter-选学，想要测试一下自己程序性能的可以试试"><a href="#性能压测—JMeter-选学，想要测试一下自己程序性能的可以试试" class="headerlink" title="性能压测—JMeter(选学，想要测试一下自己程序性能的可以试试)"></a><a href="https://en.wikipedia.org/wiki/Apache_JMeter">性能压测—JMeter(选学，想要测试一下自己程序性能的可以试试)</a></h2><p>对了，看到这里你可能会问，为什么用了缓存之后，你就知道性能提升了啊？</p>
<p>没错，我们接下来介绍一下JMeter。</p>
<p>JMeter就是用来做压测的，你可以多关注一下你加了缓存和没有加缓存的<a href="https://zhuanlan.zhihu.com/p/337708438">QPS</a>分别是多少，这时你就会发现缓存的厉害之处了。</p>
<p>这个就不用专门去看文档学习了，它只是一个工具，具体的可以去CSDN上看看是怎么实现压测的。</p>
<p>当然，这里提一下，我们这个压测仅仅只是初略的估计，因为你电脑不可能只跑你的服务，可能会打开一些Edge浏览器窗口，可能会挂着QQ，它们都会占用你电脑的系统资源。</p>
<p>同时，JMeter发送请求的时候也会占用你电脑的资源(毕竟是你电脑的一个进程)，所以我们这里只是大概看一下自己写的程序的性能罢了。</p>
<p>要想真正的测试你程序的性能，建议你把你的服务放在一台远程服务器上跑，然后用本地电脑发送JMeter请求，这样测试的相较于上面的就更加精确了。</p>
<h2 id="消息队列—RabbitMQ-必学"><a href="#消息队列—RabbitMQ-必学" class="headerlink" title="消息队列—RabbitMQ(必学)"></a><a href="https://zh.wikipedia.org/wiki/RabbitMQ">消息队列—RabbitMQ(必学)</a></h2><p>消息是消息，队列是队列，两个合在一起就是消息队列(在队列里存放的是一个一个的消息对象)。</p>
<p>这项技术主要是用于异步消息，比如说调用一个服务的链路很长，就以订单服务来说，首先创建订单，扣减库存，扣减账户余额，创建完成订单，一下子就调用到了订单服务，库存服务，用户账户服务这三个服务，如果是依次调用的话那么用户可能买完东西后会等好一会才有反应，那么如果链路变的更长呢？</p>
<p>所以我们急需一种技术可以实现传输和保存消息，将各个服务的请求交由消息队列去处理(这里再举一个小例子，快递员是直接上楼将快递给你快，还是统一将快递交由快递柜快，答案显而易见)。</p>
<p>消息队列也是同样的设计思想，与其将消息传递给对接的服务，不如解耦，去找一个代理的去异步处理消息。</p>
<p>消息队列那么多，我该学习哪个呢？</p>
<ul>
<li>推荐学习RabbitMQ，主要是因为RabbitMQ比<a href="https://zh.wikipedia.org/wiki/Kafka">Kafka</a>更简单，当然建议感兴趣的可以学学Kafka的设计理念。还有其他的消息队列你可以适当了解，比如<a href="https://zh.wikipedia.org/wiki/Apache_RocketMQ">RocketMQ</a>和<a href="https://zh.wikipedia.org/wiki/Apache_ActiveMQ">ActiveMQ</a>，但它们的社区没有前两者活跃，资料也比较少，所以不是很推荐初学者进行学习</li>
</ul>
<p>什么时候使用到它呢？</p>
<ul>
<li>当你的<strong>调用链路过长的时候</strong>，你就可以考虑使用消息队列来处理你项目中遇到的问题了</li>
</ul>
<p>推荐文档:</p>
<ul>
<li><a href="https://www.rabbitmq.com/docs">RabbitMQ Documentation | RabbitMQ</a></li>
<li><a href="https://rabbitmq.org.cn/">RabbitMQ：一个经纪人来管理所有队列 | RabbitMQ 中文</a></li>
</ul>
<h2 id="反向代理服务器—Nginx-选学，一般只要了解一下怎么用即可"><a href="#反向代理服务器—Nginx-选学，一般只要了解一下怎么用即可" class="headerlink" title="反向代理服务器—Nginx(选学，一般只要了解一下怎么用即可)"></a><a href="https://zh.wikipedia.org/wiki/Nginx">反向代理服务器—Nginx(选学，一般只要了解一下怎么用即可)</a></h2><p>你是否还在为Tomcat的性能而担忧，那么，来试试使用Nginx吧，Nginx一般使用在<a href="https://zh.wikipedia.org/wiki/Apache_Tomcat">Tomcat</a>的前面，用于抗住较高的并发量。</p>
<p>一般用于存储前端的静态资源，实现动静分离，屏蔽后面的服务器，实现反向代理。</p>
<p>如果你要学习Nginx的话，建议你了解一下<a href="https://zh.wikipedia.org/wiki/OpenResty">OpenResty</a>，相较于Nginx，OpenResty的功能更多，而且我们也更容易使用Lua脚本语言来改造，加上一些自己特制的功能，当然<a href="https://zh.wikipedia.org/wiki/Tengine">Tengine</a>也不错。</p>
<p>推荐文档:</p>
<ul>
<li><a href="https://nginx.org/en/docs/">nginx documentation</a></li>
<li><a href="https://nginxserver.cn/en/docs/">nginx 文档 - Nginx 中文 (nginxserver.cn)</a></li>
<li><a href="https://openresty.org/cn/">OpenResty® - 开源官方站</a></li>
<li><a href="https://tengine.taobao.org/documentation_cn.html">文档 - The Tengine Web Server (taobao.org)</a></li>
</ul>
<h2 id="网路编程—Netty-选学，除非你对于网络编程很感兴趣"><a href="#网路编程—Netty-选学，除非你对于网络编程很感兴趣" class="headerlink" title="网路编程—Netty(选学，除非你对于网络编程很感兴趣)"></a><a href="https://zh.wikipedia.org/wiki/Netty">网路编程—Netty(选学，除非你对于网络编程很感兴趣)</a></h2><p>如果你对于框架底层的网络编程很感兴趣，那么一定要学学Netty，可以说，很多框架的高性能是多亏了它。</p>
<p>可以说Netty才是集Java并发的大成者，它才是Java真正的高并发，有兴趣的可以了解一下，个人觉得难度还是不小的。</p>
<p>也许你觉得它和你太过遥远，其实不然，Redis客户端用过Netty，<a href="https://zh.wikipedia.org/wiki/Elasticsearch">Elasticsearch</a>底层使用的是Netty，很多微服务框架底层使用的也是Netty，比如<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99">Spring Cloud</a>、<a href="https://cn.dubbo.apache.org/zh-cn/">Dubbo</a>等，Netty的高性能使得很多框架都喜欢使用它。</p>
<h2 id="微服务框架—SpringCloud-必学"><a href="#微服务框架—SpringCloud-必学" class="headerlink" title="微服务框架—SpringCloud(必学)"></a><a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99">微服务框架—SpringCloud(必学)</a></h2><p>微服务，什么是微服务，微服务就是将原来巨大的单体服务拆分成一个个职责明确、功能独立的细小模块，然后再将这些模块分别部署到服务器上。</p>
<p>那么，为什么会出现微服务呢？</p>
<ul>
<li>答案很简单，当你的项目不断的增加新的需求变的越来越大，越复杂时，总有一天会迎来被拆分的结局。就类似于大学物理，为了你更好理解，会将对应的章节拆分开，分成第几章第几节，不会说直接一大坨没有目录没有拆分的让你学。对于程序员也是一样，如果一个项目越来越庞大，那么为了使开发效率变高，必然会将一个庞大的项目拆分成一个个功能独立的小模块</li>
</ul>
<p>推荐学习的路线：</p>
<ul>
<li>先学习Dubbo，因为Dubbo对于底层的封装更少，可以使你快速的了解到<a href="https://blog.csdn.net/weixin_42046751/article/details/109510811">分布式</a>，<a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">RPC</a>，然后再是Spring Cloud和<a href="https://github.com/alibaba/spring-cloud-alibaba">Spring Cloud Alibaba</a>，因为后两者对于底层的封装太完善了，如果直接学很有可能使你不知道一下子是怎么来的</li>
</ul>
<p>组件那么多，我该先学哪些？</p>
<ul>
<li>其实我觉得比较重要的组件是Consul &#x2F; Nacos服务注册中心，OpenFeign远程服务调用，Gateway服务网关，Sentinel熔断限流，Seata分布式事务，Micrometer Tracing服务链路追踪 + Zipkin 链路可视化</li>
<li>可能你会了解到一些其他的组件和我这里说的不一样，比如这里的Micrometer Tracing，以前是Sleuth，不过现在有点过时了，因为微服务作为一个新兴领域发展的很快嘛，所以一些组件可能过了一段事件之后就会变化，所以我们没有必要同一种类型的技术学那么多，学好一种，到时候直接带着原有的知识迁移就行了</li>
</ul>
<h2 id="容器—Docker-必学"><a href="#容器—Docker-必学" class="headerlink" title="容器—Docker(必学)"></a><a href="https://zh.wikipedia.org/wiki/Docker">容器—Docker(必学)</a></h2><p>当你想要在你的服务器上运行你自己的项目时，你会发现，你要配置对应的环境，而且自己的项目没有一个统一的工具进行管理。</p>
<p>那么为什么我们不能将这个流程自动化呢？毕竟计算机就是解放人类的，如果你想要减轻自己配置环境的负担而且不想因为自己小测试需要的环境污染整个计算机环境，那么Docker将会是你的一个不错的选择。</p>
<p>Docker主要做的是将你的项目和你项目所需的环境进行封装，可以使我们的程序直接在Linux服务器上跑，省去了我们亲自配置环境的麻烦事(直接写好一个<a href="https://zh.wikipedia.org/wiki/Docker#Dockerfile">Dockerfile</a>就行了)，而且由于其很好的隔离性，不会使得程序之间相互影响。</p>
<p>主要是多练练相关的命令，可以试着将自己的项目采用Docker的方式部署在虚拟机上试试，或者使用WSL2，这也是一个不错的选择。</p>
<p>推荐文档和仓库:</p>
<ul>
<li><a href="https://docs.docker.com/">Docker Docs</a></li>
<li><a href="https://docker.github.net.cn/">Docker中文网 (github.net.cn)</a></li>
<li><a href="https://hub.docker.com/">Docker Hub Container Image Library | App Containerization</a></li>
</ul>
<h2 id="容器编排—Kubernetes-选学，有自动化部署集成需求的学"><a href="#容器编排—Kubernetes-选学，有自动化部署集成需求的学" class="headerlink" title="容器编排—Kubernetes(选学，有自动化部署集成需求的学)"></a><a href="https://zh.wikipedia.org/wiki/Kubernetes">容器编排—Kubernetes(选学，有自动化部署集成需求的学)</a></h2><p>当你的容器启动的越来越多时，再采用原始的手动控制容器已经不适合了，毕竟你也不想将时间浪费在容器的起起停停上吧，于是我们有了更加自动化的工具Kubernetes，帮助我们对这些容器进行管理。</p>
<p>这里说说我一开始使用Kubernetes遇到的问题：</p>
<ul>
<li>不要直接在笔记本上部署完整的Kubkernetes集群，要不然你的电脑可能会承受不住直接死机，对于性能较差的笔记本电脑来说，部署<a href="https://kubernetes.io/zh-cn/docs/tutorials/hello-minikube/">Minikube</a>或<a href="https://docs.k3s.io/zh/">K3s</a>是一个更加明知的选择(比起Kubkernetes来说更加轻量)，毕竟我们只是想学习它，不是非要部署一个完整的才行</li>
</ul>
<p>推荐文档:</p>
<ul>
<li><a href="https://kubernetes.io/zh-cn/docs/home/">Kubernetes 文档 | Kubernetes</a></li>
<li><a href="https://kubernetes.ac.cn/">Kubernetes (K8s) 中文</a></li>
</ul>
<h2 id="CI-CD—Jenkins-选学，有自动化部署集成需求的学"><a href="#CI-CD—Jenkins-选学，有自动化部署集成需求的学" class="headerlink" title="CI &#x2F; CD—Jenkins(选学，有自动化部署集成需求的学)"></a><a href="https://zh.wikipedia.org/zh-cn/Jenkins_(%E8%BD%AF%E4%BB%B6)">CI &#x2F; CD—Jenkins(选学，有自动化部署集成需求的学)</a></h2><p>不知道各位有没有使用过<a href="https://zh.wikipedia.org/wiki/GitHub_Pages">Github Pages</a>这个功能，每次你将最新的静态网站代码交上Github之后，再次访问自己的网站就会发现内容更新了，那么到底是谁偷偷的为我们做了哪些本该由我们做的部署呢？</p>
<p>答案是<a href="https://docs.github.com/zh/actions">Github Actions</a>，GitHub有属于自己的一套<a href="https://zh.wikipedia.org/wiki/CI/CD">CI &#x2F;CD</a>(持续集成，持续交付，简单的理解就是持续交代码，持续帮你部署发布)。</p>
<p>这里讲讲我在学习Jenkins时遇到的一些问题：</p>
<ul>
<li>其实也没有多少，但是一定要注意Jenkins插件对于你下载Jenkins的版本是有要求的，为了较为快乐的学习这个工具，建议使用最新版的Jenkins来学习，至少你不会遇见一些因为插件版本不适配导致的奇怪Bug</li>
</ul>
<p>推荐文档:</p>
<ul>
<li><a href="https://www.jenkins.io/zh/doc/">Jenkins 用户手册</a></li>
</ul>
<h2 id="并发编程—JUC-必学"><a href="#并发编程—JUC-必学" class="headerlink" title="并发编程—JUC(必学)"></a><a href="https://www.cnblogs.com/javastack/p/15467349.html">并发编程—JUC(必学)</a></h2><p>都说Java百万并发，千万并发的，其实说的就是Java的JUC，JUC旨在教导你使用计算机有限的资源去应对更多的请求压力，看到这里相信你也明白了，这是属于程序优化的内容。</p>
<p>建议就是菜就多练，这部分是Java最难的部分之一，没有长时间的实践积累，学习原理，你是拿不下这块内容的。</p>
<p>推荐网站(建议自己找书看):</p>
<ul>
<li><a href="https://zh.singlelogin.re/">Z-Library – 世界上最大的电子图书馆。自由访问知识和文化 (singlelogin.re)</a></li>
</ul>
<h2 id="虚拟机—JVM-必学"><a href="#虚拟机—JVM-必学" class="headerlink" title="虚拟机—JVM(必学)"></a><a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA">虚拟机—JVM(必学)</a></h2><p>和上面的JUC一样，都是Java中的大头，对于JVM而言，相信你可能听过JVM调优，没错，又是对Java程序优化，在这里你将学习到如何从JVM的层面了解Java代码，会使你看待Java程序的观点产生质的变化。</p>
<p>这边建议结合视频和书(《深入理解Java虚拟机（第3版）》)一起看，毕竟这个东西比较枯燥，可能你会看不下去书，还有就是推荐使用<a href="https://arthas.aliyun.com/doc/">Arthas</a>这个工具来帮助我们学习。</p>
<p>推荐工具和文档(建议自己找书看):</p>
<ul>
<li><a href="https://arthas.aliyun.com/doc/commands.html">命令列表 | arthas (aliyun.com)</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">java (oracle.com)</a></li>
<li><a href="https://zh.singlelogin.re/">Z-Library – 世界上最大的电子图书馆。自由访问知识和文化 (singlelogin.re)</a></li>
</ul>
<h2 id="任务调度—XXL-JOB-选学，一般了解即可"><a href="#任务调度—XXL-JOB-选学，一般了解即可" class="headerlink" title="任务调度—XXL-JOB(选学，一般了解即可)"></a><a href="https://github.com/xuxueli/xxl-job">任务调度—XXL-JOB(选学，一般了解即可)</a></h2><p>任务交由谁来执行呢，定时任务该怎么做，如果你有这样的需求，那么XXL-JOB一定对你的胃口。</p>
<p>个人感觉和RabbitMQ的功能比较类似，但是比起RabbitMQ，XXL-JOB在实际的项目使用中更加轻量化。</p>
<p>推荐文档:</p>
<ul>
<li><a href="https://www.xuxueli.com/xxl-job/">分布式任务调度平台XXL-JOB (xuxueli.com)</a></li>
</ul>
<h2 id="搜索引擎—Elasticsearch-选学，等你项目需要搜索功能的时候再学"><a href="#搜索引擎—Elasticsearch-选学，等你项目需要搜索功能的时候再学" class="headerlink" title="搜索引擎—Elasticsearch(选学，等你项目需要搜索功能的时候再学)"></a><a href="https://zh.wikipedia.org/wiki/Elasticsearch">搜索引擎—Elasticsearch(选学，等你项目需要搜索功能的时候再学)</a></h2><p>这个其实也和数据库比较像，想想你平时搜索，如果匹配到了是会高亮的，或者说，不是完全匹配也可以找到数据，其实这都是它的功劳(比如你搜索笔记电脑，但是很明显，没有这个东西，可能是你打掉了一个字，但是搜索的时候依然可以搜索出来笔记本电脑)。</p>
<p>为要搜索的数据建立索引，主要用于快速搜索。</p>
<p>这个Elasticsearch是<a href="https://www.elastic.co/cn/elastic-stack/">ELK</a>的一部分，其中<a href="https://en.wikipedia.org/wiki/Kibana">Kibana</a>可以可视化你存在Elasticsearch中的数据，而且还提供了一个写<a href="https://zh.wikipedia.org/wiki/%E9%A2%86%E5%9F%9F%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80">DSL</a>语句的页面，有点类似HttpClient。</p>
<p>推荐文档:</p>
<ul>
<li><a href="https://www.elastic.co/docs">Documentation (elastic.co)</a></li>
</ul>
<h2 id="链路追踪—SkyWalking-选学，除非你的项目很大，链路层级很深"><a href="#链路追踪—SkyWalking-选学，除非你的项目很大，链路层级很深" class="headerlink" title="链路追踪—SkyWalking(选学，除非你的项目很大，链路层级很深)"></a><a href="https://skywalking.apache.org/">链路追踪—SkyWalking(选学，除非你的项目很大，链路层级很深)</a></h2><p>当你链路长了的时候推荐使用，主要是帮助你分析调用链路的，比如是在哪里调用出现了问题，哪里的请求处理耗时太长等等。</p>
<p>这个你也可以不用学，因为我们之前已经学习了Micrometer Tracing服务链路追踪，已经学习了一个链路追踪的组件了，如果你学了一个的话，其实也没有必要学习太多，学好一个就行了。</p>
<p>推荐网站:</p>
<ul>
<li><a href="https://skywalking.apache.org/">Apache SkyWalking</a></li>
<li><a href="https://skywalking.apache.org/zh/2020-04-19-skywalking-quick-start/">SkyWalking 极简入门 | Apache SkyWalking</a></li>
</ul>
<h2 id="读写分离—ShardingSphere-MyCat-选学，除非你的项目一个数据库不够用"><a href="#读写分离—ShardingSphere-MyCat-选学，除非你的项目一个数据库不够用" class="headerlink" title="读写分离—ShardingSphere &#x2F; MyCat(选学，除非你的项目一个数据库不够用)"></a><a href="https://shardingsphere.apache.org/index_zh.html">读写分离—ShardingSphere &#x2F;</a> <a href="http://www.mycat.org.cn/">MyCat(选学，除非你的项目一个数据库不够用)</a></h2><p>可以帮助你实现读写分离，分库分表，一般是在你一个数据库不够应对现有并发量的情况下使用，否则不建议学习，建议有需要了再学习。</p>
<p>这个建议直接看官方文档，主要是官方文档写的比较精炼，而且基本上照着文档上面说的配置一般都没有什么问题，不过要注意使用的数据库连接客户端的版本不能太低，要不然会产生不兼容的问题。</p>
<p>至于这两个我们到底要选择哪一个，我推荐学习使用ShardingSphere，因为它的社区更活跃，功能更多，比MyCat更加完善。</p>
<p>推荐文档:</p>
<ul>
<li><a href="https://shardingsphere.apache.org/document/current/cn/overview/">概览 :: ShardingSphere (apache.org)</a></li>
</ul>
<h2 id="同步数据—Canal-选学，建议了解即可，毕竟我们也不是要做运维人员"><a href="#同步数据—Canal-选学，建议了解即可，毕竟我们也不是要做运维人员" class="headerlink" title="同步数据—Canal(选学，建议了解即可，毕竟我们也不是要做运维人员)"></a><a href="https://github.com/alibaba/canal">同步数据—Canal(选学，建议了解即可，毕竟我们也不是要做运维人员)</a></h2><p>主要是为了解决主从数据库数据的同步问题，一般要用的话会配合MySQL使用。</p>
<h2 id="存图片—OSS-选学，建议当你遇到存图片的需求的时候再去有针对性的学"><a href="#存图片—OSS-选学，建议当你遇到存图片的需求的时候再去有针对性的学" class="headerlink" title="存图片—OSS(选学，建议当你遇到存图片的需求的时候再去有针对性的学)"></a><a href="https://www.aliyun.com/product/oss">存图片—OSS(选学，建议当你遇到存图片的需求的时候再去有针对性的学)</a></h2><p>嗯，想想看，当你有了一个用户系统，然后每一个用户都会上传自己的头像，随着用户越来越多，你会发现这些图片好像浪费了你服务器的很多空间，那么你有没有考虑过将图片存储在其他人的服务器上以避免这种情况呢？</p>
<p>如果你想优化一下，那么不妨试一试阿里云的OSS云存储吧，免费又实用。</p>
<p>推荐网站:</p>
<ul>
<li><a href="https://www.aliyun.com/">阿里云-计算，为了无法计算的价值 (aliyun.com)</a></li>
</ul>
<h2 id="超好用的工具包—Hutool-必学"><a href="#超好用的工具包—Hutool-必学" class="headerlink" title="超好用的工具包—Hutool(必学)"></a><a href="https://www.hutool.cn/docs/#/">超好用的工具包—Hutool(必学)</a></h2><p>你是不是在为有时候没有好用的工具而烦恼，又或者是自己写的小工具总是有Bug，那么不妨尝试一下这款工具包吧，里面包含了对文件、流、加密解密、转码、正则、线程、XML等JDK方法的封装，用起来既方便又安全。</p>
<p>推荐文档:</p>
<ul>
<li><a href="https://hutool.cn/">Hutool🍬一个功能丰富且易用的Java工具库，涵盖了字符串、数字、集合、编码、日期、文件、IO、加密、数据库JDBC、JSON、HTTP客户端等功能</a></li>
</ul>
<h2 id="笔者最后想说的话"><a href="#笔者最后想说的话" class="headerlink" title="笔者最后想说的话"></a>笔者最后想说的话</h2><p>什么？你竟然看到这里来了，那么不管怎么说，你一定是热爱技术的，不过我想在此提提我学了这么久的一些心得体会：</p>
<ul>
<li>框架是为了解决问题而出现的，我们不应该痴迷于学框架，而是应该把自己的基础搞扎实，比如多看看类似<a href="https://book.douban.com/subject/1148282/">SICP</a>这样的书籍。所以一般推荐你遇到了相应的问题再去找框架解决，而不是盲目的去找框架学习。还有就是记住一点，框架会不停的变化，但是它们底层设计的思想一般是不会变化的(所以我们没有必要每一个都学，学一个经典的其他的都差不多了，感兴趣再多了解一下就行)</li>
<li>我们要锻炼自己看文档的能力。就以我为例吧，我之前学习的时候总是去在B站上找视频看，但是后来我发现这样学习的效率实在是太低了，于是开始慢慢尝试去看一些中文文档去学习（上面的ShardingSphere我就是照着文档学习的），你会发现，当你会通过文档学习之后，学习的速度会变的非常快</li>
<li>善于使用搜索平台。Stack Overflow和Github是你的好帮手，前者可以搜问题，后者可以找代码</li>
<li>不要过于依赖别人的回答。有时候，别人的回答效率还不如你自己去解决这个问题的效率高，建议是在自己的程序出现Bug之后，先自己在网上搜，用GPT问，各种Debug的方法尝试了，自己实在是解决不了了再去问，关于问问题的规范可以看看这个<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">How-To-Ask-Questions-The-Smart-Way</a></li>
</ul>
<p>最后的最后，能帮作者点一个<a href="https://github.com/z0l0y/My-Backend-Learning-Journey">star</a>吗？举手之劳万分感谢。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Backend</tag>
      </tags>
  </entry>
  <entry>
    <title>一条SQL查询语句是如何执行的？</title>
    <url>/2024/09/09/MySQL01/</url>
    <content><![CDATA[<h1 id="一条SQL查询语句是如何执行的？"><a href="#一条SQL查询语句是如何执行的？" class="headerlink" title="一条SQL查询语句是如何执行的？"></a>一条SQL查询语句是如何执行的？</h1><p>平时我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个ID字段，在执行下面这个查询语句时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from table where ID = 10;</span><br></pre></td></tr></table></figure>

<p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。</p>
<p>其实这也和SQL这门语言有关系，SQL这门语言的定位就是一种声明式编程的语言，具体可以看看这个<a href="https://composingprograms.netlify.app/4/3">声明式编程</a>，本来就是不直接描述计算过程，而是描述一些计算的预期结果，比如上面SQL语句的意思是我想从这张表中获得所有ID为10的数据，并将获得到的数据按字段全部映射到结果中。</p>
<p>下面给出的是MySQL的基本架构示意图，从中你可以清楚地看到SQL语句在MySQL的各个功能模块中的执行过程。</p>
<p><img src="/2024/09/09/MySQL01/image-20240909122001902.png" alt="image-20240909122001902"></p>
<p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p>
<p><strong>Server层</strong>包括<strong>连接器、查询缓存、分析器、优化器、执行器</strong>等，涵盖MySQL的大多数核心服务功能，<strong>以及所有的内置函数（如日期、时间、数学和加密函数等）</strong>，<strong>所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等</strong>。</p>
<p>而<strong>存储引擎层</strong>负责数据的<strong>存储和提取</strong>。其架构模式是<strong>插件式的</strong>，<strong>支持InnoDB、MyISAM、Memory等多个存储引擎</strong>。现在<strong>最常用的存储引擎是InnoDB</strong>，它从<strong>MySQL 5.5.5</strong>版本开始成为了默认存储引擎。</p>
<p>也就是说，你执行create table建表的时候，如果不指定引擎类型，<strong>默认使用的就是InnoDB</strong>。不过，你也可以通过指定存储引擎的类型来选择别的引擎，<strong>比如在create table语句中使用engine&#x3D;memory, 来指定使用内存引擎创建表</strong>。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。</p>
<p>从图中不难看出，不同的存储引擎共用一个<strong>Server层</strong>，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来会结合开头提到的那条SQL语句，带你走一遍整个执行流程，依次看下每个组件的作用。</p>
<h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，你要操作数据库，首先你就要连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure>

<p><strong>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</strong></p>
<p>大概就是这个样子</p>
<p><img src="/2024/09/09/MySQL01/image-20240909122445750.png" alt="image-20240909122445750"></p>
<p>连接命令中的mysql是客户端工具，<strong>主要就是用来跟服务端建立连接的</strong>。在完成经典的TCP握手后，连接器就要开始<strong>认证你的身份</strong>，这个时候用的就是你输入的用户名和密码。</p>
<ul>
<li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li>
<li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。<strong>之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限</strong>。</li>
</ul>
<p>这就意味着，<strong>一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</strong></p>
<p>对于上面过程还有一个比较详细的解释，建议看看</p>
<ul>
<li><a href="https://blog.csdn.net/LYue123/article/details/89256577">彻底弄懂mysql（一）–mysql的通信协议_mysql tcp protocol url-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/LYue123/article/details/89285157?spm=1001.2014.3001.5502">彻底弄懂mysql（二）–连接方式_mysql连接池怎么算开启一次连接-CSDN博客</a></li>
</ul>
<p>这里我再提示一下，这个MySQL报文其实我们很久之前就见过了，特别是在IDEA中，那个数据连接的左下角就是报文。</p>
<p>总结一下，上面两篇文章：</p>
<p>第一篇主要是介绍了MySQL的通信具体是什么样的，先TCP三次握手，然后再到握手认证阶段（登陆认证报文就是在这个时候用的），最后就是命令执行阶段（我们可以输入命令啦）</p>
<p>有两个问题问的特别好：</p>
<ul>
<li>为什么还要进行三次握手认证？</li>
<li>因为TCP三次握手，<strong>只是将客户端与服务端建立起了连接，然后通过端口知道我要访问的是MySQL这个服务</strong>，但是MySQL它不同于HTTP，只要你知道URL就能得到一个响应，<strong>MySQL必须登陆后你才能进行操作</strong>。所以这个过程最重要的就是<strong>验证客户端的登陆权限</strong>。</li>
<li>为什么是服务端主动给客户端发送认证呢？</li>
<li>HTTP不是说<strong>只有客户端主动与服务端进行请求</strong>，<strong>服务端不是不能在没有请求的情况下主动进行响应吗</strong>？<br>首先，大家也不要陷入误区，<strong>在进行认证的这个交互中，实际上客户端与服务端还没有进行任何业务上的往来，只是进行一个认证</strong>，所以与上面说的HTTP的不同，如果细心的话你会发现，<strong>认证成功后，在命令执行阶段，MySQL这种通信方式是与HTTP非常类似的，在没有请求的情况下，服务端的MySQL也不会主动给你发送任何数据，所以这里不要混淆</strong>。<br>再说为什么服务端先发送，那肯定是因为他有不得不发送的道理，所以我们就需要理解一下，他发送的是什么东西。</li>
</ul>
<p>还包括了一个例子：</p>
<ul>
<li>小明找工作，投了一个简历给某个公司（TCP三次握手成功）<br>这时候，某公司就主动打电话了，告诉他，我们需要笔试，笔试的时间，网址，以及一些别的相关信息，规则等</li>
<li>小明接收到这个消息之后，到了那个时间他就会请求那个网址，并将自己的信息告诉他</li>
<li>这时候公司验证你的信息，验证成功后，你就可以开始笔试了</li>
</ul>
<p>特别是这个挑战随机数，有点意思：</p>
<p>MySQL报文<strong>挑战随机数</strong>（通常称为“随机数”或“挑战数字”）是在MySQL客户端与服务器之间进行身份验证时使用的一种机制。具体来说，它在以下场景中发挥作用：</p>
<ol>
<li><strong>身份验证</strong>: 当客户端连接到MySQL服务器时，服务器会生成一个随机数并发送给客户端。这个随机数用于生成加密的身份验证信息。</li>
<li><strong>提高安全性</strong>: 通过使用随机数，服务器可以确保每次连接的身份验证过程都是唯一的，防止重放攻击。</li>
<li><strong>握手协议</strong>: 在MySQL的握手协议中，随机数是服务器发送给客户端的一部分，客户端使用这个随机数与用户的密码结合，生成最终的身份验证信息。</li>
</ol>
<p>说实话有点像盐值加密</p>
<p>MySQL 客户端的<strong>权能标志</strong>（Client Capability Flags）是一个用于表示客户端所支持功能的位标志。这些标志在客户端与 MySQL 服务器进行连接时起着重要的作用，确保双方能够有效地通信。</p>
<ol>
<li><strong>功能协商</strong>: 客户端在建立连接时会发送其支持的功能标志，服务器根据这些标志来决定如何处理请求。</li>
<li><strong>兼容性</strong>: 通过交换权能标志，客户端和服务器可以确保双方功能的兼容性，避免因不兼容的功能导致的错误。</li>
<li><strong>优化性能</strong>: 权能标志可以帮助服务器优化数据传输方式，选择最适合双方的协议和功能。</li>
</ol>
<p>第二篇主要是比较了一下短链接和长连接的区别，然后建议一般还是使用连接池来提升性能。</p>
<p>总结一下这篇文章的重点部分：</p>
<ul>
<li>短连接：<br><strong>客户端连接–创建socket认证连接–维护连接–数据传输–关闭连接</strong></li>
<li>长连接：<br><strong>客户端连接–创建socket认证连接–维护连接–数据传输–维护连接–数据传输…-关闭连接</strong></li>
<li>连接池：<br>连接池的一个核心思想就是<strong>连接复用</strong>，<strong>通过建立一个数据库连接池以及一套连接使用、分配和管理策略</strong>，使得该连接池中的连接可以得到高效、安全的复用，<strong>避免了数据库连接频繁建立、关闭的开销</strong>。</li>
</ul>
<p>因为常见数据库的连接是一个比较影响性能的一个事情，所以使用连接池的目的也是尽量少的创建连接，然后呢又要避免去维护很多空闲的连接</p>
<p>所以建议了解一下连接池的一些参数设置：（感觉我们只用关心下面四个被加粗的就行了）</p>
<ul>
<li><strong>初始化连接就是，创建的时候想池里放入的连接对象数</strong></li>
<li>最大连接数量，就是允许同一时间能都进行工作的最大数量，如果是0表示没有限制</li>
<li><strong>最大空闲连接，就是连接池中最大空闲连接数，如果超了，就要释放一部分空闲超时连接，如果是0表示不需要释放</strong></li>
<li><strong>最小空闲连接数，太少了就要进行创建</strong></li>
<li><strong>超时等待时间，如果一个访问到来的时候，已经到达了最大连接数，那这个请求会被放在请求等待队列中，开启一个计时器，如果经过这个时间后，还没有可用连接，就直接抛出异常给此用户。如果是-1表示无限等待。</strong></li>
</ul>
<p>后面感觉还是有一点不够用，又找了一些文章来看</p>
<ul>
<li><p><a href="https://blog.csdn.net/weixin_44296929/article/details/102738568">连接池总结（作用、对比、参数含义、以及讲解）-CSDN博客</a></p>
<p>看完之后感觉连接池就是类似公交车的长连接，用了很久才会被回收，但是每一个人都可以用，不像TCP长连接只能供一个人使用</p>
</li>
<li><p><a href="https://www.jianshu.com/p/6c61cc49a0ed">数据库连接池-常用参数配置及含义 - 简书 (jianshu.com)</a></p>
<p>这个讲的配置相对详细一点</p>
</li>
</ul>
<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p>
<p><img src="/2024/09/09/MySQL01/image-20240909145917788.png" alt="image-20240909145917788"></p>
<p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： <strong>Lost connection</strong> to MySQL server during query。<strong>这时候如果你要继续，就需要重连，然后再执行请求了。（这个情况我之前好像遇到过）</strong></p>
<p>数据库里面，<strong>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</strong>。</p>
<p><strong>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</strong></p>
<p>建议再看一篇文章，再看下面的东西</p>
<p>[<a href="https://zhuanlan.zhihu.com/p/43941022">玩转MySQL之二]MySQL连接机制浅析及运维 - 知乎 (zhihu.com)</a></p>
<p>这篇文章很好的解释了为什么有的时候是不能使用短连接的：</p>
<ul>
<li><p>在<a href="https://zhida.zhihu.com/search?q=%E6%85%A2%E9%80%9F%E7%BD%91%E7%BB%9C&zhida_source=entity&is_preview=1">慢速网络</a>下使用短连接，连接的开销会很大；在生产繁忙的系统中，连接也可能会受到系统端口数的限制，如果要每秒建立几千个连接，<strong>那么连接断开后，端口不会被马上回收利用，必须经历一个“FIN”阶段的等待，直到可被回收利用为止，这样就可能会导致端口资源不够用</strong>。</p>
</li>
<li><p>从客户端的角度来说，<strong>使用长连接有一个好处，可以不用每次创建新连接，若客户端对MySQL服务器的连接请求很频繁，永久连接将更加高效</strong>。对于**<a href="https://zhida.zhihu.com/search?q=%E9%AB%98%E5%B9%B6%E5%8F%91&zhida_source=entity&is_preview=1">高并发</a>业务<strong>，如果可能会碰到连接的冲击，</strong>推荐使用长连接或连接池。**</p>
</li>
<li><p>从服务器的角度来看，情况则略有不同，<strong>它可以节省创建连接的开销，但维持连接也是需要内存的</strong>。如果滥用长连接的话，可能会使用过多的MySQL<a href="https://zhida.zhihu.com/search?q=%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5&zhida_source=entity&is_preview=1">服务器连接</a>。<strong>现代的操作系统可以拥有几千个MySQL连接，但很有可能绝大部分都是睡眠（sleep）状态的，这样的工作方式不够高效，而且连接占据内存，也会导致内存的浪费。</strong></p>
</li>
<li><p>对于扩展性好的站点来说，其实大部分的访问并不需要连接数据库。<strong>如果用户需要频繁访问数据库，那么可能会在流量增大的时候产生性能问题</strong>，此时长短连接都是无法解决问题的，<strong>所以应该进行合理的设计和优化来避免性能问题。</strong></p>
</li>
<li><p>为了确保扩展性好的站点在高流量情况下仍能保持良好的性能，以下是一些<strong>合理的设计和优化策略</strong>：</p>
<p>\1. <strong>优化应用层</strong>—从应用程序代码来看</p>
<p>减少数据库请求: 在应用逻辑中优化数据访问，尽量减少数据库请求的次数。例如，<strong>通过批量查询或合并请求。</strong></p>
<p>使用分页: 对于大数据集，<strong>使用分页而不是一次性加载所有数据。</strong></p>
<p>\2.  <strong>缓存机制</strong>—从缓存中间件来看</p>
<p>使用缓存: <strong>在数据库前面引入缓存层（如 Redis、Memcached）来存储频繁访问的数据</strong>。这样可以减少数据库的直接查询次数。</p>
<p>页面缓存: <strong>对于静态内容或不常变化的页面，使用页面缓存可以减少数据库的压力</strong>。<strong>该放Nginx的放Nginx，该放CDN的放CDN。</strong></p>
<p>\3. **负载均衡 **—大的方面，从数据库实例来看</p>
<p><strong>多实例部署</strong>: 将数据库部署为<strong>主从复制或集群模式，使用负载均衡器分散请求，提高并发处理能力。</strong></p>
<p><strong>读写分离</strong>: 将读请求和写请求分开，<strong>写操作发送到主数据库，读操作发送到从数据库。</strong></p>
<p><strong>数据分片</strong>: 对于大规模数据，可以考虑数据分片，将数据分散到不同的数据库实例中，<strong>减少单个数据库的压力。</strong></p>
<p>\4.<strong>数据库优化</strong>—小的方面，从数据库表来看</p>
<p><strong>索引优化</strong>: 确保数据库表中的索引设置合理，以加速查询。</p>
<p><strong>查询优化</strong>: 使用 EXPLAIN 分析 SQL 查询，优化慢查询，减少不必要的数据检索。</p>
</li>
</ul>
<p>下面这个感觉又可以出一个场景题了</p>
<p>但是全部使用长连接后，你可能会发现，<strong>有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</strong></p>
<p>怎么解决这个问题呢？你可以考虑以下两种方案。（至于为什么是这样，你看后面的查询缓存就知道了）</p>
<ol>
<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>
<li>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>
</ol>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</p>
<p>MySQL拿到一个查询请求后，<strong>会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</strong></p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段。<strong>执行完成后，执行结果会被存入查询缓存中。</strong>你可以看到，<strong>如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</strong></p>
<p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p>
<p>查询缓存的失效非常频繁，<strong>只要有对一个表的更新，这个表上所有的查询缓存都会被清空</strong>。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，<strong>查询缓存的命中率会非常低</strong>。除非你的业务就是有一张<strong>静态表</strong>，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询<strong>才适合使用查询缓存</strong>。</p>
<p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。<strong>而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from table where ID = 10;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，<strong>也就是说8.0开始彻底没有这个功能了</strong>。</p>
<h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p><strong>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</strong></p>
<p>分析器先会做“<strong>词法分析</strong>”。<strong>你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</strong></p>
<p>这个有点像SICP讲的Scheme分析器啊<a href="https://composingprograms.netlify.app/3/4">组合语言的解释器 (composingprograms.netlify.app)</a></p>
<p>还有一点像ES的IK分词器，那个分词器里面我记得还有具体的算法来进行分词</p>
<p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p>
<p>做完了这些识别以后，就要做“<strong>语法分析</strong>”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p>
<p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; elect * from t where ID=1;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;elect * from t where ID=1&#x27; at line 1</span><br></pre></td></tr></table></figure>

<p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了<strong>分析器，MySQL就知道你要做什么了</strong>。在开始执行之前，还要先经过<strong>优化器的处理</strong>。</p>
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure>

<ul>
<li>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li>
<li>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li>
</ul>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>
<p><strong>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</strong>如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。</p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL<strong>通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句</strong>。</p>
<p>开始执行的时候，<strong>要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误</strong>，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): SELECT command denied to user &#x27;b&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27;</span><br></pre></td></tr></table></figure>

<p>如果有权限，就<strong>打开表继续执行</strong>。打开表的时候，<strong>执行器就会根据表的引擎定义，去使用这个引擎提供的接口</strong>。</p>
<p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p>
<ol>
<li><strong>调用InnoDB引擎接口</strong>取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ol>
<p>至此，这个语句就执行完成了。</p>
<p>对于有索引的表，执行的逻辑也差不多。<strong>第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口</strong>，这些接口都是引擎中已经定义好的。</p>
<p>你会在数据库的<strong>慢查询日志</strong>中看到一个<strong>rows_examined的字段</strong>，表示这个语句执行过程中扫描了多少行。<strong>这个值就是在执行器每次调用引擎获取数据行的时候累加的</strong>。</p>
<p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果表T中没有字段k，而你执行了这个语句 select * from T where k&#x3D;1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p>
<blockquote>
<p>在执行 SQL 查询的过程中，当出现类似于 “Unknown column ‘k’ in ‘where clause’” 的错误信息时，这是在语义分析阶段报出的错误。</p>
<p>具体的解析和执行过程如下：</p>
<ol>
<li><strong>词法分析和语法分析阶段</strong>：在这个阶段，MySQL 解析器将输入的 SQL 查询语句进行词法分析和语法分析，<strong>生成语法树（Parse Tree）或语法分析树（Parse Tree）</strong>。<strong>这个阶段主要是验证查询语句的语法正确性，检查语句中的关键字、标识符、运算符等是否符合语法规则。</strong></li>
<li><strong>语义分析阶段</strong>：<strong>在语义分析阶段，MySQL 对语法树进行进一步的分析和验证。这个阶段主要是检查语句的语义正确性，包括验证列和表的存在性、数据类型的匹配、约束条件的合法性等。</strong>在执行 SQL 查询时，MySQL 需要确保查询中使用的列和表是存在的。</li>
</ol>
<p>当执行语句 “SELECT * FROM T WHERE k&#x3D;1” 时，MySQL 会在<strong>语义分析阶段尝试解析和验证其中的列名</strong>。如果表 T 中不存在名为 ‘k’ 的列，MySQL 将报告 “Unknown column ‘k’ in ‘where clause’” 错误，表示查询中引用了不存在的列。</p>
<p>因此，<strong>该错误是在语义分析阶段报出的，即在验证查询语句的语义正确性时发现的</strong>。在这个阶段，MySQL 检查查询语句是否符合数据库模式的定义和约束条件。</p>
</blockquote>
<p>参考文章：<a href="https://jums.gitbook.io/mysql-shi-zhan-45-jiang/01-ji-chu-jia-gou-yi-tiao-sql-cha-xun-yu-ju-shi-ru-he-zhi-hang-de">01 基础架构：一条SQL查询语句是如何执行的？ | MySql实战45讲 (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>日志系统：一条SQL更新语句是如何执行的？</title>
    <url>/2024/09/09/MySQL02/</url>
    <content><![CDATA[<h1 id="日志系统：一条SQL更新语句是如何执行的？"><a href="#日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="日志系统：一条SQL更新语句是如何执行的？"></a>日志系统：一条SQL更新语句是如何执行的？</h1><p>前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中涉及的处理模块。相信你还记得，<strong>一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。</strong></p>
<p>那么，<strong>一条更新语句</strong>的执行流程又是怎样的呢？</p>
<p>之前你可能经常听DBA同事说，MySQL可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也会不免会好奇，这是怎样做到的呢？</p>
<p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整型字段c：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br></pre></td></tr></table></figure>

<p>如果要将ID&#x3D;2这一行的值加1，SQL语句就会这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure>

<p>前面介绍过SQL语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p>
<p><img src="/2024/09/09/MySQL02/image-20240909163544965.png" alt="image-20240909163544965"></p>
<p>你执行语句前要<strong>先连接数据库，这是连接器的工作</strong>。</p>
<p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，<strong>所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因</strong>。</p>
<p>接下来，<strong>分析器</strong>会通过词法和语法解析知道这是一条更新语句。<strong>优化器</strong>决定要使用ID这个索引。然后，<strong>执行器</strong>负责具体执行，找到这一行，然后更新。</p>
<p>与查询流程不一样的是，<strong>更新流程还涉及两个重要的日志模块</strong>，它们正是我们今天要讨论的主角：<strong>redo log（重做日志）和 binlog（归档日志）</strong>。如果接触MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log和binlog在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。</p>
<h3 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h3><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p>
<p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p>
<ul>
<li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li>
<li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li>
</ul>
<p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p>
<p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p>
<p>同样，在MySQL里也有这个问题，<strong>如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高</strong>。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p>
<p><strong>而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。（这个其实也是为了避免写了磁盘之后没有时间来得急写日志，导致Log不一致的问题）</strong></p>
<p>具体来说，当有一条记录需要更新的时候，<strong>InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了</strong>。同时，InnoDB引擎会在<strong>适当</strong>的时候，将这个操作记录<strong>更新到磁盘</strong>里面，<strong>而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事</strong>。</p>
<p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p>
<p>与此类似，<strong>InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</strong></p>
<p><img src="/2024/09/09/MySQL02/image-20240909164238628.png" alt="image-20240909164238628"></p>
<p><strong>write pos是当前记录的位置</strong>，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。<strong>checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。（我记得之前好像看过一个类似的环形更新方法，反正Redis分布式采用的方法有一个是环形的）</strong></p>
<p><strong>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。（有一点像JVM的STW）</strong></p>
<p>有了redo log，<strong>InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失</strong>，这个能力称为<strong>crash-safe</strong>。（这玩意经常在面试中问，大概就是什么MySQL数据库突然断电了，怎么找回数据的）</p>
<p>要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然<strong>停业</strong>几天，<strong>恢复</strong>生意后<strong>依然</strong>可以通过账本和粉板上的数据明确赊账账目。</p>
<h3 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h3><p>前面我们讲过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是<strong>MySQL功能层面</strong>的事情；还有一块是引擎层，<strong>负责存储</strong>相关的具体事宜。上面我们聊到的粉板redo log是<strong>InnoDB引擎特有的日志</strong>，而<strong>Server层也有自己的日志，称为binlog（归档日志）</strong>。</p>
<p>我想你肯定会问，为什么会有两份日志呢？</p>
<p>因为<strong>最开始</strong>MySQL里<strong>并没有InnoDB引擎</strong>。<strong>MySQL自带的引擎是MyISAM</strong>，但是MyISAM<strong>没有</strong>crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</p>
<p>这两种日志有以下三点不同。</p>
<ol>
<li>从引擎来看：<strong>redo log是InnoDB引擎特有的</strong>；<strong>binlog是MySQL的Server层实现的，所有引擎都可以使用。</strong></li>
<li>从日志类型来看：<strong>redo log是物理日志</strong>，记录的是“在某个数据页上做了什么修改”；<strong>binlog是逻辑日志</strong>，记录的是这个语句的原始逻辑，比如“给ID&#x3D;2这一行的c字段加1 ”。<strong>（这个binlog记录的逻辑日志和Redis的AOF（Append Only File）挺类似的）</strong></li>
<li>从空间使用来看：<strong>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</strong></li>
</ol>
<p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。</p>
<ol>
<li>执行器先找引擎取ID&#x3D;2这一行。ID是主键，<strong>引擎直接用树（B+树）搜索找到这一行</strong>。如果ID&#x3D;2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。<strong>（这个有点类似用户态和内核态，写入之类的不安全操作交给操作系统内核执行）</strong></li>
<li>引擎将这行新数据<strong>更新到内存</strong>中，同时将这个<strong>更新操作记录到redo log</strong>里面，<strong>此时redo log处于prepare状态</strong>。<strong>然后告知执行器执行完成了，随时可以提交事务</strong>。</li>
<li><strong>执行器生成这个操作的binlog，并把binlog写入磁盘。</strong></li>
<li>执行器调用引擎的提交事务接口，<strong>引擎把刚刚写入的redo log改成提交（commit）状态</strong>，更新完成。</li>
</ol>
<p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的<strong>（反正只要是执行写操作就一定是在InnoDB中执行的，它这里深色表示只是代表调用了引擎的接口）</strong>，<strong>深色框表示是在执行器</strong>中执行的。</p>
<p><img src="/2024/09/09/MySQL02/image-20240909165928810.png" alt="image-20240909165928810"></p>
<p>你可能注意到了，最后三步看上去有点“绕”，<strong>将redo log的写入拆成了两个步骤</strong>：<strong>prepare和commit</strong>，这就是”两阶段提交”。（搞半天原来后面讲了）</p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>为什么必须有“两阶段提交”呢？<strong>这是为了让两份日志之间的逻辑一致。</strong>要说明这个问题，我们得从文章开头的那个问题说起：<strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p>
<p>前面我们说过了，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，<strong>同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</strong></p>
<p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，<strong>需要找回数据</strong>，那你可以这么做：</p>
<ul>
<li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，<strong>从这个备份恢复到临时库</strong>；</li>
<li><strong>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</strong></li>
</ul>
<p><strong>这里的思路挺像Docker的镜像构建方式的，都是将一个基础的东西作为我们的基石，然后再在上面加东西</strong></p>
<p><strong>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</strong></p>
<p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p>
<p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，<strong>要么就是先写完redo log再写binlog</strong>，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p>
<p>仍然用前面的update语句来做例子。假设当前ID&#x3D;2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p>
<ol>
<li><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。 <strong>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。 然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同</strong>。</li>
<li><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，<strong>与原库的值不同</strong>。</li>
</ol>
<p><strong>看样子意思是binlog才能恢复一个完整的数据库，redo log一般用于恢复数据库突然故障丢失的数据</strong></p>
<p><strong>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</strong></p>
<p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要<strong>恢复临时库</strong>的场景呀？</p>
<p>其实不是的，<strong>不只是误操作后需要用这个过程来恢复数据</strong>。当你需要<strong>扩容</strong>的时候，也就是需要<strong>再多搭建一些备库来增加系统的读能力的时候</strong>，现在常见的做法也是用<strong>全量备份</strong>加上<strong>应用binlog</strong>来实现的，<strong>这个“不一致”就会导致你的线上出现主从数据库不一致的情况</strong>。</p>
<p><strong>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>介绍了MySQL里面最重要的两个日志，<strong>即物理日志redo log和逻辑日志binlog</strong>。</p>
<p><strong>redo log用于保证crash-safe能力</strong>。<strong>innodb_flush_log_at_trx_commit</strong>这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。<strong>这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</strong></p>
<p><strong>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</strong></p>
<p>此外还介绍了与MySQL日志系统密切相关的“两阶段提交”。两阶段提交是跨系统<strong>维持数据逻辑一致性</strong>时<strong>常用</strong>的一个方案，即使你不做数据库内核开发，<strong>日常开发</strong>中也有可能会用到。</p>
<p>前面说到定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？</p>
<p>补充资料：（小林Coding写的还是比较详细的）</p>
<p><a href="https://blog.csdn.net/weixin_63566550/article/details/129819638">【MySQL】一文彻底搞懂 Redo-log 为什么要两阶段提交？_mysql redolog两阶段提交-CSDN博客</a></p>
<p>把这篇文章比较重要的东西提取到下面了：</p>
<p>两阶段提交的过程是怎样的？</p>
<p>相信大家应该听说过<code>MySQL</code>事务两阶段提交方案，啥叫做事务两阶段提交呢？实则是指<code>Redo-log</code>分两次写入，如下：</p>
<p><img src="/2024/09/09/MySQL02/image-20240909191851549.png" alt="image-20240909191851549"></p>
<p>从图中可看出，事务的提交过程有两个阶段，<strong>就是将 redo log 的写入拆成了两个步骤：prepare 和 commit</strong>，<strong>中间再穿插写入binlog</strong>，具体如下：</p>
<ul>
<li><strong>prepare 阶段：</strong>将 XID（内部 XA 事务的 ID） 写入到 redo log，<strong>同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit &#x3D; 1 的作用）；</strong></li>
<li><strong>commit 阶段：</strong>把 XID 写入到 binlog，然后<strong>将 binlog 持久化到磁盘（sync_binlog &#x3D; 1 的作用），</strong>接着调用引擎的提交事务接口，<strong>将 redo log 状态设置为 commit</strong>，此时该状态并<strong>不需要持久化</strong>到磁盘，<strong>只需要 write 到文件系统的 page cache 中就够了</strong>，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，<strong>一样会被认为事务已经执行成功；</strong></li>
</ul>
<p>为什么需要两阶段提交？</p>
<blockquote>
<p>其实想要弄明白这个问题，要结合bin-log日志一起来聊。</p>
</blockquote>
<p>如果只写一次的话，那到底先写bin-log还是redo-log呢？</p>
<ul>
<li><strong>先写bin-log，再写redo-log：</strong>当事务提交后，先写bin-log成功，结果在写redo-log时断电宕机了，再重启后由于redo-log中没有该事务的日志记录，因此不会恢复该事务提交的数据。但要注意，主从架构中同步数据是使用bin-log来实现的，而宕机前bin-log写入成功了，就代表这个事务提交的数据会被同步到从机，<strong>也就意味着从机会比主机多出一条数据。</strong></li>
<li><strong>先写redo-log，再写bin-log：</strong>当事务提交后，先写redo-log成功，但在写bin-log时宕机了，主节点重启后，会根据redo-log恢复数据，但从机依旧是依赖bin-log来同步数据的，因此从机无法将这个事务提交的数据同步过去，毕竟bin-log中没有撒，<strong>最终从机会比主机少一条数据。</strong></li>
</ul>
<p>经过上述分析后可得知：如果redo-log<strong>只写一次</strong>，那不管谁先写，<strong>都有可能造成主从同步数据时的不一致问题</strong>出现，<strong>为了解决该问题，redo-log就被设计成了两阶段提交模式</strong>，设置成两阶段提交后，整个执行过程有三处崩溃点：</p>
<ul>
<li>redo-log(prepare)：在写入准备状态的redo记录时宕机，事务还未提交，<strong>不会影响一致性</strong>。</li>
<li>bin-log：在写bin记录时崩溃，重启后会根据redo记录中的事务ID，<strong>回滚</strong>前面已写入的数据。（然后会继续执行这个过程）</li>
<li>redo-log(commit)：在bin-log写入成功后，<strong>写redo(commit)记录时崩溃</strong>，因为bin-log中已经写入成功了，<strong>所以从机也可以同步数据，因此重启时直接再次提交事务</strong>，写入一条redo(commit)记录即可。（这种commit一半没有成功的，之后再commit一次就行了）</li>
</ul>
<p>通过这种两阶段提交的方案，就能够确保redo-log、bin-log两者的日志数据是相同的，<strong>bin-log中有的主机再恢复，如果bin-log没有则直接回滚主机上写入的数据，确保整个数据库系统的数据一致性。</strong></p>
<blockquote>
<p>OK~,最后再简单补充一点：为什么bin-log又被叫做二进制日志呢？因为记录日志时，MySQL写入的是二进制数据，而并非字符数据，也就意味着直接用cat&#x2F;vim这类工具是无法打开的，必须要通过MySQL提供的mysqlbinlog工具解析查看。</p>
</blockquote>
<p>两阶段提交有什么问题？</p>
<p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：</p>
<ul>
<li>磁盘 I&#x2F;O 次数高：对于“双1”配置，<strong>每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</strong></li>
<li>锁竞争激烈：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li>
</ul>
<p>为什么两阶段提交的磁盘 <strong>I&#x2F;O 次数会很高</strong>？</p>
<p>binlog 和 redo log 在内存中都对应的缓存空间，binlog 会缓存在 binlog cache，redo log 会缓存在 redo log buffer，它们持久化到磁盘的时机分别由下面这两个参数控制。一般我们为了避免日志丢失的风险，会将这两个参数设置为 1：</p>
<ul>
<li>当 sync_binlog &#x3D; 1 的时候，表示每次提交事务都会将 binlog cache 里的 binlog 直接持久到磁盘；</li>
<li>当 innodb_flush_log_at_trx_commit &#x3D; 1 时，表示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘；</li>
</ul>
<p><strong>可以看到，如果 sync_binlog 和 当 innodb_flush_log_at_trx_commit 都设置为 1，那么在每个事务提交过程中， 都会至少调用 2 次刷盘操作，一次是 redo log 刷盘，一次是 binlog 落盘，所以这会成为性能瓶颈。</strong></p>
<p>为什么锁竞争激烈？</p>
<p>在早期的 MySQL 版本中，通过使用 prepare_commit_mutex 互斥锁来保证事务提交的顺序，<strong>在一个事务获取到锁时才能进入 prepare 阶段，一直到 commit 阶段结束才能释放锁，下个事务才可以继续进行 prepare 操作。</strong></p>
<p><strong>通过加锁虽然完美地解决了顺序一致性的问题，但在并发量较大的时候，就会导致对锁的争用，性能不佳。</strong></p>
<p>参考文章：<a href="https://jums.gitbook.io/mysql-shi-zhan-45-jiang/02-ri-zhi-xi-tong-yi-tiao-sql-geng-xin-yu-ju-shi-ru-he-zhi-hang-de">02 日志系统：一条SQL更新语句是如何执行的？ | MySql实战45讲 (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>事务隔离：为什么你改了我还看不见？</title>
    <url>/2024/09/09/MySQL03/</url>
    <content><![CDATA[<p>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转100块钱，而此时你的银行卡只有100块钱。</p>
<p>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这100块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。</p>
<p><strong>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。</strong>在MySQL中，<strong>事务支持是在引擎层实现的。</strong>你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。<strong>比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。</strong></p>
<p>今天的文章里，我将会以InnoDB为例，剖析MySQL在事务支持方面的特定实现，并基于原理给出相应的实践建议，希望这些案例能加深你对MySQL事务原理的理解。</p>
<h3 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h3><p>提到事务，你肯定会想到<strong>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</strong>，今天我们就来说说其中I，也就是“隔离性”。</p>
<p>当数据库上有多个事务同时执行的时候，就可能出现<strong>脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong>，为了解决这些问题，就有了“隔离级别”的概念。（简单的说，隔离级别是对于事务而言的，隔离的是事务不是其他的东西）</p>
<p>在谈隔离级别之前，你首先要知道，你<strong>隔离得越严实，效率就会越低</strong>。因此很多时候，我们都要在二者之间寻找一个平衡点。<strong>SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。</strong>下面我逐一为你解释：</p>
<ul>
<li><strong>读未提交</strong>是指：一个事务还<strong>没提交</strong>时，它做的变更<strong>就能被别的事务看到</strong>。（可以读到别人没有提交的事务，等同于考试的时候可以直接看到别人试卷的答案）</li>
<li><strong>读提交</strong>是指：一个事务提交之后，它做的变更才会被其他事务看到。（你提交试卷之后我才能看到你的答案）</li>
<li><strong>可重复读</strong>是指：<strong>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的</strong>。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。（始终相信自己最开始见到的数据是不会变化的，可以重复读取到最开始的值。<strong>这个其实底层是靠undo log的回滚指针不停往前找的</strong>）</li>
<li><strong>串行化</strong>：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。<strong>当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</strong>（<strong>串行就是排队等待，排成一行</strong>）</li>
</ul>
<p>其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表T中只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line">insert into T(c) values(1);</span><br></pre></td></tr></table></figure>

<p>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。</p>
<p><img src="/2024/09/09/MySQL03/image-20240909200825360.png" alt="image-20240909200825360"></p>
<ul>
<li><strong>若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。</strong>因此，V2、V3也都是2。</li>
<li>若隔离级别是“读提交”，则V1是1，V2的值是2。<strong>事务B的更新在提交后才能被A看到。</strong>所以， V3的值也是2。</li>
<li>若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：<strong>事务在执行期间看到的数据前后必须是一致的。</strong></li>
<li>若隔离级别是“串行化”，<strong>则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。</strong>所以从A的角度看， V1、V2值是1，V3的值是2。</li>
</ul>
<p>在实现上，数据库里面会<strong>创建一个视图</strong>，访问的时候<strong>以视图的逻辑结果为准</strong>。（视图的作用体现在这里了）</p>
<ul>
<li>在“可重复读”隔离级别下，<strong>这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</strong></li>
<li>在“读提交”隔离级别下，<strong>这个视图是在每个SQL语句开始执行的时候创建的。</strong></li>
<li>这里需要注意的是，<strong>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念。</strong></li>
<li>而“串行化”隔离级别下<strong>直接用加锁的方式来避免并行访问。</strong></li>
</ul>
<p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。<strong>Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。（MySQL 的默认事务隔离级别是 <strong>REPEATABLE READ</strong>（可重复读））</strong></p>
<p>配置的方式是，<strong>将启动参数transaction-isolation的值设置成READ-COMMITTED</strong>。你可以用show variables来查看当前的值。（这个输出的东西很多，你可以指定输出流输入到一个文件中看看）</p>
<p><img src="/2024/09/09/MySQL03/image-20240909201622812.png" alt="image-20240909201622812"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;transaction_isolation&#x27;;</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"></span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。我想<strong>你可能会问那什么时候需要“可重复读”的场景呢</strong>？我们来看一个数据校对逻辑的案例。</p>
<p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。<strong>这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</strong></p>
<p><strong>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</strong></p>
<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。</p>
<p><strong>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。（这就是Undo log用于回滚的。Undo Log（撤销日志）在数据库管理系统中用于实现回滚操作，确保数据的完整性和一致性）</strong></p>
<p>建议先看完这篇博客再看下面的内容</p>
<p><a href="https://blog.csdn.net/Weixiaohuai/article/details/117867353">MySQL回滚日志（undo log）总结_mysql undo log-CSDN博客</a></p>
<p>下面是这篇文章比较重要的部分：</p>
<p>MVCC（Multi-Version Concurrency Control，<strong>多版本并发控制</strong>）是一种用于数据库管理系统的并发控制机制，旨在允许<strong>多个事务同时读取和写入数据，而不互相阻塞</strong>。</p>
<p>在MySQL数据库InnoDB存储引擎中，用undo Log来实现多版本并发控制(MVCC)。</p>
<p><strong>当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据版本是怎样的，从而让用户能够读取到当前事务操作之前的数据【快照读】。</strong></p>
<p>下面解释一下什么是快照读，与之对应的还有一个是—当前读。</p>
<ul>
<li>快照读：<br>SQL读取的数据是快照版本【可见版本】，<strong>也就是历史版本</strong>，不用加锁，普通的SELECT就是快照读。</li>
<li>当前读：<br><strong>SQL读取的数据是最新版本。</strong>通过锁机制来保证读取的数据无法通过其他事务进行修改UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE都是当前读。</li>
</ul>
<p>说实话，这个玩意的底层实现很类似于Git的底层实现</p>
<p>undo log的存储机制</p>
<p>undo log的存储<strong>由InnoDB存储引擎</strong>实现，<strong>数据保存在InnoDB的数据文件中</strong>。</p>
<p>在InnoDB存储引擎中，undo log是<strong>采用分段(segment)的方式进行存储的</strong>。<strong>rollback segment称为回滚段，每个回滚段中有1024个undo log segment。</strong></p>
<p>在MySQL5.5之前，只支持1个rollback segment，也就是<strong>只能记录1024个undo操作</strong>。（这个记录的方式和Redis的AOF很类似）</p>
<p><strong>在MySQL5.5之后，可以支持128个rollback segment，分别从resg slot0 - resg slot127，每一个resg slot，也就是每一个回滚段，内部由1024个undo segment 组成，即总共可以记录128 * 1024个undo操作。（这个又有一点像Redis分片集群的slot槽）</strong></p>
<p><img src="/2024/09/09/MySQL03/image-20240909210933285.png" alt="image-20240909210933285"></p>
<p><strong>undo log日志里面不仅存放着数据更新前的记录，还记录着RowID、事务ID、回滚指针。（这个玩意和Git底层很类似）</strong>其中事务ID每次递增，回滚指针第一次如果是insert语句的话，回滚指针为NULL，第二次update之后的undo log的回滚指针就会指向刚刚那一条undo log日志，依次类推，就会形成一条undo log的回滚链，方便找到该条记录的历史版本。</p>
<p>undo log的工作原理</p>
<p>在更新数据之前，MySQL会<strong>提前</strong>生成undo log日志，当<strong>事务提交</strong>的时候，并<strong>不会立即删除undo log</strong>，要执行回滚（rollback）操作时，从缓存中读取数据。<strong>undo log日志的删除是通过通过后台purge线程进行回收处理的。</strong></p>
<p><img src="/2024/09/09/MySQL03/image-20240909211811977.png" alt="image-20240909211811977"></p>
<p>如上图：</p>
<ul>
<li>1、事务A执行update操作，此时事务还没提交，<strong>会将数据进行备份到对应的undo buffer，然后由undo buffer持久化到磁盘中的undo log文件中，此时undo log保存了未提交之前的操作日志</strong>，接着将操作的数据，也就是Teacher表的数据持久保存到<strong>InnoDB的数据文件IBD。</strong>（注意是先在缓存中记录到undo buffer再持久化到undo log日志中，最后才是将数据持久化到存储引擎的IBD文件中）</li>
<li>2、此时事务B进行查询操作，直接从undo buffer缓存中进行读取，这时事务A还没提交事务。如果要回滚（rollback）事务，是不读磁盘的，<strong>先直接从undo buffer缓存读取。</strong></li>
</ul>
<p>用undo log实现原子性和持久化的事务的简化过程：</p>
<p>假设有A、B两个数据，值分别为1,2。</p>
<ul>
<li>A. 事务开始</li>
<li>B. 记录A&#x3D;1到undo log中</li>
<li>C. 修改A&#x3D;3</li>
<li>D. 记录B&#x3D;2到undo log中</li>
<li>E. 修改B&#x3D;4</li>
<li>F. 将undo log写到磁盘 ——-<strong>undo log持久化</strong></li>
<li>G. 将数据写到磁盘 ——-<strong>数据持久化</strong></li>
<li>H. 事务提交 ——-<strong>提交事务</strong></li>
</ul>
<p>之所以能同时保证原子性和持久化，是因为以下特点：</p>
<ul>
<li><strong>更新数据前</strong>记录undo log。</li>
<li>为了保证持久性，<strong>必须将数据在事务提交前写到磁盘，只要事务成功提交，数据必然已经持久化到磁盘。</strong></li>
<li><strong>undo log必须先于数据持久化到磁盘。</strong>如果在G,H之间发生<strong>系统崩溃</strong>，undo log是完整的，<strong>可以用来回滚。</strong></li>
<li>如果在A - F之间发生系统崩溃，因为数据没有持久化到磁盘，所以磁盘上的数据还是保持在事务开始前的状态。</li>
</ul>
<p>缺陷：每个事务提交前将数据和undo log写入磁盘，这样会导致大量的磁盘IO，因此性能较差。 <strong>如果能够将数据缓存一段时间，就能减少IO提高性能，但是这样就会失去事务的持久性。</strong></p>
<blockquote>
<p><strong>undo日志属于逻辑日志，redo（recovery）是物理日志</strong>，所谓逻辑日志是undo log<strong>是记录一个操作过程</strong>，不会物理删除</p>
<p><strong>binlog也是逻辑日志，AOF也是逻辑日志</strong></p>
<p>undo log，sql执行delete或者update操作都会记录一条undo日志</p>
<p><strong>undo是应对数据库回滚的情况，redo是应对数据库执行到一半故障继续执行的情况，binlog是应对恢复数据库的情况</strong></p>
</blockquote>
<p>再看一篇试试</p>
<p><a href="https://cloud.tencent.com/developer/article/2220871">图文结合带你搞定MySQL日志之Undo log(回滚日志)-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p>下面提取了部分重点内容：</p>
<p><strong>如何理解Undo Log</strong></p>
<p>事务需要保证<strong>原子性</strong>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p>
<ul>
<li>情况一：事务执行过程中可能遇到<strong>各种错误</strong>，比如<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>本身的错误，操作系统错误，甚至是突然断电导致的错误。</li>
<li>情况二：DBA可以在事务执行过程中手动输入ROLLBACK语句结束当前事务的执行。以上情况出现，我们需要把数据改回原先的样子，这个过程称之为回滚。</li>
</ul>
<p>每当我们要对一条记录做改动时**(这里的改动可以指<code>INSERT、DELETE、UPDATE</code>)，都需要把回滚时所需的东西记下来。**比如:</p>
<ul>
<li>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。**(对于每个<code>INSERT</code>, InnoDB存储引擎会完成一个<code>DELETE</code>)**</li>
<li>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。**(对于每个<code>DELETE</code>,InnoDB存储引擎会执行一个<code>INSERT</code>)**</li>
<li>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。**(对于每个<code>UPDATE</code>，InnoDB存储引擎会执行一个<code>相反的UPDATE</code>，将修改前的行放回去)**</li>
</ul>
<p><a href="https://cloud.tencent.com/product/cdb?from_column=20065&from=20065">MySQL</a>把这些为了回滚而记录的这些内容称之为<code>撤销日志</code>或者<code>回滚日志</code>(即Undo Log)。<strong>注意，由于查询操作(SELECT）并不会修改任何用户记录，所以在杳询操作行时，并不需要记录相应的Undo日志</strong></p>
<p><strong>此外，Undo Log会产生<code>Redo Log</code>，也就是Undo Log的产生会伴随着Redo Log的产生，这是因为Undo Log也需要持久性的保护。</strong></p>
<p>这里解释一下，为什么它们是相辅相成的，这里简单的说一下，本来我们执行到一半挂了，undo是回到开始，redo是继续执行完</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在数据库管理系统中，Undo Log 和 Redo Log 是用于实现数据一致性和事务管理的两种重要日志，它们通常会一起生成，以确保在事务过程中能够安全地恢复数据。以下是详细解释：</span><br><span class="line"></span><br><span class="line">### 1. **Undo Log 的作用**</span><br><span class="line"></span><br><span class="line">- **回滚功能**: Undo Log 记录了事务对数据的修改前状态，允许在事务失败或被中断时将数据恢复到修改之前的状态。</span><br><span class="line">- **持久性保护**: 为了确保在系统崩溃或故障后仍能进行数据恢复，Undo Log 必须被持久化到磁盘。</span><br><span class="line"></span><br><span class="line">### 2. **Redo Log 的作用**</span><br><span class="line"></span><br><span class="line">- **恢复功能**: Redo Log 记录了已提交事务的修改操作，用于在系统崩溃后重放这些操作，从而恢复数据到最新状态。</span><br><span class="line">- **事务的完整性**: Redo Log 确保即使在故障发生时，已提交的事务也不会丢失。</span><br><span class="line"></span><br><span class="line">### 3. **二者的关系**</span><br><span class="line"></span><br><span class="line">- **同时生成**: 在事务执行过程中，每当数据库修改数据时，系统会同时生成 Undo Log 和 Redo Log。</span><br><span class="line">  - **Undo Log**: 记录修改前的状态，以便在需要回滚时使用。</span><br><span class="line">  - **Redo Log**: 记录修改后的状态，以便在系统重启时重放已提交的事务。</span><br><span class="line">- **持久性需求**:</span><br><span class="line">  - Undo Log 需要被持久化，以确保在崩溃后能够恢复未完成的事务或回滚操作。</span><br><span class="line">  - Redo Log 则确保已完成的事务能够在故障后恢复。</span><br><span class="line"></span><br><span class="line">### 4. **总结**</span><br><span class="line"></span><br><span class="line">因此，Undo Log 和 Redo Log 的产生是相辅相成的。Undo Log 提供了回滚的能力，而 Redo Log 确保了已提交事务的持久性。两者的结合使得数据库能够在发生故障时，既能恢复到一致的状态，又能保证数据的完整性和安全性。</span><br></pre></td></tr></table></figure>

<p><strong>Undo Log的存储结构</strong></p>
<p>InnoDB对Undo Log的管理采用段的方式，也就是<code>回滚段（rollback segment）</code>。每个回滚段记录了<code>1024 个Undo Log segment</code>，而在每个Undo Log segment段中进行<code>Undo页</code>的申请。</p>
<p>在<code>InnoDB1.1版本</code>之前（不包括1.1版本），只有一个<code>rollback segment</code>，因此支持<strong>同时在线</strong>的事务限制为 <strong>1024</strong>。虽然对绝大多数的应用来说都已经够用。</p>
<p>从1.1版本开始InnoDB支持最大<code>128个rollback segment</code>，故其支持<strong>同时在线的事务</strong>限制提高到了<code>128*1024</code>。</p>
<p>虽然InnoDB1.1版本支持了128个<code>rollback segment</code>，但是这些<code>rollback segment</code>都存储于共享表空间<strong>ibdata（上面提到的IBD文件）</strong>中。从lnnoDB1.2版本开始，可通过参数对<code>rollback segment</code>做进一步的设置。这些参数包括:</p>
<ul>
<li><code>innodb_undo_directory:</code>设置rollback segment文件所在的路径。这意味着rollback segment可以存放在共享表空间以外的位置，即可以设置为独立表空间。该参数的默认值为“.&#x2F;”，表示当前InnoDB存储引擎的目录。</li>
<li><code>innodb_undo_logs:</code>设置rollback segment的个数，默认值为128。在InnoDB1.2版本中，该参数用来替换之前版本的参数innodb_rollback_segments。</li>
<li><code>innodb_undo_tablespaces:</code>设置构成rollback segment文件的数量，这样rollback segment可以较为平均地分布在多个文件中。设置该参数后，会在路径innodb_undo_directory看到undo为前缀的文件，该文件就代表rollback segment文件。</li>
</ul>
<p>当事务提交时，InnoDB存储引擎会做以下两件事情：    </p>
<ul>
<li>1.将Undo Log放入列表中，<strong>以供之后的purge(清洗、清除)操作</strong>    </li>
<li>2.判断Undo Log所在的页是否可以重用(低于3&#x2F;4可以重用)，若可以分配给下个事务使用</li>
</ul>
<p><strong>Undo页的重用</strong></p>
<p>当我们开启一个事务需要写Undo log的时候，就得先去<code>Undo Log segment</code>中去找到一个空闲的位置，当有空位的时候，就去申请Undo页，在这个申请到的Undo页中进行Undo Log的写入。<strong>我们知道MySQL默认一页的大小是<code>16k</code>。</strong></p>
<p>为每一个事务分配一个页，<strong>是非常浪费的</strong>(除非你的事务非常长)，假设你的应用的TPS(每秒处理的事务数目)为1000，那么1s就需要1000个页，大概需要16M的存储，1分钟大概需要1G的存储。<strong>如果照这样下去除非MySQL清理的非常勤快，否则随着时间的推移，磁盘空间会增长的非常快</strong>，而且很多空间都是浪费的。</p>
<p><strong>于是Undo页就被设计的可以重用了</strong>，当事务提交时，并<strong>不会立刻删除</strong>Undo页。因为重用，所以这个Undo页可能混杂着其他事务的Undo Log。<strong>Undo Log在commit后，会被放到一个链表中，然后判断Undo页的使用空间是否小于3&#x2F;4，如果小于3&#x2F;4的话，则表示当前的Undo页可以被重用，那么它就不会被回收，其他事务的Undo Log可以记录在当前Undo页的后面。</strong>由于Undo Log是离散的，所以清理对应的磁盘空间时，效率不高。</p>
<p><strong>Undo Log的类型</strong></p>
<p>在InnoDB存储引擎中，Undo Log分为：</p>
<ul>
<li><p><strong>insert Undo Log</strong> </p>
<p>insert Undo Log是指在insert操作中产生的Undo Log。<strong>因为insert操作的记录，只对事务本身可见，对其他事务不可见(这是事务隔离性的要求)，故该Undo Log可以在事务提交后直接删除。不需要进行purge操作。</strong></p>
</li>
<li><p><strong>update Undo Log</strong></p>
<p>update Undo Log记录的是对delete和update操作产生的Undo Log。该Undo Log可能需要提供MVCC机制，因此<strong>不能在事务提交时就进行删除</strong>。提交时放入Undo Log链表，等待purge线程进行最后的删除。</p>
</li>
</ul>
<p><strong>Undo Log的生命周期</strong></p>
<p>以下是Undo+Redo事务的简化过程: 假设有2个数值，分别为 A&#x3D;1 和 B&#x3D;2 ，然后将A修改为3，B修改为4</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> start transaction;</span><br><span class="line"><span class="number">2</span>．记录A=<span class="number">1</span>到<span class="title class_">Undo</span> <span class="title class_">Log</span>;</span><br><span class="line"><span class="number">3.</span> update A = <span class="number">3</span>;</span><br><span class="line"><span class="number">4</span>．记录A=<span class="number">3</span> 到<span class="title class_">Redo</span> <span class="title class_">Log</span>;</span><br><span class="line"><span class="number">5</span>．记录B=<span class="number">2</span>到<span class="title class_">Undo</span> <span class="title class_">Log</span>;</span><br><span class="line"><span class="number">6.</span> update B = <span class="number">4</span>;</span><br><span class="line"><span class="number">7</span>．记录B=<span class="number">4</span>到<span class="title class_">Redo</span> <span class="title class_">Log</span>;</span><br><span class="line"><span class="number">8</span>．将<span class="title class_">Redo</span> <span class="title class_">Log</span>刷新到磁盘;</span><br><span class="line"><span class="number">9.</span> commit</span><br></pre></td></tr></table></figure>

<ul>
<li>在1-8步骤的任意一步系统宕机，<strong>事务未提交，该事务就不会对磁盘上的数据做任何影响</strong>。</li>
<li>如果在8-9之间宕机。<ul>
<li>Redo Log 进行恢复</li>
<li>Undo Log 发现有事务没完成进行回滚。</li>
</ul>
</li>
<li>若在9之后系统宕机，内存映射中变更的数据<strong>还来不及刷回磁盘</strong>，那么系统恢复之后，<strong>可以根据Redo Log把数据刷回磁盘。</strong></li>
</ul>
<p>流程图：</p>
<p><strong>这里还有一个binlog没有画，突然想起来之前使用Seata的时候好像就出现过这个redo，undo，binlog了</strong></p>
<p><strong>又想起来了，之前使用ShardingSphere的时候就是使用的它的binlog来实现主从复制的</strong></p>
<p><img src="/2024/09/09/MySQL03/image-20240909220208902.png" alt="image-20240909220208902"></p>
<p>接下来再继续看</p>
<p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p>
<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，<strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong>。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p>
<p><img src="/2024/09/09/MySQL03/image-20240909204425101.png" alt="image-20240909204425101"></p>
<p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的，因为只要是修改没有commit，看的都是undo log中的备份数据。</p>
<p><strong>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</strong></p>
<p>什么时候才不需要了呢？<strong>就是当系统里没有比这个回滚日志更早的read-view的时候。（这里的回收机制有点类似GCRoot）</strong></p>
<p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p>
<p>长事务意味着<strong>系统里面会存在很老的事务视图</strong>。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会<strong>导致大量占用存储空间</strong>。</p>
<p>这里简单提一下为什么会有那么长的事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 业务逻辑复杂</span><br><span class="line">复杂的处理流程: 某些业务逻辑涉及多个步骤，可能需要长时间才能完成。例如，涉及审批、审核或多方协作的事务。</span><br><span class="line">2. 用户交互</span><br><span class="line">等待用户输入: 在许多应用中，事务可能需要等待用户的输入或确认。例如，在线购物中的支付过程，用户可能需要时间来确认付款。</span><br><span class="line">3. 网络延迟</span><br><span class="line">网络问题: 在分布式系统中，网络延迟可能导致事务处理时间延长。如果事务需要访问多个服务或数据库，网络问题可能导致长时间未提交。</span><br><span class="line">4. 锁竞争</span><br><span class="line">资源争用: 长事务可能会持有锁，导致其他事务无法执行。为了避免死锁，开发者可能选择不立即提交事务，而是等待某个条件满足。</span><br><span class="line">5. 性能问题</span><br><span class="line">数据库性能瓶颈: 如果数据库性能较差，查询或写入操作可能会耗时较长，导致事务延迟提交。</span><br><span class="line">6. 故障恢复</span><br><span class="line">故障处理: 如果系统或应用在处理事务时遇到故障，可能会导致事务未能及时提交，处于挂起状态。</span><br><span class="line">7. 设计缺陷</span><br><span class="line">系统设计不当: 如果系统设计没有考虑到事务的合理管理，可能会导致长时间持有未提交的事务。</span><br><span class="line">8. 长时间运行的报告或查询</span><br><span class="line">复杂查询: 某些查询可能需要长时间执行，尤其是在大数据集上进行复杂的分析和报告时，可能会导致事务维持较长时间。</span><br><span class="line">总结</span><br><span class="line">长事务未提交的原因可能涉及业务逻辑、用户交互、网络延迟、锁竞争等多种因素。长时间存在的事务视图会导致存储空间占用增加，影响数据库性能，因此在设计时应该尽量避免长事务，及时提交或回滚事务，以提高系统的效率和稳定性。</span><br></pre></td></tr></table></figure>

<p>在MySQL 5.5及以前的版本，<strong>回滚日志是跟数据字典一起放在ibdata文件里的</strong>，即使<strong>长事务最终提交，回滚段被清理，文件也不会变小</strong>。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。</p>
<p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：</p>
<ol>
<li><p>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</p>
</li>
<li><p>set autocommit&#x3D;0，<strong>这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交</strong>。这个事务持续存在直到你<strong>主动执行commit 或 rollback 语句</strong>，或者断开连接。</p>
</li>
</ol>
<p>有些客户端连接框架会默认连接成功后先执行一个set autocommit&#x3D;0的命令。<strong>这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</strong></p>
<p><strong>因此，我会建议你总是使用set autocommit&#x3D;1, 通过显式语句的方式来启动事务。</strong></p>
<p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用commit work and chain语法。</p>
<p>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。<strong>如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。（详细的可以看看这篇文章<a href="https://juejin.cn/post/6987373561836994590">带你看看事务的分类和在MySQL中使用链式事务 | SQL全面教程七：事务(3)事务分类和MySQL中的commit work and chain - 掘金 (juejin.cn)</a>）</strong></p>
<p>你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(timediff(now(),trx_started))<span class="operator">&gt;</span><span class="number">60</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>主要介绍了MySQL的事务隔离级别的现象和实现，根据实现原理分析了长事务存在的风险，以及如何用正确的方式避免长事务。希望我举的例子能够帮助你理解事务，并更好地使用MySQL的事务特性。</p>
<p>现在知道了系统里面应该避免长事务，如果你是业务开发负责人同时也是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？</p>
<h3 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h3><p>在上期文章的最后，留下的问题是一天一备跟一周一备的对比。</p>
<p>好处是“最长恢复时间”更短。</p>
<p>在一天一备的模式里，最坏情况下需要应用一天的binlog。比如，你每天0点做一次全量备份，而要恢复出一个到昨天晚上23点的备份。</p>
<p>一周一备最坏情况就要应用一周的binlog了。</p>
<p><strong>系统的对应指标就是RTO（恢复目标时间）。</strong></p>
<p>当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个RTO是成本换来的，就需要你根据业务重要性来评估了。</p>
<p>参考文章：<a href="https://jums.gitbook.io/mysql-shi-zhan-45-jiang/03-shi-wu-ge-li-wei-shi-mo-ni-gai-le-wo-huan-kan-bu-jian">03 事务隔离：为什么你改了我还看不见？ | MySql实战45讲 (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出索引（上）</title>
    <url>/2024/09/09/MySQL04/</url>
    <content><![CDATA[<p>提到数据库索引，我想你并不陌生，在日常工作中会经常接触到。<strong>比如某一个SQL查询比较慢，分析完原因之后，你可能就会说“给某个字段加个索引吧”之类的解决方案</strong>。但到底什么是索引，索引又是如何工作的呢？今天就让我们一起来聊聊这个话题吧。</p>
<p>数据库索引的内容比较多，我分成了上下两篇文章。<strong>索引是数据库系统里面最重要的概念之一</strong>，所以希望你能够耐心看完。在后面的实战文章中，我也会经常引用这两篇文章中提到的知识点，加深你对数据库索引的理解。</p>
<p><strong>一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。</strong>一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。<strong>同样，对于数据库的表而言，索引其实就是它的“目录”。（这个索引还有一个兄弟，叫做倒排索引，是ES中的一个概念）</strong></p>
<h3 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h3><p>索引的出现是为了<strong>提高查询效率</strong>，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。<strong>可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。</strong></p>
<p>下面我主要从使用的角度，为你简单分析一下这三种模型的区别。</p>
<p><strong>哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。（这里是直接将HashMap的下标当作索引了）</strong></p>
<p>不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。<strong>处理这种情况的一种方法是，拉出一个链表。（当然在一定的情况下会升级为红黑树）</strong></p>
<p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p>
<p><img src="/2024/09/09/MySQL04/image-20240909233015979.png" alt="image-20240909233015979"></p>
<p>图中，User2和User4根据身份证号算出来的值都是N，但没关系，后面还跟了一个链表。假设，这时候你要查ID_card_n2对应的名字是什么，处理步骤就是：首先，将ID_card_n2通过哈希函数算出N；然后，按顺序遍历，找到User2。</p>
<p>需要注意的是，图中四个ID_card_n的值<strong>并不是递增的</strong>，这样做的好处是<strong>增加新的User时速度会很快</strong>，只需要往后追加。但缺点是，因为不是有序的，所以<strong>哈希索引做区间查询的速度是很慢的</strong>。</p>
<p>你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。</p>
<p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>，比如<strong>Memcached及其他一些NoSQL引擎</strong>。</p>
<p>而<strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p>
<p><img src="/2024/09/09/MySQL04/image-20240909233223301.png" alt="image-20240909233223301"></p>
<p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查ID_card_n2对应的名字，<strong>用二分法就可以快速得到，这个时间复杂度是O(log(N))。</strong></p>
<p>同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的User，可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一个User），然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。</p>
<p><strong>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</strong></p>
<p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是2017年某个城市的所有人口信息，这类<strong>不会再修改的数据</strong>。</p>
<p>二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：</p>
<p><img src="/2024/09/09/MySQL04/image-20240909233347671.png" alt="image-20240909233347671"></p>
<p><strong>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。</strong>这样如果你要查ID_card_n2的话，按照图中的搜索顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得到。这个时间复杂度是O(log(N))。</p>
<p><strong>当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。</strong></p>
<p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。<strong>二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</strong></p>
<p>你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。<strong>在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。</strong></p>
<p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，<strong>而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小</strong>。</p>
<p><strong>以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</strong></p>
<p><strong>N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</strong></p>
<p><strong>不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案</strong>。数据库技术发展到今天，跳表、LSM树等数据结构也被用于引擎设计中，这里我就不再一一展开了。</p>
<p>这里补充一下关于红黑树，跳表，LSM树的资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/henuliulei/p/15114440.html">b树，b+树，b-树,红黑树详解一锅端 - 你的雷哥 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://blog.csdn.net/cy973071263/article/details/122543826">【数据结构】史上最好理解的红黑树讲解，让你彻底搞懂红黑树-CSDN博客</a></li>
<li><a href="https://cloud.tencent.com/developer/article/2392723">【全网最易懂的红黑树讲解】一眼看懂二叉树、平衡树、红黑树，一文打尽-腾讯云开发者社区-腾讯云 (tencent.com)</a></li>
<li><a href="https://www.jianshu.com/p/9d8296562806">Skip List–跳表（全网最详细的跳表文章没有之一） - 简书 (jianshu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/415799237">深入浅出分析LSM树（日志结构合并树） - 知乎 (zhihu.com)</a></li>
</ul>
<p>你心里要有个概念，<strong>数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景（这个说的确实很在理啊，不要一直闷着用，还是要学会分析的）</strong>。</p>
<p>截止到这里，我用了半篇文章的篇幅和你介绍了不同的数据结构，以及它们的适用场景，你可能会觉得有些枯燥。但是，我建议你还是要多花一些时间来理解这部分内容，毕竟这是数据库处理数据的核心概念之一，在分析问题的时候会经常用到。<strong>当你理解了索引的模型后，就会发现在分析问题的时候会有一个更清晰的视角，体会到引擎设计的精妙之处。</strong></p>
<p>现在，我们一起进入相对偏实战的内容吧。</p>
<p><strong>在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。（还记得前面存储引擎层实现了undo log的存储吗？）</strong>而即使多个存储引擎支持<strong>同一种类型</strong>的索引，其底层的实现也可能不同。由于InnoDB存储引擎在MySQL数据库中使用最为广泛，所以下面我就以InnoDB为例，和你分析一下其中的索引模型。</p>
<h3 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h3><p>在InnoDB中，表都是根据<strong>主键顺序以索引的形式存放的</strong>，这种存储方式的表称为<strong>索引组织表</strong>。又因为前面我们提到的，InnoDB使用了<strong>B+树索引模型</strong>，所以数据都是存储在B+树中的。</p>
<p><strong>每一个索引在InnoDB里面对应一棵B+树。（想想everything先建立索引，然后再便于我们查找文件就知道了，又或者是ES的倒排索引，索引的目的就是加快查找速度）</strong></p>
<p>假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。</p>
<p>这个表的建表语句是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure>

<p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。</p>
<p><img src="/2024/09/09/MySQL04/image-20240910081032872.png" alt="image-20240910081032872"></p>
<p>从图中不难看出，根据<strong>叶子节点</strong>的内容，索引类型分为主键索引和非主键索引。</p>
<ul>
<li><strong>主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。</strong></li>
<li><strong>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</strong></li>
</ul>
<p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p>
<ul>
<li>如果语句是select * from T where ID&#x3D;500，即主键查询方式，则<strong>只需要</strong>搜索ID这棵B+树；</li>
<li>如果语句是select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，<strong>得到ID的值为500</strong>，<strong>再到</strong>ID索引树搜索一次。这个过程称为<strong>回表</strong>。</li>
</ul>
<p>也就是说，<strong>基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</strong></p>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+树为了<strong>维护索引有序性，在插入新值的时候需要做必要的维护</strong>。以上面这个图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p>
<p>而更糟的情况是，<strong>如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂</strong>。在这种情况下，性能自然会受影响。</p>
<p>建议先看看这几篇博客</p>
<ul>
<li><p><a href="https://blog.csdn.net/mingyuli/article/details/120349671">Mysql基础(八)：表空间、段、区、页的关系_mysql 段 区 页-CSDN博客</a></p>
<p>总结</p>
<p><strong>表空间</strong>表示一本<strong>书</strong>，<strong>段</strong>表示书中的<strong>章节</strong>，<strong>区</strong>表示每章节的<strong>小节</strong>，<strong>页</strong>表示书的<strong>每一页</strong>，<strong>行</strong>就是每页的<strong>每行数据</strong>。<strong>表空间里有多个段，一个段包含256个区，一个区包含64个页，一个页为16K。</strong></p>
<p>这个总结还可以</p>
<p><img src="/2024/09/09/MySQL04/image-20240910083029325.png" alt="image-20240910083029325"></p>
</li>
<li><p><a href="https://www.cnblogs.com/ZhuChangwu/p/14041410.html">一看就懂的：MySQL数据页以及页分裂机制 - 赐我白日梦 - 博客园 (cnblogs.com)</a></p>
<p>数据页长这样，可以对比上面的图看一下</p>
<p><img src="/2024/09/09/MySQL04/image-20240910083201460.png" alt="image-20240910083201460"></p>
</li>
<li><p><a href="https://blog.csdn.net/LO_YUN/article/details/112061699">图解MySQL页分裂_mysql页分列-CSDN博客</a></p>
<p><img src="/2024/09/09/MySQL04/image-20240910083342055.png" alt="image-20240910083342055"></p>
<p>上面就是数据页的结构了，<strong>首先两个数据页之间会有指针指向上一个和下一个数据页</strong>，形成一个<strong>双向链表</strong>，在数据页中存储的就是一行行的数据了，<strong>每个数据行之间会有单向指针连接，组成一个单向链表</strong></p>
<p>我们还可以看到图中有一些数字，这些代表的是这行数据行的类型，<strong>第一行的行类型是2，就说明这一行是起始行，代表最小的一行</strong>，指针指向了下一行的数据；<strong>接下来的数据行的行类型是0，也就是普通的数据行</strong>，里面存储了各种字段；<strong>最后一行的行类型是3，代表了最大的一行</strong></p>
<p>当一个数据页中的数据行太多放不下的下，<strong>就会生成一个新的数据页来存储，同时使用双向链表来相连</strong></p>
<p>结论就是<strong>主键值最好是有序的，这样就可以不用页分裂，还能充分使用到索引，否则就必须进行页分裂来保证索引的使用</strong></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1656122">Innodb页合并和页分裂-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p>记住InnoDB<strong>不能以单行基础上工作</strong>是非常重要的。InnoDB<strong>总是在页上操作</strong>。一旦页被加载，它就会扫描页以寻找所请求的行&#x2F;记录。</p>
<p><strong>删除之后页合并（50%），插入新数据页分裂（不能乱序插入）。</strong></p>
<p>还记得我们说过的链表吗？此时第10页之前的页为第9页，之后的页为第11页。</p>
<p>第11页保持原样。<strong>改变的是页之间的关系</strong>：</p>
<ul>
<li>第10页之前的页为第9页，之后的页为第12页</li>
<li>第12页之前的页为第10页，之后的页是第11页</li>
<li>第11页之前的页为第12页，之后的页为第13页</li>
</ul>
<p>9 –&gt; 10 –&gt;12 –&gt; 11 –&gt;13</p>
<p>大概就是执行了这个操作</p>
<p>InnoDB做的是（简化版）：</p>
<ol>
<li>创建一个新页。</li>
<li><strong>确定原始页（第10页）可以在哪里拆分（在记录级别）</strong></li>
<li><strong>移动记录</strong></li>
<li><strong>重新定义页之间关系</strong></li>
</ol>
<p>这里讲的还可以，提取出来了：</p>
<p><strong>当心批量插入失败或者回滚时带来的MySQL表碎片</strong></p>
<p>通常，DBA都了解使用DELETE语句会产生表碎片。在大多数情况下，当执行大量的删除时，DBA总会重新构建表以回收磁盘空间。<strong>但是，您是否认为只有删除才会导致表碎片？（答案：并不是）</strong>。</p>
<p>在这篇博文中，我将解释插入如何会带来碎片。</p>
<p>在讨论这个主题之前，我们需要了解MySQL，有两种碎片：</p>
<ul>
<li><strong>在表中的InnoDB页完全空闲引起的碎片。</strong></li>
<li><strong>InnoDB页未填充满（页中还有一些空闲空间）引起的碎片。</strong></li>
</ul>
<p>主要有三种由插入引起的碎片场景：</p>
<ul>
<li><strong>插入之后回滚会产生碎片</strong></li>
<li><strong>插入语句失败会产生碎片</strong></li>
<li><strong>页分裂引起的碎片</strong></li>
</ul>
<p>这篇讲的比前几篇详细一点，建议仔细看看</p>
</li>
</ul>
<p><strong>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</strong></p>
<p><strong>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</strong></p>
<p>基于上面的索引维护过程说明，我们来讨论一个案例：</p>
<blockquote>
<p>你可能在一些建表规范里面见到过类似的描述，<strong>要求建表语句里一定要有自增主键</strong>。当然事无绝对，<strong>我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</strong></p>
</blockquote>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p>
<p>插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。</p>
<p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。<strong>每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</strong></p>
<p><strong>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</strong></p>
<p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p>
<p><strong>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。</strong></p>
<p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p>
<p>所以，从性能和存储空间方面考量，<strong>自增主键往往是更合理的选择</strong>。</p>
<p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<ol>
<li><strong>只有一个索引；</strong></li>
<li><strong>该索引必须是唯一索引。</strong></li>
</ol>
<p><strong>你一定看出来了，这就是典型的KV场景。（这下看懂了）</strong></p>
<p><strong>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</strong></p>
<p><strong>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天分析了数据库引擎可用的数据结构，介绍了<strong>InnoDB采用的B+树结构，以及为什么InnoDB要这么选择</strong>。B+树能够很好地<strong>配合磁盘的读写特性，减少单次查询的磁盘访问次数</strong>。</p>
<p>由于InnoDB是<strong>索引组织表，一般情况下我会建议你创建一个自增主键，这样非主键索引占用的空间最小</strong>。但事无绝对，我也跟你讨论了<strong>使用业务逻辑字段做主键的应用场景</strong>。</p>
<p>对于上面例子中的InnoDB表T，如果你要重建索引 k，你的两个SQL语句可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table T drop index k;</span><br><span class="line">alter table T add index(k);</span><br></pre></td></tr></table></figure>

<p>如果你要重建主键索引，也可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table T drop primary key;</span><br><span class="line">alter table T add primary key(id);</span><br></pre></td></tr></table></figure>

<p>我的问题是，对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好的方法是什么？</p>
<h3 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h3><p>如何避免长事务对业务的影响？</p>
<p>这个问题，我们可以从应用开发端和数据库端来看。</p>
<p><strong>首先，从应用开发端来看：</strong></p>
<ol>
<li>确认是否<strong>使用了set autocommit&#x3D;0</strong>。这个确认工作可以在测试环境中开展，把MySQL的general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。<strong>一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。</strong></li>
<li>确认<strong>是否有不必要的只读事务</strong>。<strong>有些框架会习惯不管什么语句先用begin&#x2F;commit框起来。我见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务可以去掉。</strong></li>
<li>业务连接数据库的时候，根据业务本身的预估<strong>，通过SET MAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间</strong>。（为什么会意外？在后续的文章中会提到这类案例）</li>
</ol>
<p><strong>其次，从数据库端来看：（这后面实战味道太浓了，没用过先跳过咯）</strong></p>
<ol>
<li>监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警&#x2F;或者kill；</li>
<li>Percona的pt-kill这个工具不错，推荐使用；</li>
<li>在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题；</li>
<li>如果使用的是MySQL 5.6或者更新版本，把innodb_undo_tablespaces设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li>
</ol>
<p>参考文章：<a href="https://jums.gitbook.io/mysql-shi-zhan-45-jiang/04-shen-ru-qian-chu-suo-yin-shang">04 深入浅出索引（上） | MySql实战45讲 (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出索引（下）</title>
    <url>/2024/09/10/MySQL05/</url>
    <content><![CDATA[<p>在开始这篇文章之前，我们先来看一下这个问题：</p>
<p>在下面这个表T中，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？</p>
<p>下面是这个表的初始化语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">index k(k))</span><br><span class="line">engine=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into T values(100,1, &#x27;aa&#x27;),(200,2,&#x27;bb&#x27;),(300,3,&#x27;cc&#x27;),(500,5,&#x27;ee&#x27;),(600,6,&#x27;ff&#x27;),(700,7,&#x27;gg&#x27;);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/10/MySQL05/image-20240910092741486.png" alt="image-20240910092741486"></p>
<p>现在，我们一起来看看这条SQL查询语句的执行流程：</p>
<ol>
<li>在k索引树上找到k&#x3D;3的记录，取得 ID &#x3D; 300；</li>
<li>再到ID索引树查到ID&#x3D;300对应的R3；</li>
<li>在k索引树取下一个值k&#x3D;5，取得ID&#x3D;500；</li>
<li>再回到ID索引树查到ID&#x3D;500对应的R4；</li>
<li>在k索引树取下一个值k&#x3D;6，不满足条件，循环结束。</li>
</ol>
<p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），<strong>回表了两次</strong>（步骤2和4）。</p>
<p>在这个例子中<strong>，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？</strong></p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果执行的语句是select <strong>ID</strong> from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，<strong>索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。（说白了就是后面的这个k索引包含了前面要映射的列）</strong></p>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>
<p>需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5（对应的索引k上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2。<strong>（这样看来扫描行数是MySQL的Server层获取到的实际的行数，和存储引擎读的行数一般是不同的）</strong></p>
<blockquote>
<p>备注：关于如何查看扫描行数的问题，我将会在第16文章《如何正确地显示随机消息？》中，和你详细讨论。</p>
</blockquote>
<p>基于上面覆盖索引的说明，我们来讨论一个问题：<strong>在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</strong></p>
<p>假设这个市民表的定义是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tuser` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `id_card` varchar(32) DEFAULT NULL,</span><br><span class="line">  `name` varchar(32) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `ismale` tinyint(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `id_card` (`id_card`),</span><br><span class="line">  KEY `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure>

<p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p>
<p><strong>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</strong></p>
<p><strong>当然，索引字段的维护总是有代价的。</strong>因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务DBA，或者称为业务数据架构师的工作。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>看到这里你一定有一个疑问，<strong>如果为每一种查询都设计一个索引，索引是不是太多了</strong>。如果我现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？<strong>反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？</strong></p>
<p>这里，我先和你说结论吧。<strong>B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong></p>
<p>为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。</p>
<p>关于联合索引可以看这几篇文章</p>
<ul>
<li><p><a href="https://blog.csdn.net/qq_35590091/article/details/107536144">【MySQL】联合索引的使用_select a,b from table where a order by b ab联合索引能不能-CSDN博客</a></p>
<p>什么是<a href="https://so.csdn.net/so/search?q=%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95&spm=1001.2101.3001.7020">联合索引</a>？</p>
<p>MySQL可以使用<strong>多个字段同时建立一个索引,叫做联合索引：如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX INDEX_NAME ON TABLE_NAME(a，b,c)</span><br></pre></td></tr></table></figure>

<p><strong>这个联合索引实际上效果等同于创建了索引a，索引（a，b）,索引（a,b,c）这三个索引。因此联合索引更节约空间。</strong></p>
<p>如果是创建完表之后添加索引，那么可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD INDEX index_name ( `a`, `b`, `c` )</span><br></pre></td></tr></table></figure>

<p>也可以在创建表的时候这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> T&#123;</span><br><span class="line">a <span class="type">INT</span>,</span><br><span class="line">b <span class="type">INT</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (a),</span><br><span class="line">KEY idx_a_b (a,b)</span><br><span class="line">&#125;ENGINE<span class="operator">=</span>INNODB</span><br></pre></td></tr></table></figure>

<p><strong>联合索引的本质</strong></p>
<p>联合索引本质上来说也是一个B+树，但是不同的是，以前的B+树的键值数量是1（即一个键值+一个页指针），但是联合索引的键值数量是大于等于2。如果根据上面创建表的语句，可以得到下图的B+树，也就是说，<strong>数据按照a，b的顺序来进行排序的，即先按照a排，再按照b排：</strong></p>
<p><img src="/2024/09/10/MySQL05/image-20240910095424112.png" alt="image-20240910095424112"></p>
<p>联合索引的作用</p>
<p>作用1、在如下这种查询中，我们可以提前创建一个联合索引，提高查询效率：</p>
<p><strong>select * FROM TABLE WHERE a&#x3D;</strong> and b&#x3D;<strong>,我们就可以使用（a，b）联合索引来进行查询。</strong></p>
<p>对于单个列a也可以使用，但是只对于b 的查询不可以，因为之前说的，我们是先对a排序，再对b排序，<strong>单独看b 的话，都是乱的，比如上面的1,2,1,4,1,2。这个其实就是我们经常说的“最左原则”。本质就是因为B+树里面的排序是先排a，再排b。</strong></p>
<p>作用2、第二个好处是，<strong>联合索引它内部已经对第二个键值进行了排序处理（就像上面说的，首先对a排序，然后对b排序）</strong>，很多情况下我们要查询某个用户的购物情况，然后按照时间排序，然后取出前3次的记录，<strong>这个时候使用联合索引就可以节约一次“排序操作”（filesort）</strong>，<strong>因为在叶子节点上都已经排好序了。</strong>创建了联合索引（a，b），就可以这样直接使用联合索引查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ,,FROM TABLE WHERE a=** ORDER BY b; </span><br></pre></td></tr></table></figure>

<p>最左原则</p>
<p>MySQL使用索引时需要索引有序,假设现在建立了”name,age,school”的联合索引,那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序。</p>
<p>当进行查询时,此时索引仅仅按照name严格有序,因此必须首先使用name字段进行等值查询,之后对于匹配到的列而言,其按照age字段严格有序,此时可以使用age字段用做索引查找,,,以此类推.因此在建立联合索引的时候应该注意索引列的顺序,**一般情况下,将查询需求频繁或者字段选择性高的列放在前面.**此外可以根据特例的查询或者表结构进行单独的调整。</p>
<p>此外，MySQL会<strong>一直向右匹配直到遇到范围查询</strong>。如有索引 (a,b,c,d)，查询条件 a&#x3D;1 and b&#x3D;2 and c&gt;3 and d&#x3D;4，<strong>则会在每个节点依次命中a、b、c，无法命中d。</strong></p>
</li>
<li><p><a href="https://www.cnblogs.com/wongdw/p/12887174.html">mysql的联合索引（复合索引） - wongdw - 博客园 (cnblogs.com)</a></p>
<p>当创建(<code>col1</code>,<code>col2</code>,<code>col3</code>)联合索引时，相当于创建了**(<code>col</code>)单列索引<strong>，</strong>(<code>clo1</code>,<code>clo2</code>)联合索引<strong>以及</strong>(<code>col1</code>,<code>col2</code>,<code>col3</code>)联合索引<strong>想要索引生效，只能使用</strong><code>col1</code><strong>和</strong><code>col1</code>,<code>col2</code><strong>和</strong><code>col1</code>,<code>col2</code>,<code>col3</code><strong>三种组合；当然，</strong><code>col1</code>,<code>col3</code>组合也可以，但实际上只用到了<code>col1</code>的索引，<code>col3</code>并没有用到！**</p>
<p><img src="/2024/09/10/MySQL05/image-20240910095021156.png" alt="image-20240910095021156"></p>
<p><strong>联合索引相当于一个按照<code>姓氏——名字</code>的一个电话簿，只能先确定姓氏才可以命中索引</strong>，下列可以正确命中联合索引的语句（ <code>= </code> 和<code>IN</code>直接的字段都可以乱序，MySQL的查询优化器可以优化成索引识别的形式）</p>
<p><img src="/2024/09/10/MySQL05/image-20240910094824818.png" alt="image-20240910094824818"></p>
</li>
</ul>
<p><img src="/2024/09/10/MySQL05/image-20240910093958284.png" alt="image-20240910093958284"></p>
<p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p>
<p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p>
<p><strong>如果你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是”where name like ‘张%’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。</strong></p>
<p>可以看到，不只是索引的全部定义，<strong>只要满足最左前缀，就可以利用索引来加速检索</strong>。这个最左前缀可以是联合索引的<strong>最左N个字段，也可以是字符串索引的最左M个字符</strong>。</p>
<p>基于上面对最左前缀索引的说明，我们来讨论一个问题：<strong>在建立联合索引的时候，如何安排索引内的字段顺序。</strong></p>
<p>这里我们的评估标准是，<strong>索引的复用能力</strong>。因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p>
<p>所以现在你知道了，这段开头的问题里，<strong>我们要为高频请求创建(身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。</strong></p>
<p>那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，<strong>也就是说你需要同时维护(a,b)、(b) 这两个索引。</strong></p>
<p>这时候，我们要<strong>考虑的原则就是空间</strong>了。比如上面这个市民表的情况，<strong>name字段是比age字段大的 ，那我就建议你创建一个（name,age)的联合索引和一个(age)的单字段索引。</strong></p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些<strong>不符合</strong>最左前缀的部分，会怎么样呢？</p>
<p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure>

<p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。当然，这还不错，总比全表扫描要好。</p>
<p>然后呢？</p>
<p>当然是判断其他条件是否满足。</p>
<p><strong>在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。</strong></p>
<p><strong>而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</strong></p>
<p>图3和图4，是这两个过程的执行流程图。</p>
<p><img src="/2024/09/10/MySQL05/image-20240910100843207.png" alt="image-20240910100843207"></p>
<p>图3 无索引下推执行流程</p>
<p><img src="/2024/09/10/MySQL05/image-20240910100850704.png" alt="image-20240910100850704"></p>
<p>图4 索引下推执行流程</p>
<p>在图3和4这两个图里面，<strong>每一个虚线箭头表示回表一次。</strong></p>
<p>图3中，在(name,age)索引里面我特意去掉了age的值，这个过程InnoDB并不会去看age的值，<strong>只是按顺序把“name第一个字是’张’”的记录一条条取出来回表</strong>。因此，需要回表4次。</p>
<p>图4跟图3的区别是，InnoDB<strong>在(name,age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过</strong>。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天这篇文章继续讨论了数据库索引的概念，<strong>包括了覆盖索引、前缀索引、索引下推</strong>。你可以看到，在满足语句需求的情况下， <strong>尽量少地访问资源是数据库设计的重要原则之一。</strong>我们在使用数据库的时候，尤其是在设计表结构时，也要以减少资源消耗作为目标。</p>
<p>实际上主键索引也是可以使用多个字段的。DBA小吕在入职新公司的时候，就发现自己接手维护的库里面，有这么一个表，表结构定义类似这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `geek` (</span><br><span class="line">  `a` int(11) NOT NULL,</span><br><span class="line">  `b` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) NOT NULL,</span><br><span class="line">  `d` int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`a`,`b`),</span><br><span class="line">  KEY `c` (`c`),</span><br><span class="line">  KEY `ca` (`c`,`a`),</span><br><span class="line">  KEY `cb` (`c`,`b`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p>公司的同事告诉他说，由于历史原因，这个表需要a、b做联合主键，这个小吕理解了。</p>
<p>但是，学过本章内容的小吕又纳闷了，既然主键包含了a、b这两个字段，那意味着单独在字段c上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？</p>
<p>同事告诉他，是因为他们的业务里面有这样的两种语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from geek where c=N order by a limit 1;</span><br><span class="line">select * from geek where c=N order by b limit 1;</span><br></pre></td></tr></table></figure>

<p>我给你的问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？</p>
<p><strong>想了一下，应该是对的，这个问题的答案在上面提到过。就是减少了一次sort，提高了效率。</strong></p>
<h3 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h3><p>上期的问题是，通过两个alter 语句重建索引k，以及通过两个alter语句重建主键索引是否合理。</p>
<p>有同学问到为什么要重建索引。<strong>我们文章里面有提到，索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。（我记得之前看到别人的面经的时候就提到过空洞这个玩意，原来是在这里出现的）</strong></p>
<p>这道题目，我给你的“参考答案”是：</p>
<p><strong>重建索引k的做法是合理的，可以达到省空间的目的。</strong>但是，<strong>重建主键的过程不合理</strong>。不论是删除主键还是创建主键，<strong>都会将整个表重建</strong>。所以连着执行这两个语句的话，第一个语句就<strong>白做了</strong>。<strong>这两个语句，你可以用这个语句代替 ： alter table T engine&#x3D;InnoDB。</strong>在专栏的第12篇文章《为什么表数据删掉一半，表文件大小不变？》中，我会和你分析这条语句的执行流程。</p>
<p>参考文章：<a href="https://jums.gitbook.io/mysql-shi-zhan-45-jiang/05-shen-ru-qian-chu-suo-yin-xia">05 深入浅出索引（下） | MySql实战45讲 (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</title>
    <url>/2024/09/10/MySQL06/</url>
    <content><![CDATA[<p> 今天我要跟你聊聊MySQL的锁。<strong>数据库锁设计的初衷是处理并发问题。</strong>作为多用户共享的资源，当出现并发访问的时候，<strong>数据库需要合理地控制资源的访问规则</strong>。而锁就是用来实现这些访问规则的重要数据结构。</p>
<p><strong>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类</strong>。今天这篇文章，我会和你分享全局锁和表级锁。而关于行锁的内容，我会留着在下一篇文章中再和你详细介绍。</p>
<p>这里需要说明的是，锁的设计比较复杂，这两篇文章不会涉及锁的具体实现细节，主要介绍的是碰到锁时的现象和其背后的原理。</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>顾名思义，全局锁就是对<strong>整个数据库实例加锁</strong>。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。<strong>当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</strong></p>
<p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong>也就是把整库每个表都select出来存成文本。</p>
<p>以前有一种做法，是通过FTWRL确保不会有其他线程对数据库做更新，然后对整个库做备份。<strong>注意，在备份过程中整个库完全处于只读状态。</strong></p>
<p><strong>但是让整库都只读，听上去就很危险：</strong></p>
<ul>
<li>如果你在主库上备份，<strong>那么在备份期间都不能执行更新，业务基本上就得停摆；</strong></li>
<li>如果你在从库上备份，<strong>那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</strong></li>
</ul>
<p>看来加全局锁不太好。但是细想一下，备份为什么要加锁呢？我们来看一下不加锁会有什么问题。</p>
<p>假设你现在要维护“极客时间”的购买系统，关注的是用户账户余额表和用户课程表。</p>
<p><strong>现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课。</strong></p>
<p>如果时间顺序上是先备份账户余额表(u_account)，然后用户购买，然后备份用户课程表(u_course)，会怎么样呢？你可以看一下这个图：</p>
<p><img src="/2024/09/10/MySQL06/image-20240910114231615.png" alt="image-20240910114231615"></p>
<p><strong>可以看到，这个备份结果里，用户A的数据状态是“账户余额没扣，但是用户课程表里面已经多了一门课”。如果后面用这个备份来恢复数据的话，用户A就发现，自己赚了。</strong></p>
<p>作为用户可别觉得这样可真好啊，你可以试想一下：如果备份表的顺序反过来，先备份用户课程表再备份账户余额表，又可能会出现什么结果？</p>
<p><strong>也就是说，不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。（所以在全库逻辑备份的时候要STW，得到那一个时间点的快照数据）</strong></p>
<p>说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到一致性视图的（还记得是通过undo log实现的），对吧？</p>
<p><strong>是的，就是在可重复读隔离级别下开启一个事务。</strong></p>
<blockquote>
<p>备注：如果你对事务隔离级别的概念不是很清晰的话，可以再回顾一下第3篇文章<a href="https://time.geekbang.org/column/article/68963">《事务隔离：为什么你改了我还看不见？》</a>中的相关内容。</p>
</blockquote>
<p><strong>官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。</strong>而由于MVCC的支持，这个过程中数据是可以正常更新的。</p>
<p>你一定在疑惑，有了这个功能，为什么还需要FTWRL呢？<strong>一致性读是好，但前提是引擎要支持这个隔离级别。</strong>比如，对于<strong>MyISAM这种不支持事务的引擎（事务这一层面的东西是在存储引擎中实现的）</strong>，如果备份过程中有更新，<strong>总是只能取到最新的数据，那么就破坏了备份的一致性。</strong>这时，我们就需要使用FTWRL命令了。</p>
<p>所以，<strong>single-transaction方法只适用于所有的表使用事务引擎的库。</strong>如果有的表使用了<strong>不支持事务</strong>的引擎，那么备份就<strong>只能通过FTWRL方法</strong>。这往往是<strong>DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一</strong>。</p>
<p>你也许会问，<strong>既然要全库只读，为什么不使用set global readonly&#x3D;true的方式呢</strong>？确实readonly方式也可以让全库进入只读状态，<strong>但我还是会建议你用FTWRL方式</strong>，主要有两个原因：</p>
<ul>
<li><strong>一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。</strong>因此，修改global变量的方式<strong>影响面更大</strong>，我不建议你使用。</li>
<li><strong>二是，在异常处理机制上有差异。</strong>如果执行FTWRL命令之后由于<strong>客户端发生异常断开</strong>，那么MySQL会<strong>自动释放这个全局锁</strong>，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，<strong>如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</strong></li>
</ul>
<p><strong>业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</strong></p>
<p>但是，<strong>即使没有被全局锁住</strong>，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍的表级锁。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p>
<p><strong>表锁的语法是 lock tables … read&#x2F;write。</strong>与FTWRL类似，可以用<strong>unlock tables主动释放锁</strong>，也可以在客户端断开的时候<strong>自动释放</strong>。需要注意，lock tables语法除了会限制别的线程的读写外，<strong>也限定了本线程接下来的操作对象</strong>。</p>
<p>举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。<strong>同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。（简单的说，你对于你自己锁住的资源要负责，不能在锁还没有释放的时候就访问其他的资源）</strong></p>
<p>在还没有出现更细粒度的锁的时候，<strong>表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。</strong></p>
<p><strong>另一类表级的锁是MDL（metadata lock)。</strong>MDL<strong>不需要显式使用</strong>，在访问一个表的时候会<strong>被自动加上</strong>。MDL的作用是，<strong>保证读写的正确性</strong>。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
<p>因此，在MySQL 5.5版本中引入了MDL，<strong>当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</strong></p>
<p>关于读锁和写锁，这里有比较详细的介绍</p>
<p><a href="https://blog.csdn.net/qq_44766883/article/details/105879308">mysql的锁机制(读锁，写锁，表锁，行锁，悲观锁，乐观锁，间隙锁)_mysql 读锁 写锁 兼容性-CSDN博客</a></p>
<ul>
<li>读锁之间不互斥，<strong>这意味着多个线程可以同时对同一张表进行读取操作，而不会相互阻塞。（对同一个数据，多个读操作可以同时进行，互不干扰。加锁的会话只能对此表进行读操作,其他会话也只能进行读操作。）</strong></li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。<strong>因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。（如果当前写操作没有完毕，则无法进行其他的读操作、写操作。当前会话只能对此表进行读,写操作,其他会话无法进行任何操作。）</strong></li>
</ul>
<p>虽然<strong>MDL锁是系统默认会加的，但却是你不能忽略的一个机制</strong>。比如下面这个例子，我经常看到有人掉到这个坑里：<strong>给一个小表加个字段，导致整个库挂了。</strong></p>
<p>你肯定知道，<strong>给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据</strong>。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。我们来看一下下面的操作序列，假设表t是一个小表。</p>
<blockquote>
<p>备注：这里的实验环境是MySQL 5.6。</p>
</blockquote>
<p><img src="/2024/09/10/MySQL06/image-20240910115825808.png" alt="image-20240910115825808"></p>
<p>我们可以看到session A先启动，<strong>这时候会对表t加一个MDL读锁</strong>。<strong>由于session B需要的也是MDL读锁，因此可以正常执行。</strong></p>
<p>之后session C会被blocked，是因为session A的MDL读锁还没有释放，<strong>而session C需要MDL写锁，因此只能被阻塞</strong>。</p>
<p>如果只有session C自己被阻塞还没什么关系，但是之后所有<strong>要在表t上新申请MDL读锁的请求也会被session C阻塞。前面我们说了，所有对表的增删改操作都需要先申请MDL写锁，如果session C自己阻塞了，就会导致后面的session都被锁住，等于这个表现在完全不可读写了。</strong></p>
<p>如果某个表上的<strong>查询语句频繁</strong>，而且客户端有重试机制，<strong>也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。</strong></p>
<p>你现在应该知道了，事务中的MDL锁，<strong>在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</strong></p>
<p>基于上面的分析，我们来讨论一个问题，<strong>如何安全地给小表加字段？</strong></p>
<p><strong>首先我们要解决长事务，事务不提交，就会一直占着MDL锁。</strong>在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。<strong>如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。</strong></p>
<p>但考虑一下这个场景。<strong>如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</strong></p>
<p>这时候kill可能未必管用，<strong>因为新的请求马上就来了</strong>。比较理想的机制是，在alter table语句里面设定等待时间，<strong>如果在这个指定的等待时间里面能够拿到MDL写锁最好</strong>，拿不到也不要阻塞后面的业务语句，<strong>先放弃。之后开发人员或者DBA再通过重试命令重复这个过程</strong>。</p>
<p>MariaDB已经合并了<a href="https://github.com/alibaba/AliSQL">AliSQL</a>的这个功能，所以这两个开源分支目前都支持DDL NOWAIT&#x2F;WAIT n这个语法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name NOWAIT add column ...</span><br><span class="line">ALTER TABLE tbl_name WAIT N add column ... </span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天介绍了MySQL的全局锁和表级锁。</p>
<p><strong>全局锁主要用在逻辑备份过程中。对于全部是InnoDB引擎的库，我建议你选择使用–single-transaction参数，对应用会更友好。</strong></p>
<p><strong>表锁一般是在数据库引擎不支持行锁的时候才会被用到的。</strong>如果你发现你的应用程序里有lock tables这样的语句，你需要追查一下，比较可能的情况是：</p>
<ul>
<li><strong>要么是你的系统现在还在用MyISAM这类不支持事务的引擎，那要安排升级换引擎；</strong></li>
<li>要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，<strong>最后业务开发就是把lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。</strong></li>
</ul>
<p><strong>MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心，不要锁住整张表导致线上查询和更新出现阻塞。</strong></p>
<p>备份一般都会在备库上执行，你在用–single-transaction方法做逻辑备份的过程中，如果主库上的一个小表做了一个DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？</p>
<p>说明：这篇文章没有介绍到物理备份，<strong>物理备份会有一篇单独的文章</strong>。</p>
<h3 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h3><p>上期的问题是关于对联合主键索引和InnoDB索引组织表的理解。</p>
<p><img src="/2024/09/10/MySQL06/image-20240910123652692.png" alt="image-20240910123652692"></p>
<p>主键 a，b的聚簇索引组织顺序相当于 order by a,b ，也就是先按a排序，再按b排序，c无序。</p>
<p>索引 ca 的组织是先按c排序，再按a排序，同时记录主键 </p>
<p><img src="/2024/09/10/MySQL06/image-20240910123710753.png" alt="image-20240910123710753"></p>
<p>这个跟索引c的数据是一模一样的。</p>
<p>索引 cb 的组织是先按c排序，在按b排序，同时记录主键 </p>
<p><img src="/2024/09/10/MySQL06/image-20240910123725156.png" alt="image-20240910123725156"></p>
<p><strong>所以，结论是ca可以去掉，cb需要保留。确实有道理，因为现在已经有了a索引，（a，b）索引，c索引，（c，a）索引，（c，b）索引了，（c，a）索引 &#x3D;&#x3D; c索引加上a索引，所以多余的这个ca可以去掉。</strong></p>
<p>MRR优化—这篇文章讲的还可以，建议看一下</p>
<p><a href="https://zhuanlan.zhihu.com/p/110154066">MySQL 的 MRR 到底是什么？ - 知乎 (zhihu.com)</a></p>
<p>把这篇文章的尾声搬了一下：</p>
<ul>
<li>MRR 跟索引有很大的关系。</li>
<li><strong>索引是 MySQL 对查询做的一个优化，把原本杂乱无章的数据，用有序的结构组织起来，让全表扫描变成有章可循的查询。</strong></li>
<li><strong>而我们讲的 MRR，则是 MySQL 对基于索引的查询做的一个的优化，可以说是对优化的优化了。</strong></li>
<li>要优化 MySQL 的查询，就得先知道 MySQL 的查询过程；而要优化索引的查询，则要知道 MySQL 索引的原理。</li>
</ul>
<p>文中的两个图画的很好</p>
<p><img src="/2024/09/10/MySQL06/image-20240910130042818.png" alt="image-20240910130042818"></p>
<p><img src="/2024/09/10/MySQL06/image-20240910130053955.png" alt="image-20240910130053955"></p>
<p>总结：</p>
<ul>
<li>MRR，全称「Multi-Range Read Optimization」。</li>
<li>简单说：<strong>MRR 通过把「随机磁盘读」，转化为「<a href="https://zhida.zhihu.com/search?q=%E9%A1%BA%E5%BA%8F%E7%A3%81%E7%9B%98&zhida_source=entity&is_preview=1">顺序磁盘</a>读」，从而提高了索引查询的性能。</strong></li>
</ul>
<p>参考文章：<a href="https://jums.gitbook.io/mysql-shi-zhan-45-jiang/06-quan-ju-suo-he-biao-suo-gei-biao-jia-ge-zi-duan-zen-mo-you-zhe-mo-duo-zu-ai">06 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？ | MySql实战45讲 (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>行锁功过：怎么减少行锁对性能的影响？</title>
    <url>/2024/09/10/MySQL07/</url>
    <content><![CDATA[<p>在上一篇文章中，<strong>介绍了MySQL的全局锁和表级锁，今天我们就来讲讲MySQL的行锁。</strong></p>
<p><strong>MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。</strong>不支持行锁<strong>意味着并发控制只能使用表锁</strong>，对于这种引擎的表，<strong>同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。</strong></p>
<p>我们今天就主要来聊聊InnoDB的行锁，以及如何通过减少锁冲突来提升业务并发度。</p>
<p>顾名思义，<strong>行锁就是针对数据表中行记录的锁。这很好理解，比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。</strong></p>
<p>当然，数据库中<strong>还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导致程序出现非预期行为，比如两阶段锁。</strong></p>
<h3 id="从两阶段锁说起"><a href="#从两阶段锁说起" class="headerlink" title="从两阶段锁说起"></a>从两阶段锁说起</h3><p>我先给你举个例子。在下面的操作序列中，事务B的update语句执行时会是什么现象呢？假设字段id是表t的主键。</p>
<p><img src="/2024/09/10/MySQL07/image-20240910130922763.png" alt="image-20240910130922763"></p>
<p>这个问题的结论取决于事务A在执行完两条update语句后，持有哪些锁，以及在什么时候释放。<strong>你可以验证一下：实际上事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行。（这个我在最初学习MySQL的时候就试验过了）</strong></p>
<p>知道了这个答案，你一定知道了事务A持有的两个记录的行锁，<strong>都是在commit的时候才释放的</strong>。</p>
<p>也就是说，<strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，<strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong>我给你举个例子。</p>
<p>假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p>
<ol>
<li>从顾客A账户余额中扣除电影票价；</li>
<li>给影院B的账户余额增加这张电影票价；</li>
<li>记录一条交易日志。</li>
</ol>
<p><strong>也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。（我们在Spring程序中直接一个@Transactional注解就行了）</strong>那么，你会怎样安排这三个语句在事务中的顺序呢？</p>
<p>试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p>
<p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。<strong>所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。</strong></p>
<p><strong>好了，现在由于你的正确设计，影院余额这一行的行锁在一个事务中不会停留很长时间。</strong>但是，这并没有完全解决你的困扰。</p>
<p>如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的MySQL就挂了。<strong>你登上服务器一看，CPU消耗接近100%，但整个数据库每秒就执行不到100个事务。</strong>这是什么原因呢？</p>
<p>这里，我就要说到<strong>死锁和死锁检测了</strong>。</p>
<h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><p><strong>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</strong>这里我用数据库中的行锁举个例子。</p>
<p><img src="/2024/09/10/MySQL07/image-20240910131442146.png" alt="image-20240910131442146"></p>
<p><strong>这时候，事务A在等待事务B释放id&#x3D;2的行锁，而事务B在等待事务A释放id&#x3D;1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。</strong>当出现死锁以后，有两种策略：</p>
<ul>
<li><strong>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</strong></li>
<li>另一种策略是，<strong>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</strong></li>
</ul>
<p>在InnoDB中，innodb_lock_wait_timeout的<strong>默认值是50s</strong>，意味着如果采用第一个策略，当出现死锁以后，<strong>第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</strong></p>
<p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>所以，<strong>正常情况下我们还是要采用第二种策略</strong>，即：<strong>主动死锁检测，而且innodb_deadlock_detect的默认值本身就是on</strong>。主动死锁检测在发生死锁的时候，<strong>是能够快速发现并进行处理的</strong>，但是它也是有额外负担的。</p>
<p>你可以想象一下这个过程：<strong>每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁</strong>。</p>
<p>那如果是我们上面说到的所有事务都要更新同一行的场景呢？</p>
<p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，<strong>这是一个时间复杂度是O(n^2)的操作（1 + 2 + 3 + …… + n）</strong>。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。<strong>虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务。</strong></p>
<p>根据上面的分析，我们来讨论一下，怎么解决由这种<strong>热点行更新</strong>导致的性能问题呢？<strong>问题的症结在于，死锁检测要耗费大量的CPU资源。</strong></p>
<p><strong>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</strong>但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。<strong>而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</strong></p>
<p><strong>另一个思路是控制并发度。</strong>根据上面的分析，你会发现如果并发能够控制住，<strong>比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低</strong>，就不会出现这个问题。一个直接的想法就是，<strong>在客户端做并发控制</strong>。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有600个客户端，<strong>这样即使每个客户端控制到只有5个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到3000。</strong></p>
<p>因此，<strong>这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改MySQL源码的人，也可以做在MySQL里面</strong>。基本思路就是，<strong>对于相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。</strong></p>
<p>可能你会问，<strong>如果团队里暂时没有数据库方面的专家，不能实现这样的方案，能不能从设计上优化这个问题呢？</strong></p>
<p><strong>你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。</strong>还是以影院账户为例，可以考虑放在多条记录上，<strong>比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1&#x2F;10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。（原来有时候这样设计不是屎山啊，这是为了避免并发死锁）</strong></p>
<p>这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做<strong>详细设计</strong>。<strong>如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成0的时候，代码要有特殊处理。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天介绍了<strong>MySQL的行锁，涉及了两阶段锁协议、死锁和死锁检测这两大部分内容。</strong></p>
<p>这里<strong>两阶段加锁（2PL(Two-phase locking)）协议</strong>可以看看这几篇文章：</p>
<ul>
<li><p>[关于MySQL 两阶段加锁（2PL(Two-phase locking)）协议 - _Origin - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/origin-zy/p/17395701.html#:~:text=%E5%9C%A8MySQL%E4%B8%AD%EF%BC%8C%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%EF%BC%9A%E5%BD%93%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%E8%8E%B7%E5%8F%96%E5%88%B0%E4%BA%86%E6%9F%90%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%81%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E9%9C%80%E8%A6%81%E6%93%8D%E4%BD%9C%E5%AE%83%E4%BA%86%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%AF%B4%E5%B0%B1%E4%BC%9A%E9%A9%AC%E4%B8%8A%E9%87%8A%E6%94%BE%E6%8E%89%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%94%81%E4%BC%9A%E4%B8%80%E7%9B%B4%E8%A2%AB%E8%BF%99%E4%B8%AA%E4%BA%8B%E5%8A%A1%E6%8C%81%E6%9C%89%EF%BC%8C%E7%9B%B4%E5%88%B0%E8%BF%99%E4%B8%AA%E4%BA%8B%E5%8A%A1%E8%A2%AB%E6%8F%90%E4%BA%A4%E6%88%96%E5%9B%9E%E6%BB%9A%E5%90%8E%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%94%81%E6%89%8D%E4%BC%9A%E8%A2%AB%E9%87%8A%E6%94%BE%E6%8E%89%E3%80%82">https://www.cnblogs.com/origin-zy/p/17395701.html#:~:text=在MySQL中，两阶段锁协议的含义是：当一个事务获取到了某一个数据库对象的锁之后，并不是当前事务不需要操作它了之后，这个说就会马上释放掉，这个锁会一直被这个事务持有，直到这个事务被提交或回滚后，这个锁才会被释放掉。</a> 所以，在当前事务还没有结束的时候，任何其他事务尝试获取这个锁的时候，都会被阻塞。,知道当前事务提交或回滚后，前提事务才可以获取到这把锁。 这就是MySQL中2PL两阶段锁协议的含义。 它在事务并发的时候，为数据的一致性提供有力的保障。)</p>
<p>两阶段锁协议的含义是：<strong>当一个事务获取到了某一个数据库对象的锁之后，并不是当前事务不需要操作它了之后，这个说就会马上释放掉，这个锁会一直被这个事务持有，直到这个事务被提交或回滚后，这个锁才会被释放掉。</strong>所以，在当前事务还没有结束的时候，任何其他事务尝试获取这个锁的时候，都会被阻塞。知道当前事务提交或回滚后，前提事务才可以获取到这把锁。</p>
</li>
<li><p><a href="https://blog.csdn.net/xmtblog/article/details/104980789">8 张图，给你完整的剖析 MySQL 两阶段加锁（2PL）协议-CSDN博客</a></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两阶段加锁（2PL，Two-Phase Locking）协议是数据库管理系统中用于实现事务隔离的一种协议。它分为两个阶段：</span><br><span class="line"></span><br><span class="line">1. 扩展阶段（Growing Phase）</span><br><span class="line">在这个阶段，事务可以申请锁（包括读锁和写锁），并且可以不断地增加所持有的锁。</span><br><span class="line">事务在扩展阶段内，可以获得新的锁，但不能释放任何已持有的锁。</span><br><span class="line">这个阶段持续到事务第一次释放锁为止。</span><br><span class="line">2. 收缩阶段（Shrinking Phase）</span><br><span class="line">一旦事务释放了第一个锁，就进入收缩阶段。</span><br><span class="line">在这个阶段，事务不能再申请新的锁，只能释放已持有的锁。</span><br><span class="line">事务可以在此阶段释放任何锁，但不能再获取新的锁。</span><br><span class="line"></span><br><span class="line">扩展阶段允许事务收集必要的锁，而收缩阶段则确保锁的释放顺序，从而避免死锁和其他并发问题。两阶段加锁协议是确保数据库事务满足串行化的关键机制之一。</span><br></pre></td></tr></table></figure>

<p>其中，<strong>我以两阶段协议为起点，和你一起讨论了在开发的时候如何安排正确的事务语句</strong>。这里的原则&#x2F;我给你的建议是：<strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放。</strong></p>
<p>但是，调整语句顺序<strong>并不能完全避免死锁</strong>。所以我们引入了死锁和死锁检测的概念，以及提供了<strong>三个方案</strong>，来减少死锁对数据库的影响。<strong>减少死锁的主要方向，就是控制访问相同资源的并发事务量。</strong></p>
<p>如果你要删除一个表里面的前10000行数据，有以下三种方法可以做到：</p>
<ul>
<li>第一种，直接执行delete from T limit 10000;</li>
<li>第二种，在一个连接中循环执行20次 delete from T limit 500;</li>
<li>第三种，在20个连接中同时执行delete from T limit 500。</li>
</ul>
<p>你会选择哪一种方法呢？为什么呢？</p>
<h3 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h3><p>上期我给你留的问题是：当备库用–single-transaction做逻辑备份的时候，如果从主库的binlog传来一个DDL语句会怎么样？</p>
<p>假设这个DDL是针对表t1的， 这里我把备份过程中几个关键的语句列出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；</span><br><span class="line">/* other tables */</span><br><span class="line">Q3:SAVEPOINT sp;</span><br><span class="line">/* 时刻 1 */</span><br><span class="line">Q4:show create table `t1`;</span><br><span class="line">/* 时刻 2 */</span><br><span class="line">Q5:SELECT * FROM `t1`;</span><br><span class="line">/* 时刻 3 */</span><br><span class="line">Q6:ROLLBACK TO SAVEPOINT sp;</span><br><span class="line">/* 时刻 4 */</span><br><span class="line">/* other tables */</span><br></pre></td></tr></table></figure>

<p>在<strong>备份开始</strong>的时候，为了<strong>确保</strong>RR（可重复读）隔离级别，再设置一次RR隔离级别(Q1);</p>
<p><strong>启动事务</strong>，这里用 WITH CONSISTENT SNAPSHOT<strong>确保这个语句执行完就可以得到一个一致性视图（Q2)；</strong></p>
<p><strong>设置一个保存点</strong>，这个很重要（Q3）；</p>
<p>这里介绍一下<strong>保存点（SAVEPOINT）</strong>的概念:</p>
<ul>
<li><strong>保存点的定义</strong>: 保存点是事务中的一个标记，你可以在事务的某个时刻设置一个保存点，<strong>之后可以选择回滚到这个点，而不是回滚整个事务。</strong></li>
</ul>
<p>详细的可以看看这篇文章:</p>
<ul>
<li><p><a href="https://blog.csdn.net/hammring/article/details/106958696">事务之保存点（savepoint）-CSDN博客</a></p>
<p>下面将重点提取出来:</p>
<p>如果开启一个事务，已经写了很多语句，突然发现执行完上一语句时发现语句写错了。</p>
<p>你只好使用rollback语句让数据库恢复到事务开启之前的状态。以前写完的语句也需要重新执行。</p>
<p>所以mysql数据库的作者<strong>提出了保存点（savepoint）的概念</strong>。<strong>开启事务后在执行语句后面打几个点，我们调用rollback语句就会回滚到指定的点。而不是回到事务执行之前的样子。</strong></p>
</li>
</ul>
<p>这里还介绍一下show create table是什么意思,具体可以看看这篇文章:</p>
<ul>
<li><a href="https://deepinout.com/mysql/mysql-questions/201_tk_1706620105.html">mysql show create table命令的详解|极客笔记 (deepinout.com)</a></li>
</ul>
<p>show create 是为了<strong>拿到表结构</strong>(Q4)，然后正式导数据 （Q5），<strong>回滚到SAVEPOINT sp，在这里的作用是释放 t1的MDL锁 （Q6。当然这部分属于“超纲”，上文正文里面都没提到。）</strong></p>
<p>DDL从主库传过来的时间按照<strong>效果不同</strong>，我打了四个时刻。题目<strong>设定为小表</strong>，我们假定到达后，如果开始执行，则很快能够执行完成。</p>
<p>参考答案如下：</p>
<ol>
<li>如果在Q4语句(Q4:show create table <code>t1</code>;)执行<strong>之前</strong>（时刻 1前）到达，现象：<strong>没有影响，备份拿到的是DDL后的表结构</strong>。（在开始备份之前就同步好了，没有任何问题,这个时候binlog已经同步好了）</li>
<li>如果在“时刻 2”(Q5:SELECT * FROM <code>t1</code>;)到达，<strong>则表结构被改过</strong>，Q5执行的时候，报 <strong>Table definition has changed, please retry transaction</strong>，现象：mysqldump终止；（正式导数据的时候发现表结构定义被修改，中止备份操作）</li>
<li>如果在“时刻2”和“时刻3”(Q6:ROLLBACK TO SAVEPOINT sp;)之间到达，mysqldump占着t1的MDL读锁，<strong>binlog被阻塞</strong>，<strong>现象：主从延迟，直到Q6执行完成。</strong>（导出数据完成,但是还没有提交,此时binlog会被阻塞）</li>
<li>从“时刻4”(&#x2F;* other tables *&#x2F;)开始，<strong>mysqldump释放了MDL读锁，现象：没有影响，备份拿到的是DDL前的表结构。</strong>（已经备份完了，这时候的修改不会影响到之前的备份）</li>
</ol>
<p>参考文章：<a href="https://jums.gitbook.io/mysql-shi-zhan-45-jiang/07-hang-suo-gong-guo-zen-mo-jian-shao-hang-suo-dui-xing-neng-de-ying-xiang">07 行锁功过：怎么减少行锁对性能的影响？ | MySql实战45讲 (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>事务到底是隔离的还是不隔离的？</title>
    <url>/2024/09/10/MySQL08/</url>
    <content><![CDATA[<p>在第3篇文章和你讲事务隔离级别的时候提到过，<strong>如果是可重复读隔离级别，事务T启动的时候会创建一个视图read-view</strong>，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的<strong>仍然跟在启动时看到的一样</strong>。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。</p>
<p>但是，我在上一篇文章中，和你分享行锁的时候又提到，<strong>一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁</strong>，<strong>它又不能这么超然了，会被锁住，进入等待状态</strong>。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？</p>
<p>我给你举一个例子吧。下面是一个只有两行的表的初始化语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `k` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into t(id, k) values(1,1),(2,2);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/10/MySQL08/image-20240910163254527.png" alt="image-20240910163254527"></p>
<p>这里，我们需要注意的是事务的启动时机。</p>
<p><strong>begin&#x2F;start transaction 命令并不是一个事务的起点</strong>，在执行到它们之后的<strong>第一个操作InnoDB表的语句，事务才真正启动</strong>。<strong>如果你想要马上启动一个事务，可以使用start transaction with consistent snapshot 这个命令。（怪不得之前会加上一个后缀 with consistent snapshot）</strong></p>
<p>还需要注意的是，在整个专栏里面，我们的例子中如果没有特别说明，都是默认autocommit&#x3D;1。</p>
<p>在这个例子中，事务C没有显式地使用begin&#x2F;commit，<strong>表示这个update语句本身就是一个事务，语句完成的时候会自动提交</strong>。事务B在更新了行之后查询; 事务A在一个只读事务中查询，并且时间顺序上是在事务B的查询之后。</p>
<p>这时，如果我告诉你事务B查到的k的值是3，而事务A查到的k的值是1，你是不是感觉有点晕呢？</p>
<p>所以，今天这篇文章，我其实就是想和你说明白这个问题，希望借由把这个疑惑解开的过程，能够帮助你对InnoDB的事务和锁有更进一步的理解。</p>
<p>在MySQL里，<strong>有两个“视图”的概念</strong>：</p>
<ul>
<li><strong>一个是view。</strong>它是一个用查询语句定义的虚拟表，在调用的时候<strong>执行查询语句并生成结果</strong>。创建视图的语法是create view … ，<strong>而它的查询方法与表一样。</strong></li>
<li><strong>另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view。</strong>用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</li>
</ul>
<p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</p>
<p>在第3篇文章<a href="https://time.geekbang.org/column/article/68963">《事务隔离：为什么你改了我还看不见？》</a>中，我跟你解释过一遍MVCC的实现逻辑。今天为了说明查询和更新的区别，我换一个方式来说明，<strong>把read view拆开</strong>。你可以结合这两篇文章的说明来更深一步地理解MVCC。</p>
<h3 id="“快照”在MVCC里是怎么工作的？"><a href="#“快照”在MVCC里是怎么工作的？" class="headerlink" title="“快照”在MVCC里是怎么工作的？"></a>“快照”在MVCC里是怎么工作的？</h3><p>在可重复读隔离级别下，<strong>事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</strong></p>
<p>这时，你会说这看上去不太现实啊。如果一个库有100G，那么我启动一个事务，MySQL就要拷贝100G的数据出来，这个过程得多慢啊。<strong>可是，我平时的事务执行起来很快啊。</strong></p>
<p>实际上，我们并不需要拷贝出这100G的数据。我们先来看看这个快照是怎么实现的。</p>
<p><strong>InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。（有主键那味了）</strong></p>
<p><strong>而每行数据也都是有多个版本的。</strong>每次事务更新数据的时候，<strong>都会生成一个新的数据版本</strong>，并且<strong>把transaction id赋值给这个数据版本的事务ID</strong>，记为<strong>row trx_id</strong>。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。（这个更新版本的操作和ES挺像的）</p>
<p>也就是说，数据表中的一行记录，<strong>其实可能有多个版本(row)<strong>，</strong>每个版本有自己的row trx_id。</strong></p>
<p>如图2所示，就是一个记录被多个事务连续更新后的状态。</p>
<p><img src="/2024/09/10/MySQL08/image-20240910163823376.png" alt="image-20240910163823376"></p>
<p>图中虚线框里是<strong>同一行数据</strong>的4个版本，当前最新版本是V4，k的值是22，<strong>它是被transaction id 为25的事务更新的，因此它的row trx_id也是25。</strong>（Transaction ID: <strong>trx_id</strong> 的全称是 <strong>Transaction Identifier</strong>，即<strong>事务标识符</strong>。通过追踪每行数据的 trx_id，数据库能够确保在读取数据时<strong>只返回对应于某个事务快照的数据</strong>，从而保持数据的一致性和隔离性。）</p>
<p>你可能会问，前面的文章不是说，语句更新会生成undo log（回滚日志）吗？那么，<strong>undo log在哪呢？</strong></p>
<p><strong>实际上，图2中的三个虚线箭头，就是undo log；而V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。</strong></p>
<p>明白了多版本和row trx_id的概念后，我们再来想一下，InnoDB是怎么定义那个“100G”的快照的。</p>
<p>按照可重复读的定义，一个事务启动的时候，能够看到所有<strong>已经提交的事务结果</strong>。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p>
<p>因此，一个事务只需要在启动的时候声明说，<strong>“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</strong></p>
<p>当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。</p>
<p><strong>在实现上， InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。</strong></p>
<p><strong>数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。</strong></p>
<p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>
<p>而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。</p>
<p>这个视图数组把所有的row trx_id 分成了几种不同的情况。</p>
<p><img src="/2024/09/10/MySQL08/image-20240910163838038.png" alt="image-20240910163838038"></p>
<p>这样，对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：</p>
<ol>
<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，<strong>这个数据是可见的</strong>；</li>
<li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，<strong>是肯定不可见的</strong>；</li>
<li>如果落在黄色部分，那就包括两种情况 a. 若 row trx_id在数组中，<strong>表示这个版本是由还没提交的事务生成的，不可见</strong>； b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ol>
<p><img src="/2024/09/10/MySQL08/image-20240910165332970.png" alt="image-20240910165332970"></p>
<p>比如，对于图中的数据来说，如果有一个事务，它的低水位是18，那么当它访问这一行数据时，就会从V4通过U3计算出V3，所以在它看来，这一行的值是11。</p>
<p>你看，有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？<strong>因为之后的更新，生成的版本一定属于上面的2或者3(a)的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的了。</strong></p>
<p>所以你现在知道了，<strong>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p>
<p><img src="/2024/09/10/MySQL08/image-20240910165529160.png" alt="image-20240910165529160"></p>
<p>接下来，我们继续看一下图中的三个事务，分析下事务A的语句返回的结果，为什么是k&#x3D;1。</p>
<p>这里，我们不妨做如下假设：</p>
<ol>
<li><strong>事务A开始前，系统里面只有一个活跃事务ID是99；</strong></li>
<li><strong>事务A、B、C的版本号分别是100、101、102，且当前系统里只有这四个事务；</strong></li>
<li><strong>三个事务开始前，（1，1）这一行数据的row trx_id是90。</strong></li>
</ol>
<p>这样，事务A的视图数组就是[99,100], 事务B的视图数组是[99,100,101], 事务C的视图数组是[99,100,101,102]。</p>
<p>为了简化分析，我先把其他干扰语句去掉，只画出跟事务A查询逻辑有关的操作：</p>
<p><img src="/2024/09/10/MySQL08/image-20240910163854472.png" alt="image-20240910163854472"></p>
<p>从图中可以看到，第一个有效更新是事务C，把数据从(1,1)改成了(1,2)。这时候，<strong>这个数据的最新版本的row trx_id是102，而90这个版本已经成为了历史版本。</strong></p>
<p>第二个有效更新是事务B，<strong>把数据从(1,2)改成了(1,3)。这时候，这个数据的最新版本（即row trx_id）是101，而102又成为了历史版本。</strong></p>
<p>你可能注意到了，在事务A查询的时候，其实事务B还没有提交，但是它生成的(1,3)这个版本已经变成当前版本了。但这个版本对事务A<strong>必须是不可见的</strong>，否则就变成脏读了。</p>
<p>好，现在事务A要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。所以，事务A查询语句的读数据流程是这样的：</p>
<ul>
<li><strong>找到(1,3)的时候，判断出row trx_id&#x3D;101，比高水位大，处于红色区域，不可见；</strong></li>
<li><strong>接着，找到上一个历史版本，一看row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</strong></li>
<li><strong>再往前找，终于找到了（1,1)，它的row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</strong></li>
</ul>
<p>这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据的结果都是一致的，<strong>所以我们称之为一致性读。</strong></p>
<p>这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，这样分析可见性很麻烦。</p>
<p>所以，我来给你翻译一下。<strong>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</strong></p>
<ol>
<li><strong>版本未提交，不可见；</strong></li>
<li><strong>版本已提交，但是是在视图创建后提交的，不可见；</strong></li>
<li><strong>版本已提交，而且是在视图创建前提交的，可见。</strong></li>
</ol>
<p>现在，我们用这个规则来判断图4中的查询结果，<strong>事务A的查询语句的视图数组是在事务A启动的时候生成的，这时候：</strong></p>
<ul>
<li><strong>(1,3)还没提交，属于情况1，不可见；</strong></li>
<li><strong>(1,2)虽然提交了，但是是在视图数组创建之后提交的，属于情况2，不可见；</strong></li>
<li><strong>(1,1)是在视图数组创建之前提交的，可见。</strong></li>
</ul>
<p><strong>你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们就都用这个规则来分析。</strong></p>
<h3 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h3><p>细心的同学可能有疑问了：<strong>事务B的update语句，如果按照一致性读，好像结果不对哦？</strong></p>
<p>你看图5中，事务B的视图数组是先生成的，之后事务C才提交，不是应该看不见(1,2)吗，怎么能算出(1,3)来？</p>
<p><img src="/2024/09/10/MySQL08/image-20240910170206616.png" alt="image-20240910170206616"></p>
<p>是的，如果事务B在更新之前<strong>查询</strong>一次数据，这个查询返回的k的值确实是1。</p>
<p>但是，当它要去<strong>更新数据</strong>的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。<strong>因此，事务B此时的set k&#x3D;k+1是在（1,2）的基础上进行的操作。</strong></p>
<p>所以，这里就用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p>
<p>因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，<strong>这个新版本的row trx_id是101</strong>。</p>
<p>所以，在执行事务B<strong>查询</strong>语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的k的值是3。</p>
<p>这里我们提到了一个概念，叫作<strong>当前读</strong>。<strong>其实，除了update语句外，select语句如果加锁，也是当前读。</strong></p>
<p>建议先看看这篇博客再看下面的内容：</p>
<ul>
<li><a href="https://learnku.com/articles/12800/lock-in-share-mode-mysql-shared-lock-exclusive-lock-for-update">MySQL 共享锁 (lock in share mode)，排他锁 (for update) | Laravel China 社区 (learnku.com)</a></li>
</ul>
<p>总结一下重点内容：</p>
<p>共享锁 (lock in share mode)：</p>
<ul>
<li>允许其它事务也增加共享锁读取</li>
<li>不允许其它事物增加排他锁 (for update)</li>
<li>当事务同时增加共享锁时候，事务的更新必须等待先执行的事务 commit 后才行，如果同时并发太大可能很容易造成死锁</li>
</ul>
<p>共享锁，事务都加，都能读。修改是惟一的，必须等待前一个事务 commit，才可</p>
<p>排他锁 (for update)：</p>
<ul>
<li>事务之间不允许其它排他锁或共享锁读取，修改更不可能</li>
<li>一次只能有一个排他锁执行 commit 之后，其它事务才可执行</li>
</ul>
<p>不允许其它事务增加共享或排他锁读取。修改是惟一的，必须等待前一个事务 commit，才可</p>
<p>接下来再看本篇内容</p>
<p>所以，如果把事务A的查询语句select * from t where id&#x3D;1修改一下，加上lock in share mode 或 for update，也都可以读到版本号是101的数据，返回的k的值是3。下面这两个select语句，就是分别加了读锁（S锁，共享锁）和写锁（X锁，排他锁）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select k from t where id=1 lock in share mode;</span><br><span class="line">mysql&gt; select k from t where id=1 for update;</span><br></pre></td></tr></table></figure>

<p>再往前一步，假设事务C不是马上提交的，而是变成了下面的事务C’，会怎么样呢？</p>
<p><img src="/2024/09/10/MySQL08/image-20240910170244857.png" alt="image-20240910170244857"></p>
<p>事务C’的不同是，更新后并没有马上提交，在它提交前，事务B的更新语句先发起了。前面说过了，虽然事务C’还没提交，但是(1,2)这个版本也已经生成了，并且是当前的最新版本。那么，事务B的更新语句会怎么处理呢？</p>
<p>这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务C’没提交，也就是说(1,2)这个版本上的<strong>写锁</strong>还没释放。而事务B是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务C’释放这个锁，才能继续它的当前读。</p>
<p><img src="/2024/09/10/MySQL08/image-20240910170256116.png" alt="image-20240910170256116"></p>
<p>到这里，我们把一致性读、当前读和行锁就串起来了。</p>
<p>现在，我们再回到文章开头的问题：<strong>事务的可重复读的能力是怎么实现的？</strong></p>
<p><strong>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。</strong>如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p>
<p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，<strong>之后事务里的其他查询都共用这个一致性视图</strong>；</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个<strong>新的视图</strong>。</li>
</ul>
<p>那么，我们再看一下，在读提交隔离级别下，事务A和事务B的查询语句查到的k，分别应该是多少呢？</p>
<p>这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的start transaction。</p>
<p>下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图中的read view框。（注意：<strong>这里，我们用的还是事务C的逻辑直接提交，而不是事务C’）</strong></p>
<p><img src="/2024/09/10/MySQL08/image-20240910170318298.png" alt="image-20240910170318298"></p>
<p>这时，事务A的查询语句的视图数组是在执行这个语句的时候创建的，时序上(1,2)、(1,3)的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：</p>
<ul>
<li><strong>(1,3)还没提交，属于情况1，不可见；</strong></li>
<li><strong>(1,2)提交了，属于情况3，可见。</strong></li>
</ul>
<p>所以，这时候事务A查询语句返回的是k&#x3D;2。</p>
<p>显然地，事务B查询结果k&#x3D;3。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>InnoDB的<strong>行数据有多个版本，每个数据版本有自己的row trx_id，每个事务或者语句有自己的一致性视图</strong>。普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的可见性。</p>
<ul>
<li><strong>对于可重复读，查询只承认在事务启动前就已经提交完成的数据；</strong></li>
<li><strong>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</strong></li>
<li><strong>而当前读，总是读取已经提交完成的最新版本。</strong></li>
</ul>
<p>你也可以想一下，为什么表结构不支持“可重复读”？<strong>这是因为表结构没有对应的行数据，也没有row trx_id，因此只能遵循当前读的逻辑。</strong></p>
<p>当然，MySQL 8.0已经可以把表结构放在InnoDB字典里了，<strong>也许以后会支持表结构的可重复读</strong>。</p>
<p>又到思考题时间了。我用下面的表结构和初始化语句作为试验环境，事务隔离级别是<strong>可重复读</strong>。</p>
<p><img src="/2024/09/10/MySQL08/image-20240910184154368.png" alt="image-20240910184154368"></p>
<p>现在，我要把所有“字段c和id值相等的行”的c值清零，但是却发现了一个“诡异”的、改不掉的情况。请你构造出这种情况，并说明其原理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into t(id, c) values(1,1),(2,2),(3,3),(4,4);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/10/MySQL08/image-20240910173401745.png" alt="image-20240910173401745"></p>
<p>复现出来以后，请你再思考一下，在实际的业务开发中有没有可能碰到这种情况？你的应用代码会不会掉进这个“坑”里，你又是怎么解决的呢？</p>
<h3 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h3><p>我在上一篇文章最后，留给你的问题是：怎么删除表的前10000行。比较多的留言都选择了第二种方式，<strong>即：在一个连接中循环执行20次 delete from T limit 500。</strong></p>
<p>确实是这样的，第二种方式是相对较好的。</p>
<p>第一种方式（即：直接执行delete from T limit 10000）里面，<strong>单个语句占用时间长，锁的时间也比较长；而且大事务还会导致主从延迟。</strong></p>
<p>第三种方式（即：在<strong>20个连接中同时执行</strong>delete from T limit 500），<strong>会人为造成锁冲突。</strong></p>
<blockquote>
<p>大家需要区分行锁、MDL锁和表锁的区别。对InnoDB表更新一行，可能过了MDL关，却被挡在行锁阶段。</p>
</blockquote>
<p>直接看这篇博客即可，甚至还总结了一下前几节的内容</p>
<ul>
<li><p><a href="https://blog.csdn.net/weixin_42970433/article/details/108592789">【mysql45讲】全局锁、表级锁(表锁、MDL)、行锁的作用与区别_有mdl锁了为什么还要有表锁-CSDN博客</a></p>
</li>
<li><p><strong>全局锁</strong>一般用于<strong>数据库备份</strong>的时候使用，<strong>会对整个数据库加锁</strong>。会<strong>阻塞数据更新语句、数据定义语句、更新事务的提交</strong>（一般是在数据库备份的时候使用）</p>
</li>
<li><p><strong>表级锁</strong>现在用的比较少，如果你用的存储引擎是MyISAM的话，那么用的倒是很多。<strong>不仅会限制其他线程的读写，同时也会限制本教程接下来的操作对象</strong>（举个例子：lock tables t1 read,t2 write，使本线程只能读t1,写t2,不能写t1也不能读写其他表）（一般是存储引擎不支持行锁才会使用表级锁）</p>
</li>
<li><p><strong>元数据锁（mete data lock MDL)<strong>，不需要显示的使用，在访问表的时候会</strong>自动加上</strong>。当<strong>对一个表增删改查</strong>时，加<strong>MDL读锁</strong>；当<strong>对一个表做结构变更操作</strong>时，加<strong>MDL写锁</strong>。读锁<strong>不互斥</strong>，可以有多个线程对同一张表增删改查；写锁<strong>互斥</strong>，比如两个线程要对一张表修改表结构，第二个线程要等第一个线程结束后再修改。语句的MDL锁，在语句执行完后不会立即释放，<strong>而是等事务提交后才会释放</strong>。（简单的说，MDL是用来保护表结构的一种锁）</p>
</li>
<li><p><strong>行锁</strong>，<strong>不是</strong>所有的存储引擎都支持行锁，InnoDB是支持行锁的。InnoDB行锁是通过给索引项加锁来实现的，即只有通过索引条件检索数据，InnoDB才使用行级锁，否则将使用表锁。也就是说，<strong>没有索引的时候，使用表锁。</strong>在InnoDB中，行锁<strong>是需要时才加上</strong>，但不是执行完那条语句就释放，<strong>要等事务提交后释放</strong>。<br>所以，在应用中，<strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong>（简单的说，<strong>行锁是针对索引的锁</strong>）</p>
</li>
<li><p>死锁，并发系统中不同线程间<strong>循环资源等待时会出现死锁</strong>（字面意思，这个锁解不开了，是一个Dead的锁）</p>
</li>
</ul>
<p>参考文章：<a href="https://jums.gitbook.io/mysql-shi-zhan-45-jiang/08-shi-wu-dao-di-shi-ge-li-de-huan-shi-bu-ge-li-de">08 事务到底是隔离的还是不隔离的？ | MySql实战45讲 (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>普通索引和唯一索引，应该怎么选择？</title>
    <url>/2024/09/10/MySQL09/</url>
    <content><![CDATA[<p>在前面的基础篇文章中，我给你介绍过索引的基本概念，相信你已经了解了<strong>唯一索引和普通索引</strong>的区别。今天我们就继续来谈谈，在不同的业务场景下，应该选择普通索引，还是唯一索引？</p>
<p>不太清楚唯一索引和普通索引的右转看这篇文章：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1948984">MySQL的普通索引和唯一索引到底什么区别？-腾讯云开发者社区-腾讯云 (tencent.com)</a></li>
</ul>
<p>提取了一些重点出来：</p>
<p><strong>主键 V.S 唯一索引：</strong></p>
<p>主键保证DB的每一行都是<strong>唯一、不重复</strong>，比如身份证，学号等，不重复。 唯一索引的作用跟主键一样。 <strong>但在一张表里面只能有一个主键，不能为空，唯一索引可有多个。唯一索引可有一条记录为null。</strong></p>
<p>比如学生表：</p>
<ul>
<li>在学校，一般用学号做主键，身份证号作为唯一索引</li>
<li>在教育局，就把身份证号弄成主键，学号作为唯一索引</li>
</ul>
<p>所以选谁做主键，取决于业务需求。</p>
<p><strong>更新性能：</strong></p>
<p>往表中插入一个新记录(4,400)，InnoDB会有什么反应？</p>
<p>这要看该记录要更新的目标页是否在内存：</p>
<p>在内存：</p>
<ul>
<li>普通索引 找到3和5之间的位置，插入值，结束。 </li>
<li>唯一索引 找到3和5之间的位置，<code>判断到没有冲突</code>，插入值，结束。</li>
</ul>
<p>只是一个判断的差别，耗费微小CPU时间。</p>
<p>不在内存：</p>
<ul>
<li>唯一索引将数据页读入内存，判断到没有冲突，插入值，结束。 </li>
<li>普通索引将更新记录在change buffer，结束。</li>
</ul>
<p><strong>将数据从磁盘读入内存涉及随机I&#x2F;O访问，是DB里成本最高的操作之一。而change buffer可以减少随机磁盘访问，所以更新性能提升明显。</strong></p>
<p><strong>索引选择最佳实践：</strong></p>
<p><strong>普通索引、唯一索引在查询性能上无差别，主要考虑更新性能。所以，推荐尽量选择普通索引。</strong></p>
<p>若所有更新后面，都紧跟对该记录的查询，就该关闭change buffer。其它情况下，change buffer都能提升更新性能。 <strong>普通索引和change buffer的配合使用，对数据量大的表的更新优化还是明显的。</strong></p>
<p><strong>在使用机械硬盘时，change buffer收益也很大。</strong>所以，当你有“历史数据”库，且出于成本考虑用机械硬盘，应该关注这些表里的索引，尽量用普通索引，把change buffer开大，确保“历史数据”表的数据写性能。</p>
<p>建议看完这几篇文章之后再看下面的内容</p>
<ul>
<li><p><a href="https://www.cnblogs.com/mengxinJ/p/14211427.html">MySQL 中的WAL机制 - 萌新J - 博客园 (cnblogs.com)</a></p>
<p><strong>WAL，全称是Write-Ahead Logging， 预写日志系统。</strong>指的是 MySQL 的写操作<strong>并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上</strong>。这样的好处是错开高峰期。日志主要分为 <strong>undo log（MVCC）、redo log（防止写操作因为宕机而丢失）、binlog（写操作的备份，保证主从一致）</strong>。这三种在之前的博客已经详细说过了，作用分别是 “ <strong>完成MVCC从而实现 MySQL 的隔离级别</strong> “、” <strong>降低随机写的性能消耗（转成顺序写），同时防止写操作因为宕机而丢失</strong> “、” <strong>写操作的备份，保证主从一致</strong> “。关于这三种日志的内容讲的比较分散且具体的执行过程没有提到，所以这里来总结一下这三种日志。</p>
</li>
<li><p><a href="https://www.cnblogs.com/mengxinJ/p/14045520.html">一条 sql 的执行过程详解 - 萌新J - 博客园 (cnblogs.com)</a></p>
<p>这个可以搭配着45讲看</p>
</li>
</ul>
<p><strong>插入流程：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into t(id,k)</span><br><span class="line">values (id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure>

<p>假设当前k索引树的状态，查找到位置后：</p>
<ul>
<li>k1所在数据页在内存(buffer pool)</li>
<li>k2数据页不在内存</li>
</ul>
<p>看如下流程：</p>
<p><strong>带change buffer的更新流程</strong></p>
<blockquote>
<p> 图中箭头都是后台操作，不影响更新请求的响应。</p>
</blockquote>
<p><img src="/2024/09/10/MySQL09/image-20240910204423231.png" alt="image-20240910204423231"></p>
<p>该更新做了如下操作：</p>
<ol>
<li>Page1在内存，直接更新内存</li>
<li>Page2不在内存，<strong>就往change buffer区，缓存一个“往Page2插一行记录”的信息</strong></li>
<li><strong>将前两个动作记入redo log</strong></li>
</ol>
<p>至此，事务完成。<strong>执行该更新语句成本很低，只是写两处内存，然后写一处磁盘（前两次操作合在一起写了一次磁盘），还是顺序写。</strong></p>
<p><strong>处理之后的读请求：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t </span><br><span class="line">where k </span><br><span class="line">	in (k1, k2);</span><br></pre></td></tr></table></figure>

<p>读语句紧随更新语句之后，<strong>这时内存中的数据都还在，所以此时这俩读操作就与系统表空间和 redo log 无关。</strong></p>
<p><img src="/2024/09/10/MySQL09/image-20240910204622083.png" alt="image-20240910204622083"></p>
<p>读Page1时，<strong>直接从内存返回</strong>。</p>
<p>WAL之后若读数据，是否一定要读盘？一定要从redo log将数据更新后才能返回？ 其实不用。看上图状态，虽然磁盘上还是之前的数据，但这里直接从内存返回结果，结果是正确的。</p>
<p>读Page2时，需将Page2从磁盘读入内存，然后应用change buffer里的操作日志，生成一个正确版本并返回结果。<strong>所以一直到需要读Page2时，该数据页才会被从磁盘读入内存。</strong></p>
<p>综上，这俩机制的更新性能：</p>
<ul>
<li><strong>redo log 主要节省随机写磁盘的I&#x2F;O消耗（转成顺序写）</strong></li>
<li><strong>change buffer主要节省随机读磁盘的I&#x2F;O消耗</strong></li>
</ul>
<h5 id="带change-buffer的读过程"><a href="#带change-buffer的读过程" class="headerlink" title="带change buffer的读过程"></a>带change buffer的读过程</h5><p><strong>总结：</strong></p>
<p>因为<strong>唯一索引用不了change buffer</strong>，若业务可以接受，<strong>从性能角度，优先考虑非唯一索引</strong>。</p>
<p><strong>到底何时使用唯一索引：</strong></p>
<p>问题就在于“业务可能无法确保”，而本文前提是“业务代码已保证不会写入重复数据”，才讨论的性能问题。</p>
<ul>
<li><strong>若业务无法保证或业务就是要求<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>来做约束 没有撤退可言，必须创建唯一索引。</strong>那本文意义就在于，若碰上大量插入数据慢、内存命中率低时，多提供了一个排查思路</li>
<li><strong>“归档库”场景，可考虑使用唯一索引。</strong>比如线上数据只需保留半年，然后历史数据存在归档库。此时，归档数据已是确保没有唯一键冲突。要提高归档效率，可考虑把表的唯一索引改为普通索引。</li>
</ul>
<p>若某次写入使用了change buffer，之后主机异常重启，是否会丢失change buffer数据</p>
<p>不会！虽然是只更新内存，<strong>但在事务提交时，change buffer的操作也被记录到了redo log。所以崩溃恢复时，change buffer也能找回。</strong></p>
<p>接下来再看</p>
<p>假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写入两个重复的身份证号。<strong>如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语句：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name from CUser where id_card = &#x27;xxxxxxxyyyyyyzzzzz&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>所以，你一定会考虑在id_card字段上建索引。</strong></p>
<p>由于身份证号<strong>字段比较大</strong>，我<strong>不建议</strong>你把身份证号当做主键，那么现在你有两个选择，<strong>要么给id_card字段创建唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的。</strong></p>
<p>现在我要问你的是，<strong>从性能的角度考虑</strong>，你选择唯一索引还是普通索引呢？选择的依据是什么呢？</p>
<p>简单起见，我们还是用第4篇文章<a href="https://time.geekbang.org/column/article/69236">《深入浅出索引（上）》</a>中的例子来说明，假设字段 k 上的值都不重复。</p>
<p><img src="/2024/09/10/MySQL09/image-20240910210027396.png" alt="image-20240910210027396"></p>
<p>接下来，我们就从这两种索引对查询语句和更新语句的性能影响来进行分析。</p>
<h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p>假设，执行查询的语句是 select id from T where k&#x3D;5。这个查询语句在索引树上查找的过程，<strong>先是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。</strong></p>
<ul>
<li><strong>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k&#x3D;5条件的记录。</strong></li>
<li><strong>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</strong></li>
</ul>
<p>那么，这个不同带来的性能差距会有多少呢？<strong>答案是，微乎其微。</strong></p>
<p><strong>你知道的，InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。（这里就是想要说明InnoDB读数据不是一条一条读的，而是一页一页读的）</strong></p>
<p><strong>因为引擎是按页读写的，所以说，当找到k&#x3D;5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。（简单的说，不是IO就行）</strong></p>
<p>当然，<strong>如果k&#x3D;5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。</strong></p>
<p>但是，我们之前计算过，<strong>对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概率会很低</strong>。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。</p>
<h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，我需要先跟你介绍一下change buffer。</p>
<p>当需要更新一个数据页时，<strong>如果数据页在内存中就直接更新</strong>，而如果这个数据页<strong>还没有在内存</strong>中的话，在不影响数据一致性的前提下，<strong>InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了（WAL）</strong>。在下次查询<strong>需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作</strong>。通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>需要说明的是，<strong>虽然名字叫作change buffer，实际上它是可以持久化的数据</strong>。也就是说，<strong>change buffer在内存中有拷贝，也会被写入到磁盘上</strong>。</p>
<p><strong>将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge</strong>。除了访问这个数据页会触发merge外，<strong>系统有后台线程会定期merge</strong>。在数据库<strong>正常关闭（shutdown）的过程中，也会执行merge操作</strong>。</p>
<p>显然，如果能够将更新操作<strong>先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升</strong>。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。</p>
<p>那么，<strong>什么条件下可以使用change buffer呢？</strong></p>
<p>对于唯一索引来说，<strong>所有的更新操作都要先判断这个操作是否违反唯一性约束</strong>。比如，要插入(4,400)这个记录，<strong>就要先判断现在表中是否已经存在k&#x3D;4的记录，而这必须要将数据页读入内存才能判断</strong>。<strong>如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了</strong>。</p>
<p>因此，唯一索引的更新就<strong>不能使用change buffer</strong>，实际上<strong>也只有普通索引可以使用</strong>。</p>
<p><strong>change buffer用的是buffer pool里的内存，因此不能无限增大</strong>。change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p>
<p>现在，你已经理解了change buffer的机制，那么我们再一起来看看<strong>如果要在这张表中插入一个新记录(4,400)的话，InnoDB的处理流程是怎样的。</strong></p>
<p>第一种情况是，<strong>这个记录要更新的目标页在内存中</strong>。这时，InnoDB的处理流程如下：</p>
<ul>
<li><strong>对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；</strong></li>
<li><strong>对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。</strong></li>
</ul>
<p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的CPU时间。</p>
<p>但，这不是我们关注的重点。</p>
<p>第二种情况是，<strong>这个记录要更新的目标页不在内存中</strong>。这时，InnoDB的处理流程如下：</p>
<ul>
<li>对于唯一索引来说，<strong>需要将数据页读入内存，判断到没有冲突</strong>，插入这个值，语句执行结束；</li>
<li>对于普通索引来说，<strong>则是将更新记录在change buffer</strong>，语句执行就结束了。（充分体现了WAL）</li>
</ul>
<p><strong>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一</strong>。change buffer因为<strong>减少了随机磁盘访问，所以对更新性能的提升是会很明显的</strong>。</p>
<p>之前我就碰到过一件事儿，有个DBA的同学跟我反馈说，他负责的某个业务的库内存命中率突然从99%降低到了75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，<strong>我发现这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引</strong>。</p>
<h3 id="change-buffer的使用场景"><a href="#change-buffer的使用场景" class="headerlink" title="change buffer的使用场景"></a>change buffer的使用场景</h3><p>通过上面的分析，你已经清楚了<strong>使用change buffer对更新过程的加速作用，也清楚了change buffer只限于用在普通索引的场景下，而不适用于唯一索引</strong>。那么，现在有一个问题就是：普通索引的所有场景，使用change buffer都可以起到加速作用吗？</p>
<p><strong>因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</strong></p>
<p>因此，<strong>对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好</strong>。这种业务模型常见的就是<strong>账单类、日志类的系统</strong>。</p>
<p>反过来，假设一个业务的更新模式是<strong>写入之后马上会做查询</strong>，那么即使满足了条件，将更新先记录在change buffer，但之后由于<strong>马上要访问这个数据页</strong>，会<strong>立即触发merge过程</strong>。这样随机访问IO的次数<strong>不会减少</strong>，<strong>反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用</strong>。</p>
<h3 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h3><p>回到我们文章开头的问题，普通索引和唯一索引应该怎么选择。<strong>其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。</strong></p>
<p><strong>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。</strong></p>
<p>在实际使用中，你会发现，<strong>普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的</strong>。</p>
<p>特别地，在使用机械硬盘时，change buffer这个机制的收效是非常显著的。所以，当你有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那你应该特别关注这些表里的索引，尽量使用普通索引，然后把change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。</p>
<h3 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h3><p>理解了change buffer的原理，你可能会联想到我在前面文章中和你介绍过的redo log和WAL。</p>
<p>在前面文章的评论中，我发现有同学混淆了redo log和change buffer。WAL 提升性能的核心机制，也的确是尽量减少随机读写，这两个概念确实容易混淆。所以，这里我把它们放到了同一个流程里来说明，便于你区分这两个概念。</p>
<blockquote>
<p>备注：这里，你可以再回顾下第2篇文章<a href="https://time.geekbang.org/column/article/68633">《日志系统：一条SQL更新语句是如何执行的？》</a>中的相关内容。</p>
</blockquote>
<p>现在，我们要在表上执行这个插入语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure>

<p>这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存(InnoDB buffer pool)中，k2所在的数据页不在内存中。如图2所示是带change buffer的更新状态图。</p>
<p><img src="/2024/09/10/MySQL09/image-20240910210049413.png" alt="image-20240910210049413"></p>
<p>分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。</p>
<p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p>
<ol>
<li><strong>Page 1在内存中，直接更新内存；</strong></li>
<li><strong>Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息</strong></li>
<li><strong>将上述两个动作记入redo log中（图中3和4）。</strong></li>
</ol>
<p>做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。</p>
<p>同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。</p>
<p>那在这之后的读请求，要怎么处理呢？</p>
<p>比如，我们现在要执行 select * from t where k in (k1, k2)。这里，我画了这两个读请求的流程图。</p>
<p><strong>如果读语句发生在更新语句后不久，内存中的数据都还在，</strong>那么此时的这两个读操作就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关了。所以，我在图中就没画出这两部分。</p>
<p><img src="/2024/09/10/MySQL09/image-20240910210104418.png" alt="image-20240910210104418"></p>
<p>从图中可以看到：</p>
<ol>
<li><strong>读Page 1的时候，直接从内存返回</strong>。WAL之后如果读数据，是不是一定要读盘，<strong>是不是一定要从redo log里面把数据更新以后才可以返回</strong>？其实是不用的。你可以看一下图3的这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。（简单的说，WAL就是延迟更新的，拖到没有办法了再更新）</li>
<li><strong>要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果。</strong></li>
</ol>
<p>可以看到，直到需要读Page 2的时候，这个数据页才会被读入内存。</p>
<p>所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，<strong>redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。（一个优化了写磁盘，一个优化了读磁盘）</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天，我从普通索引和唯一索引的选择开始，和你分享了数据的查询和更新过程，然后说明了change buffer的机制以及应用场景，最后讲到了索引选择的实践。</p>
<p><strong>由于唯一索引用不上change buffer的优化机制，因此如果业务可以接受，从性能角度出发我建议你优先考虑非唯一索引。</strong></p>
<p>最后，又到了思考题时间。</p>
<p><img src="/2024/09/10/MySQL09/image-20240910211808617.png" alt="image-20240910211808617"></p>
<p>通过图2你可以看到，change buffer一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致change buffer丢失呢？change buffer丢失可不是小事儿，再从磁盘读入数据可就没有了merge过程，就等于是数据丢失了。会不会出现这种情况呢？</p>
<p><strong>补充：</strong> 大家对“是否使用唯一索引”有比较多的讨论，主要是纠结在“业务可能无法确保”的情况。这里，我再说明一下：</p>
<ul>
<li><strong>首先，业务正确性优先。</strong>咱们这篇文章的前提是“业务代码<strong>已经保证不会写入重复数据</strong>”的情况下，讨论性能问题。<strong>如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引</strong>。这种情况下，本篇文章的意义在于，<strong>如果碰上了大量插入数据慢、内存命中率低的时候，可以给你多提供一个排查思路。</strong></li>
<li><strong>然后，在一些“归档库”的场景，你是可以考虑使用唯一索引的。</strong>比如，线上数据只需要保留半年，然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。<strong>要提高归档效率，可以考虑把表里面的唯一索引改成普通索引。</strong></li>
</ul>
<h3 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h3><p>上期的问题是：如何构造一个“数据无法修改”的场景。</p>
<p><img src="/2024/09/10/MySQL09/image-20240910212018837.png" alt="image-20240910212018837"></p>
<p>这样，session A看到的就是我截图的效果了。</p>
<p>其实，还有另外一种场景</p>
<p><img src="/2024/09/10/MySQL09/image-20240910212034843.png" alt="image-20240910212034843"></p>
<p>这个操作序列跑出来，session A看的内容也是能够复现我截图的效果的。这个session B’启动的事务比A要早，其实是上期我们描述事务版本的可见性规则时留的彩蛋，因为规则里还有一个“活跃事务的判断”，我是准备留到这里再补充的。</p>
<p>当我试图在这里讲述完整规则的时候，发现第8篇文章<a href="https://time.geekbang.org/column/article/70562">《事务到底是隔离的还是不隔离的？》</a>中的解释引入了太多的概念，以致于分析起来非常复杂。</p>
<p>因此，我重写了第8篇，这样我们人工去判断可见性的时候，才会更方便。【看到这里，我建议你能够再重新打开第8篇文章并认真学习一次。】</p>
<p>用新的方式来分析session B’的更新为什么对session A不可见就是：在session A视图数组创建的瞬间，session B’是活跃的，属于“版本未提交，不可见”这种情况。</p>
<p>业务中如果要绕过这类问题，可以尝试使用“乐观锁”解决。</p>
<p>参考文章：<a href="https://jums.gitbook.io/mysql-shi-zhan-45-jiang/09-pu-tong-suo-yin-he-wei-yi-suo-yin-ying-gai-zen-mo-xuan-ze">09 普通索引和唯一索引，应该怎么选择？ | MySql实战45讲 (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL为什么有时候会选错索引？</title>
    <url>/2024/09/10/MySQL10/</url>
    <content><![CDATA[<p>前面我们介绍过索引，<strong>你已经知道了在MySQL中一张表其实是可以支持多个索引的</strong>。但是，<strong>你写SQL语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由MySQL来确定的。</strong></p>
<p>不知道你有没有碰到过这种情况，一条本来可以执行得很快的语句，<strong>却由于MySQL选错了索引</strong>，而导致执行速度变得很慢？</p>
<p>我们一起来看一个例子吧。</p>
<p>我们先建一个简单的表，表里有a、b两个字段，并分别建上索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `a` int(11) DEFAULT NULL,</span><br><span class="line">  `b` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE=InnoDB；</span><br></pre></td></tr></table></figure>

<p>然后，我们往表t中插入10万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到(100000,100000,100000)。</p>
<p>我是用<strong>存储过程</strong>来插入数据的，这里我贴出来方便你复现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delimiter ;;</span><br><span class="line">create procedure idata()</span><br><span class="line">begin</span><br><span class="line">  declare i int;</span><br><span class="line">  set i=1;</span><br><span class="line">  while(i&lt;=100000)do</span><br><span class="line">    insert into t values(i, i, i);</span><br><span class="line">    set i=i+1;</span><br><span class="line">  end while;</span><br><span class="line">end;;</span><br><span class="line">delimiter ;</span><br><span class="line">call idata();</span><br></pre></td></tr></table></figure>

<p>接下来，我们分析一条SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t where a between 10000 and 20000;</span><br></pre></td></tr></table></figure>

<p>你一定会说，这个语句还用分析吗，很简单呀，a上有索引，肯定是要使用索引a的。</p>
<p>你说得没错，图1显示的就是使用explain命令看到的这条语句的执行情况。</p>
<p><img src="/2024/09/10/MySQL10/image-20240911073643013.png" alt="image-20240911073643013"></p>
<p>从图1看上去，这条查询语句的执行也确实符合预期，key这个字段值是’a’，表示优化器选择了索引a。</p>
<p>不过别急，这个案例不会这么简单。在我们已经准备好的包含了10万行数据的表上，我们再做如下操作。</p>
<p><img src="/2024/09/10/MySQL10/image-20240911073701695.png" alt="image-20240911073701695"></p>
<p>这里，session A的操作你已经很熟悉了，它就是<strong>开启了一个事务</strong>。随后，session B把数据都删除后，又调用了 idata这个存储过程，插入了10万行数据。</p>
<p>这时候，session B的查询语句select * from t where a between 10000 and 20000就<strong>不会再选择索引a了</strong>。我们可以通过慢查询日志（slow log）来查看一下具体的执行情况。</p>
<p>为了说明优化器选择的结果是否正确，我增加了一个对照，即：<strong>使用force index(a)来让优化器强制使用索引a（这部分内容，我还会在这篇文章的后半部分中提到）</strong>。</p>
<p>下面的三条SQL语句，就是这个实验过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set long_query_time=0;</span><br><span class="line">select * from t where a between 10000 and 20000; /*Q1*/</span><br><span class="line">select * from t force index(a) where a between 10000 and 20000;/*Q2*/</span><br></pre></td></tr></table></figure>

<ul>
<li>第一句，<strong>是将慢查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日志中；</strong></li>
<li>第二句，Q1是session B原来的查询；</li>
<li>第三句，Q2是加了**force index(a)**来和session B原来的查询语句执行情况对比。</li>
</ul>
<p><img src="/2024/09/10/MySQL10/image-20240911073735882.png" alt="image-20240911073735882"></p>
<p>可以看到，<strong>Q1扫描了10万行，显然是走了全表扫描，执行时间是40毫秒。Q2扫描了10001行，执行了21毫秒。也就是说，我们在没有使用force index的时候，MySQL用错了索引，导致了更长的执行时间。</strong></p>
<p>这个例子对应的是我们<strong>平常不断地删除历史数据和新增数据的场景</strong>。这时，MySQL竟然会选错索引，是不是有点奇怪呢？今天，我们就从这个奇怪的结果说起吧。</p>
<h2 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h2><p>在第一篇文章中，我们就提到过，<strong>选择索引是优化器的工作</strong>。</p>
<p><strong>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句</strong>。在数据库里面，<strong>扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少</strong>。</p>
<p>当然，扫描行数并不是唯一的判断标准，<strong>优化器还会结合是否使用临时表、是否排序等因素进行综合判断</strong>。</p>
<p>我们这个简单的查询语句并没有涉及到临时表和排序，<strong>所以MySQL选错索引肯定是在判断扫描行数的时候出问题了</strong>。</p>
<p>那么，问题就是：<strong>扫描行数是怎么判断的？</strong></p>
<p>MySQL在真正开始执行语句之前，<strong>并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数</strong>。</p>
<p>这个<strong>统计信息就是索引的“区分度”</strong>。显然，一个索引上不同的值越多，这个索引的区分度就越好。<strong>而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好</strong>。</p>
<p>我们可以<strong>使用show index方法，看到一个索引的基数</strong>。如图4所示，就是表t的show index 的结果 。虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不同，而且<strong>其实都不准确</strong>。</p>
<p><img src="/2024/09/10/MySQL10/image-20240911074038621.png" alt="image-20240911074038621"></p>
<p>那么，<strong>MySQL是怎样得到索引的基数的呢？</strong>这里，我给你简单介绍一下<strong>MySQL采样统计</strong>的方法。</p>
<p>为什么要采样统计呢？<strong>因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</strong></p>
<p><strong>采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数</strong>。</p>
<p>而数据表是会<strong>持续更新</strong>的，索引统计信息也不会固定不变。所以，当变更的数据行数超过1&#x2F;M的时候，会<strong>自动触发重新做一次索引统计</strong>。</p>
<p>在MySQL中，有两种存储索引统计的方式，可以通过设置参数innodb_stats_persistent的值来选择：</p>
<ul>
<li>设置为on的时候，<strong>表示统计信息会持久化存储。</strong>这时，默认的N是20，M是10。</li>
<li>设置为off的时候，<strong>表示统计信息只存储在内存中。</strong>这时，默认的N是8，M是16。</li>
</ul>
<p>由于是采样统计，<strong>所以不管N是20还是8，这个基数都是很容易不准的。</strong></p>
<p>但，这还不是全部。</p>
<p>你可以从上图中看到，这次的索引统计值（cardinality列）虽然不够精确，但大体上还是差不多的，选错索引一定还有别的原因。</p>
<p>其实索引统计只是一个输入，对于一个具体的语句来说，优化器还要判断，执行这个语句本身要扫描多少行。</p>
<p>接下来，我们再一起看看优化器预估的，这两个语句的扫描行数是多少。</p>
<p><img src="/2024/09/10/MySQL10/image-20240911074053831.png" alt="image-20240911074053831"></p>
<p>rows这个字段表示的是预计扫描行数。</p>
<p>其中，Q1的结果还是符合预期的，rows的值是104620；但是Q2的rows值是37116，偏差就大了。<strong>而图1中我们用explain命令看到的rows是只有10001行，是这个偏差误导了优化器的判断。</strong></p>
<p>到这里，<strong>可能你的第一个疑问不是为什么不准，而是优化器为什么放着扫描37000行的执行计划不用，却选择了扫描行数是100000的执行计划呢</strong>？</p>
<p>这是因为，<strong>如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的</strong>。</p>
<p>而如果选择扫描10万行，<strong>是直接在主键索引上扫描的，没有额外的代价</strong>。</p>
<p>优化器会<strong>估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快</strong>。当然，从执行时间看来，这个选择并不是最优的。</p>
<p>使用普通索引<strong>需要把回表的代价算进去，在图1执行explain的时候，也考虑了这个策略的代价 ，但图1的选择是对的</strong>。也就是说，这个策略并没有问题。</p>
<p>所以冤有头债有主，MySQL选错索引，<strong>这件事儿还得归咎到没能准确地判断出扫描行数。至于为什么会得到错误的扫描行数</strong>，这个原因就作为课后问题，留给你去分析了。</p>
<p>既然是统计信息不对，那就修正。<strong>analyze table t 命令，可以用来重新统计索引信息</strong>。我们来看一下执行效果。</p>
<p><img src="/2024/09/10/MySQL10/image-20240911074130011.png" alt="image-20240911074130011"></p>
<p>这回对了。</p>
<p><strong>所以在实践中，如果你发现explain的结果预估的rows值跟实际情况差距比较大，可以采用这个方法来处理。</strong></p>
<p>其实，如果只是索引统计不准确，<strong>通过analyze命令可以解决很多问题，但是前面我们说了，优化器可不止是看扫描行数。</strong></p>
<p>依然是基于这个表t，我们看看另外一个语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 1;</span><br></pre></td></tr></table></figure>

<p>从条件上看，这个查询没有符合条件的记录，因此会返回空集合。</p>
<p>在开始执行这条语句之前，你可以先设想一下，如果你来选择索引，会选择哪一个呢？</p>
<p>为了便于分析，我们先来看一下a、b这两个索引的结构图。</p>
<p><img src="/2024/09/10/MySQL10/image-20240911074144966.png" alt="image-20240911074144966"></p>
<p>如果使用索引a进行查询，<strong>那么就是扫描索引a的前1000个值，然后取到对应的id，再到主键索引上去查出每一行，然后根据字段b来过滤。显然这样需要扫描1000行。</strong></p>
<p>如果使用索引b进行查询，<strong>那么就是扫描索引b的最后50001个值，与上面的执行过程相同，也是需要回到主键索引上取值再判断，所以需要扫描50001行。</strong></p>
<p>所以你一定会想，如果使用索引a的话，执行速度明显会快很多。那么，下面我们就来看看到底是不是这么一回事儿。</p>
<p>图8是执行explain的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/10/MySQL10/image-20240911074207327.png" alt="image-20240911074207327"></p>
<p>可以看到，返回结果中key字段显示，这次优化器选择了索引b，而rows字段显示需要扫描的行数是50198。</p>
<p><strong>从这个结果中，你可以得到两个结论：</strong></p>
<ol>
<li><strong>扫描行数的估计值依然不准确；</strong></li>
<li><strong>这个例子里MySQL又选错了索引。</strong></li>
</ol>
<h3 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a>索引选择异常和处理</h3><p>其实<strong>大多数时候优化器都能找到正确的索引，但偶尔你还是会碰到我们上面举例的这两种情况</strong>：原本可以执行得很快的SQL语句，执行速度却比你预期的慢很多，你应该怎么办呢？</p>
<p><strong>一种方法是，像我们第一个例子一样，采用force index强行选择一个索引。</strong>MySQL会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。<strong>如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</strong></p>
<p>我们来看看第二个例子。刚开始分析时，我们认为选择索引a会更好。现在，我们就来看看执行效果：</p>
<p><img src="/2024/09/10/MySQL10/image-20240911075335025.png" alt="image-20240911075335025"></p>
<p>可以看到，原本语句需要执行2.23秒，而当你使用force index(a)的时候，只用了0.05秒，<strong>比优化器的选择快了40多倍。</strong></p>
<p><strong>也就是说，优化器没有选择正确的索引，force index起到了“矫正”的作用。</strong></p>
<p>不过很多程序员不喜欢使用force index，<strong>一来这么写不优美</strong>，二来<strong>如果索引改了名字，这个语句也得改</strong>，显得很麻烦。而且如果以后<strong>迁移到别的数据库的话，这个语法还可能会不兼容</strong>。</p>
<p>但其实使用force index最主要的问题还是变更的及时性。<strong>因为选错索引的情况还是比较少出现的，所以开发的时候通常不会先写上force index。而是等到线上出现问题的时候，你才会再去修改SQL语句、加上force index。</strong>但是修改之后还要测试和发布，<strong>对于生产系统来说，这个过程不够敏捷</strong>。</p>
<p>所以，数据库的问题最好还是在数据库内部来解决。那么，在数据库里面该怎样解决呢？</p>
<p>既然优化器放弃了使用索引a，说明a还不够合适，所以<strong>第二种方法就是，我们可以考虑修改语句，引导MySQL使用我们期望的索引。</strong>比如，在这个例子里，<strong>显然把“order by b limit 1” 改成 “order by b,a limit 1” ，语义的逻辑是相同的</strong>。</p>
<p><img src="/2024/09/10/MySQL10/image-20240911075503759.png" alt="image-20240911075503759"></p>
<p>之前优化器选择使用索引b，<strong>是因为它认为使用索引b可以避免排序（b本身是索引，已经是有序的了，如果选择索引b的话，不需要再做排序，只需要遍历），所以即使扫描行数多，也判定为代价更小。</strong></p>
<p>现在order by b,a 这种写法，要求按照b,a排序，就意味着使用这两个索引都需要排序。<strong>因此，扫描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描1000行的索引a。</strong></p>
<p>当然，这种修改并不是通用的优化手段，只是刚好在这个语句里面有limit 1，<strong>因此如果有满足条件的记录， order by b limit 1和order by b,a limit 1 都会返回b是最小的那一行，逻辑上一致，才可以这么做。</strong></p>
<p>如果你觉得修改语义这件事儿不太好，这里还有一种改法，图11是执行效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from  (select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 100)alias limit 1;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/10/MySQL10/image-20240911075527162.png" alt="image-20240911075527162"></p>
<p>在这个例子里，<strong>我们用limit 100让优化器意识到，使用b索引代价是很高的。其实是我们根据数据特征诱导了一下优化器，也不具备通用性。</strong></p>
<p><strong>第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</strong></p>
<p>不过，在这个例子中，<strong>我没有找到通过新增索引来改变优化器行为的方法。这种情况其实比较少，尤其是经过DBA索引优化过的库，再碰到这个bug，找到一个更合适的索引一般比较难。</strong></p>
<p><strong>如果我说还有一个方法是删掉索引b，你可能会觉得好笑。</strong>但实际上我碰到过两次这样的例子，最终是DBA跟业务开发沟通后，<strong>发现这个优化器错误选择的索引其实根本没有必要存在，于是就删掉了这个索引，优化器也就重新选择到了正确的索引。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天我们一起聊了聊<strong>索引统计的更新机制，并提到了优化器存在选错索引的可能性</strong>。</p>
<p>对于<strong>由于索引统计信息不准确导致的问题，你可以用analyze table来解决</strong>。</p>
<p>而对于其他优化器误判的情况：</p>
<ul>
<li><strong>你可以在应用端用force index来强行指定索引</strong></li>
<li><strong>也可以通过修改语句来引导优化器</strong></li>
<li><strong>还可以通过增加或者删除索引来绕过这个问题</strong></li>
</ul>
<p>你可能会说，今天这篇文章后面的几个例子，怎么都没有展开说明其原理。我要告诉你的是，<strong>今天的话题，我们面对的是MySQL优化器的bug，每一个展开都必须深入到一行行代码去量化，实在不是我们在这里应该做的事情</strong>。</p>
<p>所以，我把我用过的解决方法跟你分享，希望你在碰到类似情况的时候，能够有一些思路。</p>
<p>前面我们在构造第一个例子的过程中，通过session A的配合，让session B删除数据后又重新插入了一遍数据，然后就发现explain结果中，rows字段从10001变成37000多。</p>
<p>而如果没有session A的配合，只是单独执行delete from t 、call idata()、explain这三句话，会看到rows字段其实还是10000左右。你可以自己验证一下这个结果。</p>
<p>这是什么原因呢？也请你分析一下吧。</p>
<h3 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h3><p>我在上一篇文章最后留给你的问题是，如果某次写入使用了change buffer机制，之后主机异常重启，是否会丢失change buffer和数据。</p>
<p>这个问题的答案是<strong>不会丢失</strong>，虽然是只更新内存，但是在事务提交的时候，<strong>我们把change buffer的操作也记录到redo log里了，所以崩溃恢复的时候，change buffer也能找回来</strong>。</p>
<p>merge的过程是否会把数据直接写回磁盘，这是个好问题。这里，我再为你分析一下。</p>
<p>merge的执行流程是这样的：</p>
<ol>
<li><strong>从磁盘读入数据页到内存（老版本的数据页）；</strong></li>
<li><strong>从change buffer里找出这个数据页的change buffer 记录(可能有多个），依次应用，得到新版数据页；</strong></li>
<li><strong>写redo log。这个redo log包含了数据的变更和change buffer的变更。</strong></li>
</ol>
<p>到这里merge过程就结束了。<strong>这时候，数据页和内存中change buffer对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。</strong></p>
<p><strong>merge 操作</strong>通常在<strong>数据操作、读取数据页、后台处理、Buffer Pool 管理、系统事件和显式刷新操作</strong>等情况下触发。主要是<strong>处理 Change Buffer 中的变更记录，并将这些变更合并到相应的数据页</strong>中。</p>
<p>合并到相应数据页的过程实际上是将<strong>变更应用到内存中的数据页，但在这个阶段，数据页本身并不会立即更新到磁盘，而是保持在内存中，处于脏页的状态，实际的磁盘更新会延迟进行</strong>。</p>
<p><strong>Checkpoint机制</strong>，具体可以看看这篇文章</p>
<ul>
<li><a href="https://www.cnblogs.com/chenpingzhao/p/5107480.html">【mysql】关于checkpoint机制 - 踏雪无痕SS - 博客园 (cnblogs.com)</a></li>
</ul>
<p>参考文章：<a href="https://jums.gitbook.io/mysql-shi-zhan-45-jiang/10-mysql-wei-shi-mo-you-shi-hou-hui-xuan-cuo-suo-yin">10 MySQL为什么有时候会选错索引？ | MySql实战45讲 (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么给字符串字段加索引？</title>
    <url>/2024/09/11/MySQL11/</url>
    <content><![CDATA[<p>现在，几乎所有的系统都支持邮箱登录，<strong>如何在邮箱这样的字段上建立合理的索引</strong>，是我们今天要讨论的问题。</p>
<p>假设，你现在<strong>维护一个支持邮箱登录的系统</strong>，用户表是这么定义的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table SUser(</span><br><span class="line">ID bigint unsigned primary key,</span><br><span class="line">email varchar(64), </span><br><span class="line">... </span><br><span class="line">)engine=innodb; </span><br></pre></td></tr></table></figure>

<p><strong>由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select f1, f2 from SUser where email=&#x27;xxx&#x27;;</span><br></pre></td></tr></table></figure>

<p>从第4和第5篇讲解索引的文章中，<strong>我们可以知道，如果email这个字段上没有索引，那么这个语句就只能做全表扫描</strong>。</p>
<p>同时，<strong>MySQL是支持前缀索引的</strong>，也就是说，<strong>你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</strong></p>
<p>比如，这两个在email字段上创建索引的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table SUser add index index1(email);</span><br><span class="line">或</span><br><span class="line">mysql&gt; alter table SUser add index index2(email(6));</span><br></pre></td></tr></table></figure>

<p>第一个语句创建的index1索引里面，包含了<strong>每个记录的整个字符串</strong>；而第二个语句创建的index2索引里面，<strong>对于每个记录都是只取前6个字节</strong>。</p>
<p>那么，这两种不同的定义在数据结构和存储上有什么区别呢？如图2和3所示，就是这两个索引的示意图。</p>
<p><img src="/2024/09/11/MySQL11/image-20240911103026039.png" alt="image-20240911103026039"></p>
<p><img src="/2024/09/11/MySQL11/image-20240911103031756.png" alt="image-20240911103031756"></p>
<p>从图中你可以看到，<strong>由于email(6)这个索引结构中每个邮箱字段都只取前6个字节（即：zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。</strong></p>
<p>但，这同时带来的损失是，<strong>可能会增加额外的记录扫描次数。</strong></p>
<p>接下来，我们再看看下面这个语句，在这两个索引定义下分别是怎么执行的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,name,email from SUser where email=&#x27;zhangssxyz@xxx.com&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>如果使用的是index1</strong>（即email整个字符串的索引结构），执行顺序是这样的：</p>
<p>1.<br>   从index1<strong>索引树</strong>找到满足索引值是’<a href="mailto:&#122;&#x68;&#x61;&#x6e;&#x67;&#115;&#x73;&#120;&#x79;&#x7a;&#64;&#x78;&#x78;&#x78;&#x2e;&#x63;&#x6f;&#x6d;">&#122;&#x68;&#x61;&#x6e;&#x67;&#115;&#x73;&#120;&#x79;&#x7a;&#64;&#x78;&#x78;&#x78;&#x2e;&#x63;&#x6f;&#x6d;</a>’的这条记录，取得ID2的值；<br>2. <strong>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</strong><br>3. <strong>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email&#x3D;‘<a href="mailto:&#x7a;&#x68;&#x61;&#x6e;&#103;&#115;&#115;&#x78;&#121;&#x7a;&#x40;&#120;&#x78;&#x78;&#x2e;&#99;&#x6f;&#x6d;">&#x7a;&#x68;&#x61;&#x6e;&#103;&#115;&#115;&#x78;&#121;&#x7a;&#x40;&#120;&#x78;&#x78;&#x2e;&#99;&#x6f;&#x6d;</a>’的条件了，循环结束。</strong></p>
<p>这个过程中，<strong>只需要回主键索引取一次数据，所以系统认为只扫描了一行。</strong></p>
<p><strong>如果使用的是index2</strong>（即email(6)索引结构），执行顺序是这样的：</p>
<p>1.<br>   从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；<br>2. 到主键上查到主键值是ID1的行，判断出email的值不是’<a href="mailto:&#x7a;&#x68;&#97;&#110;&#x67;&#115;&#x73;&#x78;&#121;&#122;&#64;&#x78;&#120;&#120;&#46;&#99;&#x6f;&#x6d;">&#x7a;&#x68;&#97;&#110;&#x67;&#115;&#x73;&#x78;&#121;&#122;&#64;&#x78;&#120;&#120;&#46;&#99;&#x6f;&#x6d;</a>’，这行记录丢弃；<br>3. 取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集；<br>4. 重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。</p>
<p><strong>在这个过程中，要回主键索引取4次数据，也就是扫描了4行。</strong></p>
<p>通过这个对比，你很容易就可以发现，<strong>使用前缀索引后，可能会导致查询语句读数据的次数变多</strong>。</p>
<p>但是，对于这个查询语句来说，<strong>如果你定义的index2不是email(6)而是email(7），也就是说取email字段的前7个字节来构建索引的话，即满足前缀’zhangss’的记录只有一个，也能够直接查到ID2，只扫描一行就结束了</strong>。</p>
<p>也就是说<strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p>
<p>于是，你就有个问题：当要给字符串创建前缀索引时，<strong>有什么方法能够确定我应该使用多长的前缀呢</strong>？</p>
<p>实际上，<strong>我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</strong></p>
<p>首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select count(distinct email) as L from SUser;</span><br></pre></td></tr></table></figure>

<p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引，可以用这个语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select </span><br><span class="line">  count(distinct left(email,4)）as L4,</span><br><span class="line">  count(distinct left(email,5)）as L5,</span><br><span class="line">  count(distinct left(email,6)）as L6,</span><br><span class="line">  count(distinct left(email,7)）as L7,</span><br><span class="line">from SUser;</span><br></pre></td></tr></table></figure>

<p>当然，<strong>使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如5%<strong>。然后，在返回的L4~L7中，找出</strong>不小于</strong> L * 95%的值，<strong>假设这里L6、L7都满足，你就可以选择前缀长度为6</strong>。</p>
<h3 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h3><p>前面我们说了使用<strong>前缀索引可能会增加扫描行数，这会影响到性能。其实，前缀索引的影响不止如此，我们再看一下另外一个场景。</strong></p>
<p>你先来看看这个SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,email from SUser where email=&#x27;zhangssxyz@xxx.com&#x27;;</span><br></pre></td></tr></table></figure>

<p>与前面例子中的SQL语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,name,email from SUser where email=&#x27;zhangssxyz@xxx.com&#x27;;</span><br></pre></td></tr></table></figure>

<p>相比，这个语句只要求返回id和email字段。</p>
<p>所以，<strong>如果使用index1（即email整个字符串的索引结构）的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2（即email(6)索引结构）的话，就不得不回到ID索引再去判断email字段的值。</strong></p>
<p>即使你将index2的定义修改为<strong>email(18)的前缀索引</strong>，这时候虽然index2<strong>已经包含了所有的信息</strong>，但InnoDB<strong>还是要回到id索引再查一下</strong>，<strong>因为系统并不确定前缀索引的定义是否截断了完整信息。</strong></p>
<p>也就是说，<strong>使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</strong></p>
<h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><p>对于类似于邮箱这样的字段来说，<strong>使用前缀索引的效果可能还不错。但是，遇到前缀的区分度不够好的情况时，我们要怎么办呢？</strong></p>
<p>比如，我们国家的身份证号，一共18位，<strong>其中前6位是地址码，所以同一个县的人的身份证号前6位一般会是相同的</strong>。</p>
<p>假设你维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为6的前缀索引的话，<strong>这个索引的区分度就非常低了。</strong></p>
<p>按照我们前面说的方法，<strong>可能你需要创建长度为12以上的前缀索引，才能够满足区分度要求。</strong></p>
<p>但是，索引选取的越长，<strong>占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。</strong></p>
<p>那么，如果我们能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理方法呢？这种方法，既可以占用更小的空间，也能达到相同的查询效率。</p>
<p>答案是，有的。</p>
<p><strong>第一种方式是使用倒序存储。****如果你存储身份证号的时候把它倒过来存，每次查询的时候，你可以这么写：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select field_list from t where id_card = reverse(&#x27;input_id_card_string&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这6位很可能就提供了足够的区分度。当然了，实践中你不要忘记使用count(distinct)方法去做个验证。</strong></p>
<p><strong>第二种方式是使用hash字段。</strong>你可以在表上再创建一个整数字段，来保存身份证的校验码，<strong>同时在这个字段上创建索引。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);</span><br></pre></td></tr></table></figure>

<p>然后每次插入新记录的时候，<strong>都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你的查询语句where部分要判断id_card的值是否精确相同。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select field_list from t where id_card_crc=crc32(&#x27;input_id_card_string&#x27;) and id_card=&#x27;input_id_card_string&#x27;</span><br></pre></td></tr></table></figure>

<p>这样，<strong>索引的长度变成了4个字节</strong>，比原来小了很多。</p>
<p>接下来，我们再一起看看<strong>使用倒序存储和使用hash字段这两种方法的异同点。</strong></p>
<p>首先，它们的相同点是，<strong>都不支持范围查询</strong>。倒序存储的字段上创建的索引<strong>是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了</strong>。同样地，hash字段的方式<strong>也只能支持等值查询</strong>。</p>
<p>它们的区别，主要体现在以下三个方面：</p>
<ol>
<li>从占用的额外空间来看，<strong>倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段</strong>。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，<strong>如果再长一点，这个消耗跟额外这个hash字段也差不多抵消了</strong>。</li>
<li>在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的话，<strong>reverse函数额外消耗的CPU资源会更小些</strong>。</li>
<li>从查询效率上看，<strong>使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1</strong>。而倒序存储方式毕竟还是用的前缀索引的方式，<strong>也就是说还是会增加扫描行数</strong>。</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在今天这篇文章中，我跟你聊了聊<strong>字符串字段创建索引</strong>的场景。我们来回顾一下，你可以使用的方式有：</p>
<ul>
<li><strong>直接创建完整索引</strong>，这样可能比较占用空间；</li>
<li><strong>创建前缀索引</strong>，节省空间，<strong>但会增加查询扫描次数，并且不能使用覆盖索引</strong>；</li>
<li><strong>倒序存储</strong>，<strong>再创建前缀索引</strong>，用于绕过字符串本身前缀的区分度不够的问题；</li>
<li><strong>创建hash字段索引</strong>，查询性能稳定，有额外的存储和计算消耗，<strong>跟第三种方式一样，都不支持范围扫描</strong>。</li>
</ul>
<p>在实际应用中，你要根据业务字段的特点选择使用哪种方式。</p>
<p>如果你在维护一个学校的学生信息数据库，学生登录名的统一格式是”学号@gmail.com”, 而学号的规则是：十五位的数字，其中前三位是所在城市编号、第四到第六位是学校编号、第七位到第十位是入学年份、最后五位是顺序编号。</p>
<p>系统登录的时候都需要学生输入登录名和密码，验证正确后才能继续使用系统。就只考虑登录验证这个行为的话，你会怎么设计这个登录名的索引呢？</p>
<h3 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h3><p>上篇文章中的第一个例子，大家要检查一下隔离级别是不是RR（Repeatable Read，可重复读），创建的表t是不是InnoDB引擎。</p>
<p>在上一篇文章最后，我给你留的问题是，为什么经过这个操作序列，explain的结果就不对了？这里，我来为你分析一下原因。</p>
<p>delete 语句删掉了所有的数据，然后再通过call idata()插入了10万行数据，看上去是覆盖了原来的10万行。</p>
<p>但是，session A<strong>开启了事务并没有提交，所以之前插入的10万行数据是不能删除的</strong>。这样，<strong>之前的数据每一行数据都有两个版本，旧版本是delete之前的数据，新版本是标记为deleted的数据。</strong></p>
<p>这样，索引a上的数据其实就有两份。</p>
<p>然后你会说，不对啊，主键上的数据也不能删，那没有使用force index的语句，使用explain命令看到的扫描行数为什么还是100000左右？（潜台词，如果这个也翻倍，也许优化器还会认为选字段a作为索引更合适）</p>
<p><strong>是的，不过这个是主键，主键是直接按照表的行数来估计的。而表的行数，优化器直接用的是show table status的值。</strong></p>
<p>这个值的计算方法，我会在后面有文章为你详细讲解。</p>
<p><img src="/2024/09/11/MySQL11/image-20240911103410211.png" alt="image-20240911103410211"></p>
<blockquote>
<p>大家的机器如果<strong>IO能力比较差</strong>的话，做这个验证的时候，可以把<strong>innodb_flush_log_at_trx_commit 和 sync_binlog 都设置成0。</strong></p>
</blockquote>
<p>参考文章：<a href="https://jums.gitbook.io/mysql-shi-zhan-45-jiang/11-zen-mo-gei-zi-fu-chuan-zi-duan-jia-suo-yin">11 怎么给字符串字段加索引？ | MySql实战45讲 (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么我的MySQL会“抖”一下？</title>
    <url>/2024/09/11/MySQL12/</url>
    <content><![CDATA[<p>平时的工作中，不知道你有没有遇到过这样的场景，<strong>一条SQL语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。</strong></p>
<p>看上去，这就像是数据库“抖”了一下。今天，我们就一起来看一看这是什么原因。</p>
<h3 id="你的SQL语句为什么变“慢”了"><a href="#你的SQL语句为什么变“慢”了" class="headerlink" title="你的SQL语句为什么变“慢”了"></a>你的SQL语句为什么变“慢”了</h3><p>在前面第2篇文章<a href="https://time.geekbang.org/column/article/68633">《日志系统：一条SQL更新语句是如何执行的？》</a>中，我为你介绍了WAL机制。现在你知道了，<strong>InnoDB在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作redo log（重做日志），也就是《孔乙己》里咸亨酒店掌柜用来记账的粉板，在更新内存写完redo log后，就返回给客户端，本次更新成功。</strong></p>
<p>做下类比的话，<strong>掌柜记账的账本是数据文件，记账用的粉板是日志文件（redo log），掌柜的记忆就是内存</strong>。</p>
<p>掌柜总要找时间把账本更新一下，<strong>这对应的就是把内存里的数据写入磁盘的过程，术语就是flush</strong>。在这个flush操作执行之前，孔乙己的赊账总额，其实跟掌柜手中账本里面的记录是不一致的。因为孔乙己今天的赊账金额还只在粉板上，而账本里的记录是老的，还没把今天的赊账算进去。</p>
<p><strong>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</strong>。</p>
<p>不论是脏页还是干净页，都在内存中。在这个例子里，内存对应的就是掌柜的记忆。</p>
<p>接下来，我们用一个示意图来展示一下“孔乙己赊账”的整个操作过程。假设原来孔乙己欠账10文，这次又要赊9文。</p>
<p><img src="/2024/09/11/MySQL12/image-20240911105754102.png" alt="image-20240911105754102"></p>
<p>回到文章开头的问题，<strong>你不难想象，平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）</strong>。</p>
<p>那么，什么情况会引发数据库的flush过程呢？</p>
<p>我们还是继续用咸亨酒店掌柜的这个例子，想一想：掌柜在什么情况下会把粉板上的赊账记录改到账本上？</p>
<ul>
<li>第一种场景是，<strong>粉板满了，记不下了。这时候如果再有人来赊账，掌柜就只得放下手里的活儿，将粉板上的记录擦掉一些，留出空位以便继续记账。</strong>当然在擦掉之前，他必须先将正确的账目记录到账本中才行。 这个场景，<strong>对应的就是InnoDB的redo log写满了。这时候系统会停止所有更新操作（STW），把checkpoint往前推进，redo log留出空间可以继续写</strong>。我在第二讲画了一个redo log的示意图，这里我改成环形，便于大家理解。</li>
</ul>
<p><img src="/2024/09/11/MySQL12/image-20240911105804571.png" alt="image-20240911105804571"></p>
<p>checkpoint可不是随便往前修改一下位置就可以的。比如图2中，<strong>把checkpoint位置从CP推进到CP’</strong>，就需要将两个点之间的日志（浅绿色部分），<strong>对应的所有脏页都flush到磁盘上。之后，图中从write pos到CP’之间就是可以再写入的redo log的区域。</strong></p>
<ul>
<li>第二种场景是，这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，<strong>赶紧找出账本把孔乙己这笔账先加进去。 这种场景，对应的就是系统内存不足</strong>。当需要新的内存页，而内存不够用的时候，<strong>就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。</strong> 你一定会说，<strong>这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿redo log出来应用不就行了？这里其实是从性能考虑的。如果刷脏页一定会写盘</strong>，就保证了每个数据页有两种状态：<ul>
<li><strong>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</strong></li>
<li><strong>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。 这样的效率最高。</strong></li>
</ul>
</li>
<li><strong>第三种场景是，生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不如更新账本。</strong> 这种场景，<strong>对应的就是MySQL认为系统“空闲”的时候</strong>。当然，MySQL“这家酒店”的生意好起来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，<strong>即使是“生意好”的时候，也要见缝插针地找时间，只要有机会就刷一点“脏页”</strong>。</li>
<li><strong>第四种场景是，年底了咸亨酒店要关门几天，需要把账结清一下。</strong>这时候掌柜要把所有账都记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了。 <strong>这种场景，对应的就是MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快</strong>。</li>
</ul>
<p>接下来，<strong>你可以分析一下上面四种场景对性能的影响。</strong></p>
<p>其中，<strong>第三种情况是属于MySQL空闲时的操作，这时系统没什么压力，而第四种场景是数据库本来就要关闭了。这两种情况下，你不会太关注“性能”问题</strong>。所以这里，我们主要来分析一下前两种场景下的性能问题。</p>
<p>第一种是“redo log写满了，要flush脏页”，这种情况是InnoDB要尽量避免的。<strong>因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为0。</strong></p>
<p>第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。<strong>InnoDB用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</strong></p>
<ul>
<li><strong>第一种是，还没有使用的；</strong></li>
<li><strong>第二种是，使用了并且是干净页；</strong></li>
<li><strong>第三种是，使用了并且是脏页。</strong></li>
</ul>
<p>InnoDB的策略是<strong>尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少</strong>。</p>
<p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。<strong>这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</strong></p>
<p>所以，<strong>刷脏页虽然是常态</strong>，但是出现以下这两种情况，都是会明显影响性能的：</p>
<ol>
<li><strong>一个查询要获取的新的数据页较多，会淘汰太多脏页，导致查询的响应时间明显变长；</strong></li>
<li><strong>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。</strong></li>
</ol>
<p>所以，InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p>
<h3 id="InnoDB刷脏页的控制策略"><a href="#InnoDB刷脏页的控制策略" class="headerlink" title="InnoDB刷脏页的控制策略"></a>InnoDB刷脏页的控制策略</h3><p>接下来，我就来和你说说InnoDB脏页的控制策略，以及和这些策略相关的参数。</p>
<p><strong>首先，你要正确地告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时候，可以刷多快。</strong></p>
<p>这就要用到<strong>innodb_io_capacity这个参数了，它会告诉InnoDB你的磁盘能力</strong>。<strong>这个值我建议你设置成磁盘的IOPS。磁盘的IOPS可以通过fio这个工具来测试，下面的语句是我用来测试磁盘随机读写的命令：</strong></p>
<p>关于IOPS可以看看这篇文章：</p>
<ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/668976764">一文读懂：IOPS、延迟和吞吐量等存储性能指标 - 知乎 (zhihu.com)</a></p>
<p><strong>我们举个简单的栗子</strong>，就像我们上班坐地铁一样，<strong>地铁上一个和下一个人可以看作存储系统的I&#x2F;O，IOPS就相当于（地铁上的人+地铁下的人）&#x2F;停留时间（秒）。</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest </span><br></pre></td></tr></table></figure>

<p>其实，<strong>因为没能正确地设置innodb_io_capacity参数，而导致的性能问题也比比皆是</strong>。之前，就曾有其他公司的开发负责人找我看一个库的性能问题，说<strong>MySQL的写入速度很慢，TPS很低，但是数据库主机的IO压力并不大。经过一番排查，发现罪魁祸首就是这个参数的设置出了问题</strong>。</p>
<p>他的主机磁盘用的是SSD，<strong>但是innodb_io_capacity的值设置的是300。于是，InnoDB认为这个系统的能力就这么差，所以刷脏页刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了脏页累积，影响了查询和更新性能</strong>。</p>
<p><strong>虽然我们现在已经定义了“全力刷脏页”的行为，但平时总不能一直是全力刷吧？毕竟磁盘能力不能只用来刷脏页，还需要服务用户请求。所以接下来，我们就一起看看InnoDB怎么控制引擎按照“全力”的百分比来刷脏页。</strong></p>
<p>根据我前面提到的知识点，试想一下，<strong>如果你来设计策略控制刷脏页的速度，会参考哪些因素呢？</strong></p>
<p>这个问题可以这么想，如果刷太慢，会出现什么情况？<strong>首先是内存脏页太多，其次是redo log写满。</strong></p>
<p>所以，InnoDB的刷盘速度就是要参考这两个因素：<strong>一个是脏页比例，一个是redo log写盘速度。</strong></p>
<p>InnoDB会根据这两个因素先单独算出两个数字。</p>
<p>参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%。InnoDB会根据当前的脏页比例（假设为M），算出一个范围在0到100之间的数字，计算这个数字的伪代码类似这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  if M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      return 100;</span><br><span class="line">  return 100*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InnoDB每次写入的日志都有一个序号，<strong>当前写入的序号跟checkpoint对应的序号之间的差值，我们假设为N</strong>。InnoDB会根据这个N算出一个<strong>范围在0到100之间的数字</strong>，这个计算公式可以记为F2(N)。F2(N)算法比较复杂，你只要知道N越大，算出来的值越大就好了。</p>
<p>然后，<strong>根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。</strong></p>
<p>上述的计算流程比较抽象，不容易理解，所以我画了一个简单的流程图。图中的F1、F2就是上面我们通过脏页比例和redo log写入速度算出来的两个值。</p>
<p><img src="/2024/09/11/MySQL12/image-20240911105833495.png" alt="image-20240911105833495"></p>
<p>现在你知道了，<strong>InnoDB会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源并可能影响到了你的更新语句</strong>，都可能是造成你从业务端感知到MySQL“抖”了一下的原因。</p>
<p>要尽量避免这种情况，你就要<strong>合理地设置innodb_io_capacity</strong>的值，并且**平时要多关注脏页比例，不要让它经常接近75%**。</p>
<p>其中，脏页比例是通过Innodb_buffer_pool_pages_dirty&#x2F;Innodb_buffer_pool_pages_total得到的，具体的命令参考下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = &#x27;Innodb_buffer_pool_pages_dirty&#x27;;</span><br><span class="line">select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = &#x27;Innodb_buffer_pool_pages_total&#x27;;</span><br><span class="line">select @a/@b;</span><br></pre></td></tr></table></figure>

<p>接下来，我们再看一个有趣的策略。</p>
<p><strong>一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢了</strong>。而MySQL中的一个机制，可能让你的查询会更慢：<strong>在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷</strong>。</p>
<p>在InnoDB中，innodb_flush_neighbors 参数就是用来控制这个行为的，<strong>值为1的时候会有上述的“连坐”机制，值为0时表示不找邻居，自己刷自己的</strong>。</p>
<p>找“邻居”这个优化在机械硬盘时代是很有意义的，<strong>可以减少很多随机IO。机械硬盘的随机IOPS一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升</strong>。</p>
<p>而如果使用的是SSD这类IOPS比较高的设备的话，<strong>我就建议你把innodb_flush_neighbors的值设置成0。因为这时候IOPS往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少SQL语句响应时间。</strong></p>
<p><strong>在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天这篇文章，我延续第2篇中介绍的WAL的概念，<strong>和你解释了这个机制后续需要的刷脏页操作和执行时机</strong>。利用WAL技术，<strong>数据库将随机写转换成了顺序写，大大提升了数据库的性能</strong>。</p>
<p>但是，<strong>由此也带来了内存脏页的问题。脏页会被后台线程自动flush，也会由于数据页淘汰而触发flush，而刷脏页的过程由于会占用资源，可能会让你的更新和查询语句的响应时间长一些</strong>。在文章里，我也给你介绍了控制刷脏页的方法和对应的监控方式。</p>
<p>一个内存配置为128GB、innodb_io_capacity设置为20000的大规格实例，正常会建议你将redo log设置成4个1GB的文件。</p>
<p>但如果你在配置的时候不慎将redo log设置成了1个100M的文件，会发生什么情况呢？又为什么会出现这样的情况呢？</p>
<h3 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h3><p>上期我留给你的问题是，给一个学号字段创建索引，有哪些方法。</p>
<p>由于这个学号的规则，<strong>无论是正向还是反向的前缀索引，重复度都比较高。因为维护的只是一个学校的，因此前面6位（其中，前三位是所在城市编号、第四到第六位是学校编号）其实是固定</strong>的，邮箱后缀都是@gamil.com，<strong>因此可以只存入学年份加顺序编号，它们的长度是9位</strong>。</p>
<p>而其实在此基础上，<strong>可以用数字类型来存这9位数字。比如201100001，这样只需要占4个字节。其实这个就是一种hash</strong>，只是它用了最简单的转换规则：<strong>字符串转数字的规则，而刚好我们设定的这个背景，可以保证这个转换后结果的唯一性</strong>。</p>
<p>一个学校的总人数这种数据量，50年才100万学生，这个表肯定是小表。<strong>为了业务简单，直接存原来的字符串。这个答复里面包含了“优化成本和收益”的思想，我觉得值得at出来</strong>。</p>
<p>如果碰到表数据量特别大的场景，通过这种方式的收益是很不错的。</p>
<blockquote>
<p>用整型存<strong>“四位年份+五位编号”</strong>的方法； <strong>由于整个学号的值超过了int上限，用8个字节的bigint来存的方法。</strong></p>
</blockquote>
<p>参考文章：<a href="https://jums.gitbook.io/mysql-shi-zhan-45-jiang/12-wei-shi-mo-wo-de-mysql-hui-dou-yi-xia">12 为什么我的MySQL会“抖”一下？ | MySql实战45讲 (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么表数据删掉一半，表文件大小不变？</title>
    <url>/2024/09/11/MySQL13/</url>
    <content><![CDATA[<p>经常会有同学来问我，<strong>我的数据库占用空间太大，我把一个最大的表删掉了一半的数据，怎么表文件的大小还是没变？</strong></p>
<p>那么今天，我就和你聊聊<strong>数据库表的空间回收</strong>，看看如何解决这个问题。</p>
<p>这里，我们还是针对MySQL中应用最广泛的InnoDB引擎展开讨论。<strong>一个InnoDB表包含两部分，即：表结构定义和数据</strong>。在MySQL 8.0版本以前，<strong>表结构是存在以.frm为后缀的文件里</strong>。而MySQL 8.0版本，<strong>则已经允许把表结构定义放在系统数据表中了</strong>。<strong>因为表结构定义占用的空间很小，所以我们今天主要讨论的是表数据。</strong></p>
<p>接下来，我会先和你说明为什么简单地删除表数据达不到表空间回收的效果，然后再和你介绍正确回收空间的方法。</p>
<h3 id="参数innodb-file-per-table"><a href="#参数innodb-file-per-table" class="headerlink" title="参数innodb_file_per_table"></a>参数innodb_file_per_table</h3><p>表数据既可以<strong>存在共享表空间里，也可以是单独的文件。这个行为是由参数innodb_file_per_table控制的</strong>：</p>
<ol>
<li>这个参数设置为OFF表示的是，<strong>表的数据放在系统共享表空间，也就是跟数据字典放在一起</strong>；</li>
<li>这个参数设置为ON表示的是，<strong>每个InnoDB表数据存储在一个以 .ibd为后缀的文件中</strong>。</li>
</ol>
<p>从MySQL 5.6.6版本开始，<strong>它的默认值就是ON了</strong>。</p>
<p>我建议你不论使用MySQL的哪个版本，<strong>都将这个值设置为ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过drop table命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</strong></p>
<p>所以，<strong>将innodb_file_per_table设置为ON，是推荐做法，我们接下来的讨论都是基于这个设置展开的。</strong></p>
<p>我们在删除整个表的时候，可以使用drop table命令回收表空间。<strong>但是，我们遇到的更多的删除数据的场景是删除某些行，这时就遇到了我们文章开头的问题：表中的数据被删除了，但是表空间却没有被回收。</strong></p>
<p>我们要彻底搞明白这个问题的话，就要从数据删除流程说起了。</p>
<h3 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h3><p>我们先再来看一下InnoDB中一个索引的示意图。在前面<a href="https://time.geekbang.org/column/article/69236">第4</a>和<a href="https://time.geekbang.org/column/article/69636">第5</a>篇文章中，我和你介绍索引时曾经提到过，<strong>InnoDB里的数据都是用B+树的结构组织的。</strong></p>
<p><img src="/2024/09/11/MySQL13/image-20240911145519977.png" alt="image-20240911145519977"></p>
<p>假设，我们要删掉R4这个记录，<strong>InnoDB引擎只会把R4这个记录标记为删除。如果之后要再插入一个ID在300和600之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</strong></p>
<p>现在，你已经知道了InnoDB的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记录，会怎么样？</p>
<p><strong>答案是，整个数据页就可以被复用了。</strong></p>
<p>但是，<strong>数据页的复用跟记录的复用是不同的。</strong></p>
<p>记录的复用，只限于符合范围条件的数据。比如上面的这个例子，R4这条记录被删除后，<strong>如果插入一个ID是400的行，可以直接复用这个空间。但如果插入的是一个ID是800的行，就不能复用这个位置了。</strong></p>
<p><strong>而当整个页从B+树里面摘掉以后，可以复用到任何位置。以图1为例，如果将数据页page A上的所有记录删除以后，page A会被标记为可复用。这时候如果要插入一条ID&#x3D;50的记录需要使用新页的时候，page A是可以被复用的。</strong></p>
<p><strong>如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。</strong></p>
<p>进一步地，如果我们用delete命令把整个表的数据删除呢？结果就是，<strong>所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。</strong></p>
<p>你现在知道了，<strong>delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过delete命令是不能回收表空间的</strong>。这些可以复用，<strong>而没有被使用的空间，看起来就像是“空洞”（怎么这里也出现了空洞）</strong>。</p>
<p>实际上，<strong>不止是删除数据会造成空洞，插入数据也会。</strong></p>
<p><strong>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</strong></p>
<p>假设图1中page A已经满了，这时我要再插入一行数据，会怎样呢？</p>
<p><img src="/2024/09/11/MySQL13/image-20240911145535516.png" alt="image-20240911145535516"></p>
<p><strong>可以看到，由于page A满了，再插入一个ID是550的数据时，就不得不再申请一个新的页面page B来保存数据了。页分裂完成后，page A的末尾就留下了空洞（注意：实际上，可能不止1个记录的位置是空洞）。</strong></p>
<p>另外，更新索引上的值，<strong>可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的</strong>。</p>
<p><strong>也就是说，经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。</strong></p>
<p><strong>而重建表，就可以达到这样的目的。（我记得前面有讲过，例子还是重建索引）</strong></p>
<h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>试想一下，如果你现在有一个表A，需要做空间收缩，为了把表中存在的空洞去掉，你可以怎么做呢？</p>
<p><strong>你可以新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行一行地从表A里读出来再插入到表B中。</strong></p>
<p>由于表B是新建的表，<strong>所以表A主键索引上的空洞，在表B中就都不存在了</strong>。显然地，表B的主键索引<strong>更紧凑</strong>，数据页的<strong>利用率也更高</strong>。如果我们把表B<strong>作为临时表，数据从表A导入表B的操作完成后，用表B替换A，从效果上看，就起到了收缩表A空间的作用</strong>。</p>
<p>这里，你可以使用<strong>alter table A engine&#x3D;InnoDB命令来重建表。在MySQL 5.5版本之前，这个命令的执行流程跟我们前面描述的差不多，区别只是这个临时表B不需要你自己创建，MySQL会自动完成转存数据、交换表名、删除旧表的操作。</strong></p>
<p><img src="/2024/09/11/MySQL13/image-20240911145555956.png" alt="image-20240911145555956"></p>
<p>显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表A的话，就会造成数据丢失。<strong>因此，在整个DDL过程中，表A中不能有更新。也就是说，这个DDL不是Online的。</strong></p>
<p>而在<strong>MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。</strong></p>
<p>我给你简单描述一下<strong>引入了Online DDL之后</strong>，重建表的流程：</p>
<ol>
<li><strong>建立一个临时文件</strong>，扫描表A主键的所有数据页；</li>
<li>用数据页中表A的记录<strong>生成B+树，存储到临时文件中；</strong></li>
<li>生成临时文件的过程中，<strong>将所有对A的操作记录在一个日志文件（row log）中，对应的是图中state2的状态；</strong></li>
<li>临时文件生成后，<strong>将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件，对应的就是图中state3的状态；</strong></li>
<li>用<strong>临时文件替换表A的数据文件。</strong></li>
</ol>
<p><img src="/2024/09/11/MySQL13/image-20240911145607197.png" alt="image-20240911145607197"></p>
<p>可以看到，与图3过程的不同之处在于，<strong>由于日志文件记录和重放操作这个功能的存在，这个方案在重建表的过程中，允许对表A做增删改操作。这也就是Online DDL名字的来源。</strong></p>
<p>DDL之类的忘记了建议看看这篇文章</p>
<ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/391552199">SQL语言：DDL、DML、DQL、DCL详解 - 知乎 (zhihu.com)</a></p>
<p>简单的说，DDL修改表，DML修改行，DQL查询行，DCL权限控制</p>
</li>
</ul>
<p>我记得有同学在第6篇讲表锁的文章<a href="https://time.geekbang.org/column/article/69862">《全局锁和表锁 ：给表加个字段怎么索这么多阻碍？》</a>的评论区留言说，<strong>DDL之前是要拿MDL写锁的，这样还能叫Online DDL吗？</strong></p>
<p>确实，图4的流程中，<strong>alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。</strong></p>
<p>为什么要退化呢？<strong>为了实现Online，MDL读锁不会阻塞增删改操作。</strong></p>
<p>那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做DDL。</p>
<p>而对于一个大表来说，<strong>Online DDL最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个DDL过程来说，锁的时间非常短。对业务来说，就可以认为是Online的。</strong></p>
<p>需要补充说明的是，<strong>上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗IO和CPU资源的。</strong>因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，我推荐你使用GitHub开源的gh-ost来做。</p>
<h3 id="Online-和-inplace"><a href="#Online-和-inplace" class="headerlink" title="Online 和 inplace"></a>Online 和 inplace</h3><p>说到Online，我还要再和你澄清一下它和另一个跟DDL有关的、容易混淆的概念inplace的区别。</p>
<p><img src="/2024/09/11/MySQL13/image-20240911154457500.png" alt="image-20240911154457500"></p>
<p>你可能注意到了，在图3中，<strong>我们把表A中的数据导出来的存放位置叫作tmp_table。这是一个临时表，是在server层创建的。</strong></p>
<p><img src="/2024/09/11/MySQL13/image-20240911154505918.png" alt="image-20240911154505918"></p>
<p>在图4中，根据表A重建出来的数据是放在“tmp_file”里的，这个临时文件是<strong>InnoDB在内部创建出来的。整个DDL过程都在InnoDB内部完成</strong>。<strong>对于server层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。</strong></p>
<p><strong>所以，我现在问你，如果你有一个1TB的表，现在磁盘间是1.2TB，能不能做一个inplace的DDL呢？</strong></p>
<p><strong>答案是不能。因为，tmp_file也是要占用临时空间的。</strong></p>
<p>我们<strong>重建表的这个语句alter table t engine&#x3D;InnoDB，其实隐含的意思是：（InnoDB内部）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table t engine=innodb,ALGORITHM=inplace;</span><br></pre></td></tr></table></figure>

<p><strong>跟inplace对应的就是拷贝表（server层）的方式了</strong>，用法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table t engine=innodb,ALGORITHM=copy;</span><br></pre></td></tr></table></figure>

<p>当你使用ALGORITHM&#x3D;copy的时候，表示的是<strong>强制拷贝表</strong>，对应的流程就是图3的操作过程。</p>
<p>但我这样说你可能会觉得，inplace跟Online是不是就是一个意思？</p>
<p>其实不是的，只是在重建表这个逻辑中刚好是这样而已。</p>
<p>比如，如果我要给InnoDB表的一个字段加全文索引，写法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table t add FULLTEXT(field_name);</span><br></pre></td></tr></table></figure>

<p><strong>这个过程是inplace的，但会阻塞增删改操作，是非Online的。</strong></p>
<p>如果说这两个逻辑之间的关系是什么的话，可以概括为：</p>
<ol>
<li>DDL过程<strong>如果是Online的，就一定是inplace的</strong>；</li>
<li>反过来未必，也就是说inplace的DDL，有可能不是Online的。截止到MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引(SPATIAL index)就属于这种情况。</li>
</ol>
<p>最后，我们再延伸一下。</p>
<p>在第10篇文章<a href="https://time.geekbang.org/column/article/71173">《MySQL为什么有时候会选错索引》</a>的评论区中，有同学问到使用optimize table、analyze table和alter table这三种方式重建表的区别。这里，我顺便再简单和你解释一下。</p>
<ul>
<li>从MySQL 5.6版本开始，<strong>alter table t engine &#x3D; InnoDB（也就是recreate）默认的就是上面图4的流程了；</strong></li>
<li>analyze table t <strong>其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁；</strong></li>
<li>optimize table t <strong>等于recreate+analyze。</strong></li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天这篇文章，我和你讨论了数据库中收缩表空间的方法。</p>
<p><strong>现在你已经知道了，如果要收缩一个表，只是delete掉表里面不用的数据的话，表文件的大小是不会变的，你还要通过alter table命令重建表，才能达到表文件变小的目的</strong>。我跟你介绍了<strong>重建表的两种实现方式，Online DDL的方式是可以考虑在业务低峰期使用的，而MySQL 5.5及之前的版本，这个命令是会阻塞DML的，这个你需要特别小心</strong>。</p>
<p>假设现在有人碰到了一个“想要收缩表空间，结果适得其反”的情况，看上去是这样的：</p>
<ol>
<li>一个表t文件大小为1TB；</li>
<li>对这个表执行 alter table t engine&#x3D;InnoDB；</li>
<li>发现执行完成后，空间不仅没变小，还稍微大了一点儿，比如变成了1.01TB。</li>
</ol>
<p>你觉得可能是什么原因呢 ？</p>
<h3 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h3><p>在上期文章最后，我留给你的问题是，如果一个高配的机器，redo log设置太小，会发生什么情况。</p>
<p><strong>每次事务提交都要写redo log，如果设置太小，很快就会被写满，也就是下面这个图的状态，这个“环”将很快被写满，write pos一直追着CP。</strong></p>
<p><img src="/2024/09/11/MySQL13/image-20240911145857781.png" alt="image-20240911145857781"></p>
<p><strong>这时候系统不得不停止所有更新，去推进checkpoint。</strong></p>
<p>这时，你看到的现象就是<strong>磁盘压力很小，但是数据库出现间歇性的性能下跌。</strong></p>
<blockquote>
<p>在这种情况下，<strong>连change buffer的优化也失效了。</strong></p>
<p><strong>因为checkpoint一直要往前推，这个操作就会触发merge操作，然后又进一步地触发刷脏页操作；</strong></p>
<p> 有几个同学提到了<strong>内存淘汰脏页，对应的redo log的操作</strong>，这个我们会在后面的文章中展开，大家可以先看一下 </p>
</blockquote>
<p>参考文章：<a href="https://jums.gitbook.io/mysql-shi-zhan-45-jiang/13-wei-shi-mo-biao-shu-ju-shan-diao-yi-ban-biao-wen-jian-da-xiao-bu-bian#xiao-jie">13 为什么表数据删掉一半，表文件大小不变？ | MySql实战45讲 (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
